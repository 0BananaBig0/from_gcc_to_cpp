<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>const, constexpr and static - from_gcc_to_cpp</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">from_gcc_to_cpp</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../FromGccToCPP/" class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../Gcc/" class="nav-link">Gcc</a>
                            </li>
                            <li class="navitem">
                                <a href="../makeAndMakefiles/" class="nav-link">make and Makefiles</a>
                            </li>
                            <li class="navitem">
                                <a href="../Git/" class="nav-link">Git</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">CPP <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../CPPPerface/" class="dropdown-item">CPP Perface</a>
</li>
                                    
<li>
    <a href="../MemoryPartitions/" class="dropdown-item">Memory Partitions</a>
</li>
                                    
<li>
    <a href="../AutoAndDecltype/" class="dropdown-item">auto and decltype</a>
</li>
                                    
<li>
    <a href="../UsingTypedefNameSpaces/" class="dropdown-item">using, typedef and Namespaces</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">const, constexpr and static</a>
</li>
                                    
<li>
    <a href="../Volatile/" class="dropdown-item">volatile</a>
</li>
                                    
<li>
    <a href="../MacrosAndPragma/" class="dropdown-item">Macros and Related Keywords ( Including pragma</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Functions, Classes, Operators And Templates <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../Functions/" class="dropdown-item">Functions</a>
</li>
                                    
<li>
    <a href="../Classes/" class="dropdown-item">Classes</a>
</li>
                                    
<li>
    <a href="../HidingOverloadingOverridingAndOverwriting/" class="dropdown-item">Hiding, Overloading, Overriding, and Overwriting</a>
</li>
                                    
<li>
    <a href="../Structures/" class="dropdown-item">Structures</a>
</li>
                                    
<li>
    <a href="../Operators/" class="dropdown-item">Operators</a>
</li>
                                    
<li>
    <a href="../NewAndDelete/" class="dropdown-item">new and delete</a>
</li>
                                    
<li>
    <a href="../Templates/" class="dropdown-item">Templates</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Data Structures and Algorithms <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../IntroductionToTheCPPSTL/" class="dropdown-item">Introduction to C++ STL</a>
</li>
                                    
<li>
    <a href="../ConversionAndCasting/" class="dropdown-item">Conversion And Casting</a>
</li>
                                    
<li>
    <a href="../Bindings/" class="dropdown-item">Bindings</a>
</li>
                                    
<li>
    <a href="../StdBindAndStdFunction/" class="dropdown-item">std::bind and std::function</a>
</li>
                                    
<li>
    <a href="../Arrays/" class="dropdown-item">Arrays</a>
</li>
                                    
<li>
    <a href="../DynamicArraysOrStdVector/" class="dropdown-item">Dynamic Arrays (std::vector</a>
</li>
                                    
<li>
    <a href="../ListsAndForwardLists/" class="dropdown-item">Lists and Forward Lists</a>
</li>
                                    
<li>
    <a href="../SetsUnorderedSetsAndFlatSets/" class="dropdown-item">Sets Unordered Sets and Flat Sets</a>
</li>
                                    
<li>
    <a href="../MapsUnorderedMapsAndFlatMaps/" class="dropdown-item">Maps Unordered Maps and Flat Maps</a>
</li>
                                    
<li>
    <a href="../StacksAndQueues/" class="dropdown-item">Stacks and Queues</a>
</li>
                                    
<li>
    <a href="../Enums/" class="dropdown-item">enum</a>
</li>
                                    
<li>
    <a href="../UnionStdAnyStdVariantStdOptional/" class="dropdown-item">union, std:any std::variant and std::optional</a>
</li>
                                    
<li>
    <a href="../CharsAndStrings/" class="dropdown-item">Chars and Strings</a>
</li>
                                    
<li>
    <a href="../PairsAndTuples/" class="dropdown-item">Pairs and Tuples</a>
</li>
                                    
<li>
    <a href="../SmartPointers/" class="dropdown-item">Smart Pointers</a>
</li>
                                    
<li>
    <a href="../Algorithms/" class="dropdown-item">Algorithms</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../Timers/" class="dropdown-item">Timers</a>
</li>
                                    
<li>
    <a href="../Threads/" class="dropdown-item">Threads</a>
</li>
                                    
<li>
    <a href="../StaticAssert/" class="dropdown-item">static_assert</a>
</li>
                                    
<li>
    <a href="../Extern/" class="dropdown-item">Extern</a>
</li>
                                    
<li>
    <a href="../SomeCFunctionsAndOperators/" class="dropdown-item">Some C Functions and Operators</a>
</li>
                                    
<li>
    <a href="../SomeProgrammingTechniques/" class="dropdown-item">Some Programming Techniques</a>
</li>
                                    
<li>
    <a href="../Handles/" class="dropdown-item">Handles</a>
</li>
                                    
<li>
    <a href="../FileIOs/" class="dropdown-item">FileIOs</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../UsingTypedefNameSpaces/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../Volatile/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-light">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="2"><a href="#const-constexpr-and-static" class="nav-link">const, constexpr and static</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#const-constexpr-and-static"><code>const</code>, <code>constexpr</code> and <code>static</code></a></li>
<li><a href="#const"><code>const</code></a><ul>
<li><a href="#explanation">Explanation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#const-variables"><code>const</code> Variables</a><ul>
<li><a href="#explanation-1">Explanation</a></li>
<li><a href="#syntax">Syntax</a></li>
</ul>
</li>
<li><a href="#const-pointers"><code>const</code> Pointers</a><ul>
<li><a href="#explanation-2">Explanation</a></li>
<li><a href="#syntax-1">Syntax</a></li>
</ul>
</li>
<li><a href="#const-references"><code>const</code> References</a><ul>
<li><a href="#explanation-3">Explanation</a></li>
<li><a href="#syntax-2">Syntax</a></li>
</ul>
</li>
<li><a href="#const-member-variables"><code>const</code> Member Variables</a><ul>
<li><a href="#explanation-4">Explanation</a></li>
<li><a href="#syntax-3">Syntax</a></li>
</ul>
</li>
<li><a href="#const-methods-const-member-functions"><code>const</code> Methods (<code>const</code> Member Functions)</a><ul>
<li><a href="#explanation-5">Explanation</a></li>
<li><a href="#syntax-4">Syntax</a></li>
</ul>
</li>
<li><a href="#const-function-parameters"><code>const</code> Function Parameters</a><ul>
<li><a href="#explanation-6">Explanation</a></li>
<li><a href="#syntax-5">Syntax</a></li>
</ul>
</li>
<li><a href="#const-return-values"><code>const</code> Return Values</a><ul>
<li><a href="#explanation-7">Explanation</a></li>
<li><a href="#syntax-6">Syntax</a></li>
</ul>
</li>
<li><a href="#const-return-pointers"><code>const</code> Return Pointers</a><ul>
<li><a href="#explanation-8">Explanation</a></li>
<li><a href="#syntax-7">Syntax</a></li>
</ul>
</li>
<li><a href="#const-return-references"><code>const</code> Return References</a><ul>
<li><a href="#explanation-9">Explanation</a></li>
<li><a href="#syntax-8">Syntax</a></li>
</ul>
</li>
<li><a href="#const-instances-of-classes"><code>const</code> Instances of Classes</a><ul>
<li><a href="#explanation-10">Explanation</a></li>
<li><a href="#syntax-9">Syntax</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#constexpr"><code>constexpr</code></a><ul>
<li><a href="#explanation-11">Explanation</a></li>
<li><a href="#allowed-elements-valid-elements">Allowed Elements (Valid Elements)</a></li>
<li><a href="#disallowed-elements">Disallowed Elements</a></li>
<li><a href="#usage-1">Usage</a></li>
<li><a href="#constexpr-variables"><code>constexpr</code> Variables</a><ul>
<li><a href="#explanation-12">Explanation</a></li>
<li><a href="#syntax-10">Syntax</a></li>
</ul>
</li>
<li><a href="#constexpr-pointers"><code>constexpr</code> Pointers</a><ul>
<li><a href="#explanation-13">Explanation</a></li>
<li><a href="#syntax-11">Syntax</a></li>
</ul>
</li>
<li><a href="#constexpr-references"><code>constexpr</code> References</a><ul>
<li><a href="#explanation-14">Explanation</a></li>
<li><a href="#syntax-12">Syntax</a></li>
</ul>
</li>
<li><a href="#constexpr-member-variables"><code>constexpr</code> Member Variables</a><ul>
<li><a href="#explanation-15">Explanation</a></li>
<li><a href="#syntax-13">Syntax</a></li>
</ul>
</li>
<li><a href="#constexpr-functions-constexpr-return-values"><code>constexpr</code> Functions (<code>constexpr</code> Return Values)</a><ul>
<li><a href="#explanation-16">Explanation</a></li>
<li><a href="#syntax-14">Syntax</a></li>
</ul>
</li>
<li><a href="#constexpr-constructors-c11-and-later"><code>constexpr</code> Constructors (C++11 and later)</a><ul>
<li><a href="#explanation-17">Explanation</a></li>
<li><a href="#syntax-15">Syntax</a></li>
</ul>
</li>
<li><a href="#constexpr-instances-of-classes"><code>constexpr</code> Instances of Classes</a><ul>
<li><a href="#explanation-18">Explanation</a></li>
<li><a href="#syntax-16">Syntax</a></li>
</ul>
</li>
<li><a href="#user-defined-literals">User-defined Literals</a><ul>
<li><a href="#explanation-19">Explanation</a></li>
<li><a href="#syntax-17">Syntax</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#static"><code>static</code></a><ul>
<li><a href="#explanation-20">Explanation</a></li>
<li><a href="#usage-2">Usage</a></li>
<li><a href="#static-local-variables"><code>static</code> Local Variables</a><ul>
<li><a href="#explanation-21">Explanation</a></li>
<li><a href="#syntax-18">Syntax</a></li>
</ul>
</li>
<li><a href="#static-global-variables"><code>static</code> Global Variables</a><ul>
<li><a href="#explanation-22">Explanation</a></li>
<li><a href="#syntax-19">Syntax</a></li>
</ul>
</li>
<li><a href="#static-member-variables"><code>static</code> Member Variables</a><ul>
<li><a href="#explanation-23">Explanation</a></li>
<li><a href="#syntax-20">Syntax</a></li>
</ul>
</li>
<li><a href="#static-methods-static-member-functions"><code>static</code> Methods (<code>static</code> Member Functions)</a><ul>
<li><a href="#explanation-24">Explanation</a></li>
<li><a href="#syntax-21">Syntax</a></li>
</ul>
</li>
<li><a href="#static-global-functions"><code>static</code> Global Functions</a><ul>
<li><a href="#explanation-25">Explanation</a></li>
<li><a href="#syntax-22">Syntax</a></li>
</ul>
</li>
<li><a href="#static-instances-of-classes"><code>static</code> Instances of Classes</a><ul>
<li><a href="#explanation-26">Explanation</a></li>
<li><a href="#syntax-23">Syntax</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="const-constexpr-and-static"><code>const</code>, <code>constexpr</code> and <code>static</code></h2>
<h3 id="const"><code>const</code></h3>
<h4 id="explanation">Explanation</h4>
<ol>
<li>The <code>const</code> <strong>keyword</strong> is used to <strong>declare constants or read-only variables</strong>.</li>
<li>When a variable is declared as <code>const</code>, its value <strong>cannot be modified</strong> after it is initialized.</li>
<li>This concept is beneficial for <strong>protecting data</strong> from unintended changes and for <strong>enhancing
   code readability and maintainability</strong>.</li>
<li>However, it is <strong>just a promise</strong> that programmers should keep something constant and <strong>can be
   broken</strong>.</li>
</ol>
<h4 id="usage">Usage</h4>
<h5 id="const-variables"><code>const</code> Variables</h5>
<h6 id="explanation_1">Explanation</h6>
<ol>
<li>A <code>const</code> variable is <strong>a variable</strong> whose value <strong>cannot be changed</strong> after it has been
   initialized.</li>
<li>The keyword <code>const</code> stands for "constant" and is used to define variables that should remain
   unchanged throughout their lifespan.</li>
<li>A <code>const</code> variable must <strong>be initialized when it is declared</strong>.</li>
<li>It can be <strong>evaluated at compile time</strong> if it is <strong>initialized with a constant expression</strong>.</li>
<li>It can bind to <strong>a literal value or a temporary result</strong>.</li>
</ol>
<h6 id="syntax">Syntax</h6>
<pre><code class="language-CPP">const Type var_name = value;
</code></pre>
<h5 id="const-pointers"><code>const</code> Pointers</h5>
<h6 id="explanation_2">Explanation</h6>
<ol>
<li><code>const Type* pointer_name;</code> means <strong>the value</strong> pointed to cannot be altered through this
   pointer.</li>
<li><code>Type* const pointer_name;</code> means <strong>the pointer address itself</strong> cannot be changed after it is
   initialized.</li>
</ol>
<h6 id="syntax_1">Syntax</h6>
<ol>
<li>Pointer to constant value: <code>const Type* ptr_name;</code></li>
<li>Constant pointer: <code>Type* const ptr_name;</code></li>
</ol>
<h5 id="const-references"><code>const</code> References</h5>
<h6 id="explanation_3">Explanation</h6>
<ol>
<li>A <code>const</code> reference is <strong>a reference</strong> that <strong>points to a value but cannot modify it</strong>.</li>
<li><code>const</code> references are commonly <strong>used to avoid copying large objects</strong> in function parameters or
   to ensure a value isn’t modified when it’s passed as a reference.</li>
<li><strong>a <code>const</code> reference</strong> can bind to <strong>a literal value or a temporary result</strong>.</li>
</ol>
<h6 id="syntax_2">Syntax</h6>
<pre><code class="language-CPP">const&amp; Type var_name = value;
</code></pre>
<h5 id="const-member-variables"><code>const</code> Member Variables</h5>
<h6 id="explanation_4">Explanation</h6>
<ol>
<li>A <code>const</code> data member <strong>must be initialized</strong> when the object is <strong>constructed</strong> because its
   value <strong>cannot be changed</strong> after initialization.</li>
<li>There are only two way to initialize a <code>const</code> member:</li>
<li><strong>In-class initialization</strong>:<ul>
<li>In-class initialization works well <strong>for constants of integral types (like int, char, etc.)
   or other literal types</strong>.</li>
<li>For <strong>non-integral types</strong>, <strong>initializer lists</strong> must be used.</li>
<li>It can be <strong>overridden</strong> by the constructor.</li>
</ul>
</li>
<li><strong>Constructor initializer lists</strong>.</li>
</ol>
<h6 id="syntax_3">Syntax</h6>
<pre><code class="language-CPP">class ClassName {
   private:
      // In-class initialization.
      const Type _mem = initializer;
};
</code></pre>
<h5 id="const-methods-const-member-functions"><code>const</code> Methods (<code>const</code> Member Functions)</h5>
<h6 id="explanation_5">Explanation</h6>
<ol>
<li>A <code>const</code> member method is <strong>a member function of a class</strong> that <strong>does not modify the object</strong>
   on which it is called.</li>
<li>This means the <code>const</code> member function <strong>can't modify any non-mutable member variables</strong> of the
   class or object.</li>
<li>In addition, a <code>const</code> function can <strong>be overloaded</strong> with other non-const functions, even if
   their names and parameter lists are the same.</li>
<li>This is possible because their signatures differ, as the <strong><code>const</code></strong> keyword <strong>modifies the
   function signatures</strong>.</li>
<li>However, if a member is of <strong>pointer</strong> type, <strong>the value or object</strong> the pointer points to does
   <strong>not belong to the class</strong>.</li>
<li><strong>Only the address</strong> stored in the pointer <strong>belongs to the class</strong>.</li>
<li>Therefore, a <code>const</code> function can <strong>still modify the pointed-to value or object</strong>.</li>
</ol>
<h6 id="syntax_4">Syntax</h6>
<pre><code class="language-CPP">RetType funcName( para_list ) const;
</code></pre>
<h5 id="const-function-parameters"><code>const</code> Function Parameters</h5>
<h6 id="explanation_6">Explanation</h6>
<ol>
<li>A <code>const</code> parameter is <strong>a parameter</strong> that <strong>receives an argument</strong> and <strong>ensures</strong> that the
   function <strong>does not change the argument</strong>.</li>
</ol>
<h6 id="syntax_5">Syntax</h6>
<pre><code class="language-CPP">void funcName( const Type para1, ... );
</code></pre>
<h5 id="const-return-values"><code>const</code> Return Values</h5>
<h6 id="explanation_7">Explanation</h6>
<ol>
<li><strong>Returning a <code>const</code> value</strong> from a function indicates that the returned value <strong>cannot be
   modified</strong> by the caller.</li>
<li>However, if <strong>a <code>const</code></strong> return value <strong>is assigned</strong> to <strong>a non-const</strong> variable, it <strong>becomes
   modifiable</strong> once the <strong>assignment operation</strong> is complete.</li>
</ol>
<h6 id="syntax_6">Syntax</h6>
<pre><code class="language-CPP">const RetType funcName( para_list ) {
    // Function body.
};
</code></pre>
<h5 id="const-return-pointers"><code>const</code> Return Pointers</h5>
<h6 id="explanation_8">Explanation</h6>
<ol>
<li>A function can return <strong>a pointer to a constant value</strong>, ensuring that <strong>the value</strong> being
   pointed to <strong>cannot be modified</strong> through the pointer.</li>
<li>To <strong>assign a <code>const</code> return pointer to a variable</strong>, the <strong>variable</strong> must likewise be <strong>a
   pointer to <code>const</code></strong>.</li>
</ol>
<h6 id="syntax_7">Syntax</h6>
<pre><code class="language-CPP">const returnType* funcName() {
    // Function body
};
</code></pre>
<h5 id="const-return-references"><code>const</code> Return References</h5>
<h6 id="explanation_9">Explanation</h6>
<ol>
<li>A function can return <strong>a reference to a constant object</strong>, allowing <strong>efficient access</strong> to the
   object while ensuring it <strong>cannot be modified</strong>.</li>
<li>To <strong>assign a <code>const</code> return reference to a variable</strong>, the <strong>variable</strong> must likewise be <strong>a
   <code>const</code> reference</strong>.</li>
</ol>
<h6 id="syntax_8">Syntax</h6>
<pre><code class="language-CPP">const returnType&amp; funcName() {
    // Function body
};
</code></pre>
<h5 id="const-instances-of-classes"><code>const</code> Instances of Classes</h5>
<h6 id="explanation_10">Explanation</h6>
<ol>
<li>A <code>const</code> instance <strong>ensures</strong> that none of its <strong>non-mutable members can be modified</strong> after
   initialization.</li>
<li>However, if a member is of <strong>pointer</strong> type, <strong>the value or object</strong> the pointer points to does
   <strong>not belong to the class</strong>.</li>
<li>Only the <strong>address</strong> stored in the pointer <strong>belongs to the class</strong>.</li>
<li>Therefore, a <code>const</code> instance <strong>cannot ensure</strong> that this <strong>value or object remains unmodified</strong>.</li>
<li><strong>Only const-qualified member functions can be called</strong> on a <code>const</code> instance. These are
   functions that do not modify the object’s state.</li>
<li>A <code>const</code> instance can still <strong>modify <code>mutable</code> members</strong>.</li>
</ol>
<h6 id="syntax_9">Syntax</h6>
<pre><code class="language-CPP">const ClassName obj_ptr;
</code></pre>
<h3 id="constexpr"><code>constexpr</code></h3>
<h4 id="explanation_11">Explanation</h4>
<ol>
<li>The <code>constexpr</code> <strong>keyword</strong> is used to <strong>declare variables and functions</strong> that can be
   <strong>evaluated at compile-time</strong>.</li>
<li>This feature allows the compiler to perform calculations and allocate memory for certain
   constructs even before the program runs.</li>
<li>When a variable or function is declared as <code>constexpr</code>, <strong>all elements related to it</strong> should be
   <strong>evaluated at compile time</strong>. For example, the function cannot contain any runtime I/O
   operations, as they cannot be evaluated at compile time.</li>
<li>It enforces that <strong>certain values and calculations</strong> can be <strong>performed at compile-time</strong>,
   leading to significant performance improvements.</li>
<li>Any variable or object declared with the <code>constexpr</code> keyword is constant and <strong>cannot be modified
   after it is initialized</strong>.</li>
<li>It enhances <strong>the code readabilit</strong>.</li>
</ol>
<h4 id="allowed-elements-valid-elements">Allowed Elements (Valid Elements)</h4>
<ol>
<li>Constant expressions (e.g., literals, <code>constexpr</code> variables).</li>
<li>Simple arithmetic operations.</li>
<li>Control flow statements (like if, switch, and loops) that do not depend on runtime values.</li>
</ol>
<h4 id="disallowed-elements">Disallowed Elements</h4>
<ol>
<li>Runtime I/O operations (e.g., std::cout).</li>
<li>Dynamic memory allocation.</li>
<li>Non-constexpr function calls (unless those functions are also <code>constexpr</code>).</li>
</ol>
<h4 id="usage_1">Usage</h4>
<h5 id="constexpr-variables"><code>constexpr</code> Variables</h5>
<h6 id="explanation_12">Explanation</h6>
<ol>
<li>A <code>constexpr</code> variable is <strong>a variable</strong> that <strong>must be initialized with an initializer</strong> that
   can be fully <strong>resolved at compile-time</strong>.</li>
<li>The <strong>initializer must</strong> be <strong>evaluated at compile time</strong>.</li>
</ol>
<h6 id="syntax_10">Syntax</h6>
<pre><code class="language-CPP">constexpr Type var_name = initializer;
</code></pre>
<h5 id="constexpr-pointers"><code>constexpr</code> Pointers</h5>
<h6 id="explanation_13">Explanation</h6>
<ol>
<li><code>constexpr</code> applies to the <strong>pointer itself</strong>, meaning <strong>the address</strong> stored in the pointer must
   <strong>be a constant expression</strong>.</li>
<li>The <strong>address</strong> stored in a <code>constexpr</code> pointer must <strong>be known at compile-time</strong>.</li>
</ol>
<h6 id="syntax_11">Syntax</h6>
<pre><code class="language-CPP">constexpr Type* var_name = initializer;
</code></pre>
<h5 id="constexpr-references"><code>constexpr</code> References</h5>
<h6 id="explanation_14">Explanation</h6>
<ol>
<li>A <code>constexpr</code> reference is <strong>a constant reference</strong> that can <strong>be evaluated at compile time</strong>.</li>
<li>It can bind to <strong>a literal value or a temporary result</strong>.</li>
<li><code>constexpr</code> references are used when you need a reference to a compile-time constant expression.</li>
<li>To declare a <code>constexpr</code> reference, it must be a const reference, and it must refer to a constant
   expression.</li>
</ol>
<h6 id="syntax_12">Syntax</h6>
<pre><code class="language-CPP">constexpr&amp; Type var_name = initializer;
</code></pre>
<h5 id="constexpr-member-variables"><code>constexpr</code> Member Variables</h5>
<h6 id="explanation_15">Explanation</h6>
<ol>
<li>A <code>constexpr</code> member variable is <strong>a variable</strong> defined within a class that can be <strong>initialized
   with constant expressions</strong>.</li>
<li>This allows them to be <strong>evaluated at compile time</strong>, which can lead to <strong>performance
   improvements</strong> and enable more complex compile-time computations.</li>
</ol>
<h6 id="syntax_13">Syntax</h6>
<pre><code class="language-CPP">class ClassName {
   public:
      constexpr Type _mem = initializer;
};
</code></pre>
<h5 id="constexpr-functions-constexpr-return-values"><code>constexpr</code> Functions (<code>constexpr</code> Return Values)</h5>
<h6 id="explanation_16">Explanation</h6>
<ol>
<li>A <code>constexpr</code> function is <strong>a function</strong> that will be <strong>evaluated at compile-time</strong> if <strong>given
   compile-time constant arguments</strong>.</li>
<li>If the result of a <code>constexpr</code> function is <strong>assigned to</strong> a variable, the best choice is to keep
   the variable as <strong>a <code>constexpr</code> variable</strong>.</li>
<li>This ensures that the variable is <strong>initialized at compile time</strong>, which means <strong>the result</strong> of
   the function is also <strong>evaluated at compile time</strong>.</li>
<li>Additionally, its <strong>parameters</strong> should be <strong><code>const</code> values</strong> or <strong>constant expressions</strong> to
   ensure that the function is executed at compile time.</li>
<li><strong><code>RetType</code></strong> must be <strong>a literal type</strong>, which includes integral types, floating-point types,
   pointers, and certain user-defined types.</li>
</ol>
<h6 id="syntax_14">Syntax</h6>
<pre><code class="language-CPP">constexpr RetType funcName( para_list ) {
    // Function body
};

constexpr RetType var_name = funcName( para_list );
</code></pre>
<h5 id="constexpr-constructors-c11-and-later"><code>constexpr</code> Constructors (C++11 and later)</h5>
<h6 id="explanation_17">Explanation</h6>
<ol>
<li>A <code>constexpr</code> constructor is <strong>a construcotr</strong> that can be used to <strong>create instances</strong> of the
   class with <strong>constant expressions</strong>.</li>
<li>When a <code>constexpr</code> constructor is used to construct an object, the best choice is to keep the
   <strong>object as a <code>constexpr</code> type</strong>, and <strong>its initializer</strong> should be <strong>evaluated at compile
   time</strong>.</li>
<li>Only when all related elements can be evaluated at compile time can the constructor also be
   evaluated at compile time.</li>
</ol>
<h6 id="syntax_15">Syntax</h6>
<pre><code class="language-CPP">class ClassName {
   public:
      // Initialize member variables at compile-time.
      constexpr ClassName( para_list ): ... {};

   private:
      ...;
};

constexpr ClassName obj_name( para_list );
</code></pre>
<h5 id="constexpr-instances-of-classes"><code>constexpr</code> Instances of Classes</h5>
<h6 id="explanation_18">Explanation</h6>
<ol>
<li>A <code>constexpr</code> instance is <strong>an object</strong> that is <strong>evaluated at compile-time</strong>, if all its
   dependencies (constructors, functions, and data) are also <code>constexpr</code>.</li>
<li>A <code>constexpr</code> instance must remain <strong>immutable</strong>, meaning its state cannot change after
   initialization.</li>
<li><strong>All data members</strong> must be <strong>initialized</strong> by <strong>the <code>constexpr</code> constructor</strong> since further
   modifications are not allowed.</li>
<li>The class <strong>must have a <code>constexpr</code> constructor</strong>.</li>
<li>All <strong>member functions</strong> invoked on a <code>constexpr</code> object <strong>must also be <code>constexpr</code></strong>.</li>
<li>Data members used in <code>constexpr</code> evaluation must be integral constants or themselves <code>constexpr</code>.</li>
<li>A <code>constexpr</code> instance <strong>is always <code>const</code></strong> implicitly, but the reverse is not true—<code>const</code>
   instances are not guaranteed to be evaluated at compile time.</li>
</ol>
<h6 id="syntax_16">Syntax</h6>
<pre><code class="language-CPP">constexpr ClassName obj_ptr;
</code></pre>
<h5 id="user-defined-literals">User-defined Literals</h5>
<h6 id="explanation_19">Explanation</h6>
<ol>
<li>User-defined literals allow you to <strong>create custom literal suffixes</strong> that <strong>extend the
   functionality of built-in literals</strong>.</li>
<li>This feature lets you <strong>define special behaviors for literals of various types</strong>, including
   integers, floating-point numbers, and strings.</li>
<li>It's especially useful for <strong>creating more readable code</strong>, <strong>adding context or units to
   values</strong>, and <strong>improving type safety</strong>.</li>
<li>User-defined literals are <strong>created by defining functions with specific naming and parameter
   rules</strong>.</li>
<li>They <strong>begin with an underscore</strong> and <strong>are appended to a literal to convert it into a specific
   type or to invoke custom logic</strong>.</li>
</ol>
<h6 id="syntax_17">Syntax</h6>
<pre><code class="language-CPP">constexpr RetType operator&quot;&quot; _name( Type para, ... ) {
   // Do something that can be evaluated at compile time.
   return ...;
}
</code></pre>
<h3 id="static"><code>static</code></h3>
<h4 id="explanation_20">Explanation</h4>
<ol>
<li>The <code>static</code> <strong>keyword</strong> in C++ is used to <strong>change the storage duration and visibility</strong> of
   variables and functions. It alters how variables are initialized and where they can be accessed.</li>
<li>All <code>static</code> elements are <strong>initialized only once</strong> and <strong>persist until the program terminates</strong>.</li>
<li><strong>Local</strong> variables/objects: It <strong>changes their lifetime</strong> but does not change their scope.</li>
<li><strong>Global</strong> variables/objects/function: It does not change their lifetime, but it <strong>changes their
   scope</strong> by limiting them to the file where they are defined or declared.</li>
<li><strong>Class members variables</strong>: It <strong>changes their scope and lifetime</strong>. <code>static</code> data members are
   initialized outside the class definition.</li>
<li><strong>Class member function</strong>: It does <strong>not allow them to access non-static members</strong>, except for
   <code>static</code> members.</li>
</ol>
<h4 id="usage_2">Usage</h4>
<h5 id="static-local-variables"><code>static</code> Local Variables</h5>
<h6 id="explanation_21">Explanation</h6>
<ol>
<li>A <code>static</code> local variable is <strong>a <code>static</code> variable</strong> declared within a function that <strong>maintains
   its state between function calls</strong>.</li>
<li>It has <strong>local scope</strong>, meaning it is <strong>only accessible within the function where it is
   declared</strong>.</li>
<li>The variable is <strong>automatically initialized to zero</strong> if <strong>not explicitly initialized</strong>.</li>
</ol>
<h6 id="syntax_18">Syntax</h6>
<pre><code class="language-CPP">RetType funcName() {
    // Initialized only once and retains value between calls.
    static Type count = val;
    ...;
};
</code></pre>
<h5 id="static-global-variables"><code>static</code> Global Variables</h5>
<h6 id="explanation_22">Explanation</h6>
<ol>
<li>A <code>static</code> global variable is declared outside of all functions and is <strong>only accessible within
   the file</strong> in which it is declared, <strong>preventing name conflicts in other files</strong>.</li>
<li>The variable is <strong>automatically initialized to zero</strong> if <strong>not explicitly initialized</strong>.</li>
</ol>
<h6 id="syntax_19">Syntax</h6>
<pre><code class="language-CPP">static Type var_name;
</code></pre>
<h5 id="static-member-variables"><code>static</code> Member Variables</h5>
<h6 id="explanation_23">Explanation</h6>
<ol>
<li><code>static</code> members of a class belong to the class itself rather than any object instance and <strong>can
   be accessed without an instance</strong>. <strong><code>static</code> members</strong> are <strong>shared among all instances of that
   class</strong>.</li>
<li>They are <strong>accessed using the class name</strong> instead of the object name.</li>
<li><code>static</code> keyword <strong>only changes their lifetime</strong>; it does <strong>not affect their visibility</strong>.</li>
<li><strong>Non-inline or non-constexpr</strong> <code>static</code> member variables should be <strong>defined or initialized
   outside the class</strong>.</li>
<li><strong><code>inline</code> or <code>constexpr</code></strong> <code>static</code> member variables can be <strong>defined or initialized inside or
   outside the class</strong>.</li>
<li>In fact, <code>static</code> members are <strong><code>static</code> variables defined within a namespace</strong>.</li>
</ol>
<h6 id="syntax_20">Syntax</h6>
<pre><code class="language-CPP">class ClassName {
   public:
      // Declaration of a static public class member.
      static Type1 _staticMember1;
      static Type2 _staticMember2;
      static inline Type3 _staticMember3;
      static constexpr Type4 _staticMember4;
      static inline Type5 _staticMember5 = val5;
      static constexpr Type6 _staticMember6 = val6;

   private:
      // Declaration of a static private class member.
      static Type7 _staticMember7;
      static Type8 _staticMember8;
      static inline Type9 _staticMember9;
      static constexpr Type10 _staticMember10;
      static inline Type11 _staticMember11 = val11;
      static constexpr Type12 _staticMember12 = val12;
};

// Providing definition and initialization for the static member.
Type1 ClassName::_staticMember1 = val1;
Type2 ClassName::_staticMember2 = val2;
Type3 ClassName::_staticMember3 = val3;
Type4 ClassName::_staticMember4 = val4;
Type7 ClassName::_staticMember7 = val7;
Type8 ClassName::_staticMember2 = val8;
Type9 ClassName::_staticMember9 = val9;
Type10 ClassName::_staticMember10 = val10;
</code></pre>
<h5 id="static-methods-static-member-functions"><code>static</code> Methods (<code>static</code> Member Functions)</h5>
<h6 id="explanation_24">Explanation</h6>
<ol>
<li>A <code>static</code> member function is <strong>a function</strong> defined within a class that can <strong>be called without
   creating an instance</strong> of the class.</li>
<li>It <strong>cannot access instance variables or instance methods</strong> directly, since it <strong>does not have a
   <code>this</code></strong> pointer.</li>
<li>This means it can <strong>only access <code>static</code> data members</strong> or other <strong><code>static</code> member functions</strong>
   within the class.</li>
<li>It can be <strong>called using the class name</strong>.</li>
</ol>
<h6 id="syntax_21">Syntax</h6>
<pre><code class="language-CPP">class ClassName {
   public:
      static RetType funcName( para_list ){
         // Function body.
      };
};

RetType var_name = ClassName::funcName( para_list );
</code></pre>
<pre><code class="language-CPP">class ClassName {
   public:
      static RetType funcName( para_list );
};

RetType var_name = ClassName::funcName( para_list ){
   // Function body.
};
</code></pre>
<h5 id="static-global-functions"><code>static</code> Global Functions</h5>
<h6 id="explanation_25">Explanation</h6>
<ol>
<li>A <code>static</code> global function is a function <strong>limited in visibility to the file</strong> where it is
   defined, which helps to <strong>avoid name conflicts across different files</strong>.</li>
</ol>
<h6 id="syntax_22">Syntax</h6>
<pre><code class="language-CPP">static RetType funcName() {
    // Function body.
};
</code></pre>
<h5 id="static-instances-of-classes"><code>static</code> Instances of Classes</h5>
<h6 id="explanation_26">Explanation</h6>
<ol>
<li>A <code>static</code> instance of a class refers to <strong>an object of the class</strong> that has <code>static</code> storage
   duration.</li>
<li>It <strong>persists</strong> for the <strong>entire duration</strong> of the program (until the program terminates).</li>
<li>It is <strong>initialized only once</strong>, <strong>the first time</strong> its definition or block <strong>is executed</strong>.</li>
<li>It can be scoped to a function, class, or namespace, depending on where it is declared.</li>
<li>In fact, it's <strong>a <code>static</code> variable</strong>, a <code>static</code> local variable or a <code>static</code> global variable.</li>
</ol>
<h6 id="syntax_23">Syntax</h6>
<pre><code class="language-CPP">static ClassName obj_ptr;
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
