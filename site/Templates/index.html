<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Templates - from_gcc_to_cpp</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">from_gcc_to_cpp</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../FromGccToCPP/" class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../Gcc/" class="nav-link">Gcc</a>
                            </li>
                            <li class="navitem">
                                <a href="../makeAndMakefiles/" class="nav-link">make and Makefiles</a>
                            </li>
                            <li class="navitem">
                                <a href="../Git/" class="nav-link">Git</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">CPP <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../CPPPerface/" class="dropdown-item">CPP Perface</a>
</li>
                                    
<li>
    <a href="../MemoryPartitions/" class="dropdown-item">Memory Partitions</a>
</li>
                                    
<li>
    <a href="../AutoAndDecltype/" class="dropdown-item">auto and decltype</a>
</li>
                                    
<li>
    <a href="../UsingTypedefNameSpaces/" class="dropdown-item">using, typedef and Namespaces</a>
</li>
                                    
<li>
    <a href="../ConstConstexprAndStatic/" class="dropdown-item">const, constexpr and static</a>
</li>
                                    
<li>
    <a href="../Volatile/" class="dropdown-item">volatile</a>
</li>
                                    
<li>
    <a href="../MacrosAndPragma/" class="dropdown-item">Macros and Related Keywords ( Including pragma</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Functions, Classes, Operators And Templates <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../Functions/" class="dropdown-item">Functions</a>
</li>
                                    
<li>
    <a href="../Classes/" class="dropdown-item">Classes</a>
</li>
                                    
<li>
    <a href="../HidingOverloadingOverridingAndOverwriting/" class="dropdown-item">Hiding, Overloading, Overriding, and Overwriting</a>
</li>
                                    
<li>
    <a href="../Structures/" class="dropdown-item">Structures</a>
</li>
                                    
<li>
    <a href="../Operators/" class="dropdown-item">Operators</a>
</li>
                                    
<li>
    <a href="../NewAndDelete/" class="dropdown-item">new and delete</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Templates</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Data Structures and Algorithms <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../IntroductionToTheCPPSTL/" class="dropdown-item">Introduction to C++ STL</a>
</li>
                                    
<li>
    <a href="../ConversionAndCasting/" class="dropdown-item">Conversion And Casting</a>
</li>
                                    
<li>
    <a href="../Bindings/" class="dropdown-item">Bindings</a>
</li>
                                    
<li>
    <a href="../StdBindAndStdFunction/" class="dropdown-item">std::bind and std::function</a>
</li>
                                    
<li>
    <a href="../Arrays/" class="dropdown-item">Arrays</a>
</li>
                                    
<li>
    <a href="../DynamicArraysOrStdVector/" class="dropdown-item">Dynamic Arrays (std::vector</a>
</li>
                                    
<li>
    <a href="../ListsAndForwardLists/" class="dropdown-item">Lists and Forward Lists</a>
</li>
                                    
<li>
    <a href="../SetsUnorderedSetsAndFlatSets/" class="dropdown-item">Sets Unordered Sets and Flat Sets</a>
</li>
                                    
<li>
    <a href="../MapsUnorderedMapsAndFlatMaps/" class="dropdown-item">Maps Unordered Maps and Flat Maps</a>
</li>
                                    
<li>
    <a href="../StacksAndQueues/" class="dropdown-item">Stacks and Queues</a>
</li>
                                    
<li>
    <a href="../Enums/" class="dropdown-item">enum</a>
</li>
                                    
<li>
    <a href="../UnionStdAnyStdVariantStdOptional/" class="dropdown-item">union, std:any std::variant and std::optional</a>
</li>
                                    
<li>
    <a href="../CharsAndStrings/" class="dropdown-item">Chars and Strings</a>
</li>
                                    
<li>
    <a href="../PairsAndTuples/" class="dropdown-item">Pairs and Tuples</a>
</li>
                                    
<li>
    <a href="../SmartPointers/" class="dropdown-item">Smart Pointers</a>
</li>
                                    
<li>
    <a href="../Algorithms/" class="dropdown-item">Algorithms</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Others <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../Timers/" class="dropdown-item">Timers</a>
</li>
                                    
<li>
    <a href="../Threads/" class="dropdown-item">Threads</a>
</li>
                                    
<li>
    <a href="../StaticAssert/" class="dropdown-item">static_assert</a>
</li>
                                    
<li>
    <a href="../Extern/" class="dropdown-item">Extern</a>
</li>
                                    
<li>
    <a href="../SomeCFunctionsAndOperators/" class="dropdown-item">Some C Functions and Operators</a>
</li>
                                    
<li>
    <a href="../SomeProgrammingTechniques/" class="dropdown-item">Some Programming Techniques</a>
</li>
                                    
<li>
    <a href="../Handles/" class="dropdown-item">Handles</a>
</li>
                                    
<li>
    <a href="../FileIOs/" class="dropdown-item">FileIOs</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../NewAndDelete/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../IntroductionToTheCPPSTL/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-light">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="2"><a href="#templates" class="nav-link">Templates</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#templates">Templates</a></li>
<li><a href="#explanation">Explanation</a></li>
<li><a href="#order-of-parameters-in-the-parameter-list">Order of Parameters in the Parameter List</a></li>
<li><a href="#limitations-of-template-default-types-and-values">Limitations of Template Default Types and Values</a></li>
<li><a href="#explicit-instantiation">Explicit Instantiation</a></li>
<li><a href="#implicit-instantiation-common-instantiation">Implicit Instantiation (<strong>Common Instantiation</strong>)</a></li>
<li><a href="#function-templates">Function Templates</a><ul>
<li><a href="#explanation-1">Explanation</a></li>
<li><a href="#syntax">Syntax</a></li>
</ul>
</li>
<li><a href="#class-templates-or-struct-templates">Class Templates or Struct Templates</a><ul>
<li><a href="#explanation-2">Explanation</a></li>
<li><a href="#syntax-1">Syntax</a></li>
</ul>
</li>
<li><a href="#template-specialization">Template Specialization</a><ul>
<li><a href="#explanation-3">Explanation</a></li>
<li><a href="#full-specialization">Full specialization</a></li>
<li><a href="#explanation-4">Explanation</a></li>
<li><a href="#syntax-2">Syntax</a></li>
<li><a href="#partial-specialization-partial-parameters">Partial Specialization (Partial Parameters)</a></li>
<li><a href="#explanation-5">Explanation</a></li>
<li><a href="#syntax-3">Syntax</a></li>
</ul>
</li>
<li><a href="#variadic-templates-template-packs">Variadic Templates (Template Packs)</a><ul>
<li><a href="#explanation-6">Explanation</a></li>
<li><a href="#common-syntax">Common Syntax</a></li>
<li><a href="#link">Link</a></li>
</ul>
</li>
<li><a href="#template-parameters-with-non-type-parameters">Template Parameters with Non-type Parameters</a><ul>
<li><a href="#explanation-7">Explanation</a></li>
<li><a href="#syntax-4">Syntax</a></li>
</ul>
</li>
<li><a href="#constraints-and-concepts">Constraints and Concepts</a><ul>
<li><a href="#explanation-8">Explanation</a></li>
<li><a href="#links">Links</a></li>
</ul>
</li>
<li><a href="#sfinae-substitution-failure-is-not-an-error">SFINAE (Substitution Failure Is Not An Error)</a><ul>
<li><a href="#explanation-9">Explanation</a></li>
<li><a href="#syntax-5">Syntax</a></li>
</ul>
</li>
<li><a href="#type-traits">Type Traits</a><ul>
<li><a href="#explanation-10">Explanation</a></li>
<li><a href="#syntax-6">Syntax</a></li>
</ul>
</li>
<li><a href="#template-aliases">Template Aliases</a></li>
<li><a href="#universial-references-forward-references">Universial References (Forward References)</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="templates">Templates</h2>
<h3 id="explanation">Explanation</h3>
<ol>
<li>Templates are C++ entities that use the <strong><code>template</code> keyword</strong> to define and use <strong>the <code>typename</code>
   or the <code>class</code> keyword</strong> to speficy a generic type .</li>
<li>Template parameters <strong>cannot be references or pointers</strong>.</li>
<li>Template parameters <strong>must be either types (e.g., <code>class T</code>, <code>typename T</code>) or values (e.g., <code>int N</code>)</strong>.</li>
<li>All <strong>type parameters</strong> can be bound to <strong>default types</strong>, and all <strong>non-type parameters</strong> can be
   bound to <strong>default values</strong>.</li>
<li>Templates empower developers to write <strong>generic and reusable code</strong>. By enabling functions and
   classes to <strong>operate on arbitrary data types</strong>, templates facilitate enhanced flexibility and
   <strong>type safety</strong> in programming.</li>
<li>They <strong>do not exist</strong>, and the compiler <strong>does not create them</strong>, and some compilers <strong>do not
   detect its syntax</strong> <strong>until they are called</strong>. At compile time, the compiler create and detect
   them.</li>
<li>Because templates <strong>exist and are compiled only for specific types when instantiated</strong>, they
   <strong>can</strong> be <strong>declared and defined in header files</strong>.</li>
</ol>
<h3 id="order-of-parameters-in-the-parameter-list">Order of Parameters in the Parameter List</h3>
<ol>
<li>For <strong>function templates</strong>, there is <strong>no specific order</strong> for parameters in the parameter list.
   Type or non-type parameters, whether they have default types or values, and parameter packs can
   be placed anywhere in the list.</li>
<li>However, <strong>for class templates</strong>, there is <strong>a specific order</strong>:</li>
<li>All parameters without default types or values must be placed at the beginning of the parameter
     list.</li>
<li>All parameters with default types or values must be specified at the end of the parameter list,
     but before any parameter packs.</li>
<li>All parameter packs must be placed at the end of the parameter list.</li>
<li><strong>Better orders</strong>:</li>
<li><strong>Type parameters without default types, non-type parameters without default values, type
     parameters with default types, non-type parameters with default values, and parameter packs</strong>.</li>
<li>Non-type parameters without default values, type parameters without default types, non-type
     parameters with default values, type parameters with default types, and parameter packs.</li>
</ol>
<h3 id="limitations-of-template-default-types-and-values">Limitations of Template Default Types and Values</h3>
<ol>
<li><strong>Order of parameters</strong>:</li>
<li><strong>It is not permissible to omit a parameter with a default value if one intends to provide
     values for later parameters</strong>.</li>
<li><strong>Dependent names</strong>:</li>
<li>Default template parameters <strong>cannot depend on other template parameters</strong>. A template
     parameter cannot be utilized to define the default value of another template parameter.</li>
<li><strong>Ambiguity in overloading</strong>:</li>
<li>The use of default template parameters in function overloading may lead to ambiguity.</li>
<li>If multiple templates can potentially match a call due to the presence of default arguments,
     the compiler may encounter difficulty in determining which template to invoke.</li>
<li><strong>Inheritance and template defaults</strong>:</li>
<li><strong>In derived template classes</strong>, <strong>the default arguments</strong> inherited from the base class
     <strong>cannot be modified</strong>.</li>
<li>It is necessary to explicitly specify the types in the derived class.</li>
<li><strong>Specialization limitations</strong>:</li>
<li>Template specializations are <strong>unable to alter default template parameters</strong>.</li>
<li>If a specialization employs a different type or value, it must explicitly define those
     parameters.</li>
</ol>
<h3 id="explicit-instantiation">Explicit Instantiation</h3>
<ol>
<li>The explicit instantiation refers to the deliberate and formal creation of a specific instance
    of a template with a particular type, as specified by the programmer.</li>
<li><strong>It works similarly to declaring a template with specific types and then using it</strong>.</li>
<li>This is done <strong>using the <code>template</code> keyword</strong> followed by the instantiation of the template with</li>
<li>the desired type.</li>
<li>This mechanism is primarily used to control when and where a template is instantiated,
    particularly in larger codebases where managing template definitions and instances can become
    complex.</li>
</ol>
<h3 id="implicit-instantiation-common-instantiation">Implicit Instantiation (<strong>Common Instantiation</strong>)</h3>
<ol>
<li>The implicit instantiation refers to the automatic creation of a template instance by the
    compiler when a template is used with a specific type, without requiring explicit instantiation
    by the programmer.</li>
<li><strong>It works similarly to using a template directly with specific types, without any prior
    declaration</strong>.</li>
</ol>
<h3 id="function-templates">Function Templates</h3>
<h4 id="explanation_1">Explanation</h4>
<ol>
<li>Function templates allow for the definition of <strong>functions</strong> that can <strong>operate with any data
   type</strong>.</li>
<li>This capability <strong>reduces code duplication</strong> and <strong>enhances type safety</strong>, as the compiler can
   automatically generate type-specific implementations based on the provided template parameters.</li>
</ol>
<h4 id="syntax">Syntax</h4>
<pre><code class="language-CPP">// Definition syntax.
template&lt; typename T1, typename T2, ... &gt; T1 funcName( T2 arg1, ... ) {
   // Function implementation.
};
</code></pre>
<pre><code class="language-CPP">// Usage syntax, explicit instantitaion syntax.
template Type funcName( ... );
</code></pre>
<pre><code class="language-CPP">// Usage syntax, explicit instantitaion syntax.
template Type funcName&lt;&gt;( ... );
</code></pre>
<pre><code class="language-CPP">// Usage syntax, explicit instantitaion syntax.
template Type funcName&lt; ... &gt;( ... );
</code></pre>
<pre><code class="language-CPP">// Usage syntax, implicit instantitaion syntax.
Type result = funcName( ... );
</code></pre>
<pre><code class="language-CPP">// Usage syntax, implicit instantitaion syntax.
Type result = funcName&lt;&gt;( ... );
</code></pre>
<pre><code class="language-CPP">// Usage syntax, implicit instantitaion syntax.
Type result = funcName&lt; ... &gt;( ... );
</code></pre>
<h3 id="class-templates-or-struct-templates">Class Templates or Struct Templates</h3>
<h4 id="explanation_2">Explanation</h4>
<ol>
<li>Class templates or struct templates enable the creation of <strong>classes or structs</strong> that can
   <strong>manage various data types</strong>.</li>
<li>This feature is particularly advantageous for <strong>implementing data structures</strong> such as <strong>lists,
   stacks, and queues</strong>, where <strong>the type of data may vary</strong>.</li>
</ol>
<h4 id="syntax_1">Syntax</h4>
<pre><code class="language-CPP">// With explicit instantiation.
namespace SpaceName {
   // Definition Syntax.
   template&lt; class T, ... &gt; class ClassName {
         RetType funcName( ... ) {
            // Do something.
         };
   };
};   // namespace SpaceName.

// Usage syntax, instantiation syntax.
// template class ClassName&lt;int&gt;; // error: class template ClassName not visible in the global namespace.
using SpaceName::ClassName;
// template class ClassName&lt;int&gt;; // error: explicit instantiation outside of the namespace of the template.
template class SpaceName::ClassName&lt; Type, ... &gt;;         // OK: explicit instantiation.
template RetType SpaceName::ClassName&lt; Type, ... &gt;::funcName( ... );   // OK: explicit instantiation.
</code></pre>
<pre><code class="language-CPP">// With implicit instantiation.
// Definition Syntax.
template&lt; class T, ... &gt; struct StructName
{
};
// Usage syntax, instantiation syntax.
template struct StructName&lt; Type, ... &gt;;   // Explicit instantiation of StructName&lt; Type &gt;.
StructName&lt; Type, ... &gt; obj;               // Implicit instantiation of StructName&lt; Type &gt;.
</code></pre>
<h3 id="template-specialization">Template Specialization</h3>
<h4 id="explanation_3">Explanation</h4>
<ol>
<li>Template specialization allows for the definition of <strong>a specific implementation of a template
   for a particular data type</strong> to <strong>meet specific conditions</strong>.</li>
<li>However, they do <strong>not allow more than one specialization for the same type parameters</strong>. The
   compiler will throw <strong>an error</strong> if multiple specializations that match the same signature are
   declared.</li>
<li>This feature is useful when <strong>the generic implementation requires adjustment for certain types to
   enhance functionality or performance</strong>.</li>
</ol>
<h4 id="full-specialization">Full specialization</h4>
<h5 id="explanation_4">Explanation</h5>
<ol>
<li>In <strong>full specialization</strong>, it is imperative to <strong>specify all template parameters explicitly</strong>.</li>
<li>For instance, if your template accepts two parameters, both must be explicitly defined in the
   specialization.</li>
</ol>
<h5 id="syntax_2">Syntax</h5>
<pre><code class="language-CPP">// Definition syntax.
template&lt; para_list &gt; class ClassName {
      // Implementation.
};

// Full specialization for `arg_list2`.
template&lt;&gt; class ClassName&lt; arg_list2 &gt; {
      // Another implementation.
};
</code></pre>
<pre><code class="language-CPP">// Usage syntax.
ClassName&lt; arg_list1 &gt; obj1;   // Utilizes the generic version.
ClassName&lt; arg_list2 &gt; obj2;   // Utilizes the specialized version.
</code></pre>
<h4 id="partial-specialization-partial-parameters">Partial Specialization (Partial Parameters)</h4>
<h5 id="explanation_5">Explanation</h5>
<ol>
<li>In <strong>partial specialization</strong>, it is permissible to <strong>leave some template parameters
   unspecified</strong>, allowing them to <strong>remain generic</strong>.</li>
<li><strong>The names</strong> of the unspecified template parameters <strong>do not need to remain the same as
   before</strong>, <strong>except for their remaining quantity</strong>.</li>
<li>This flexibility is advantageous for <strong>providing specialized behavior tailored to specific
   categories of types</strong>.</li>
</ol>
<h5 id="syntax_3">Syntax</h5>
<pre><code class="language-CPP">// Definition syntax.
template&lt; para_list1 &gt; class ClassName {
      // Implementation.
};

// Partial specialization for `arg_list3`.
template&lt; para_list2 &gt; class ClassName&lt; arg_list3 &gt; {
      // Another implementation.
};
</code></pre>
<pre><code class="language-CPP">// Usage syntax.
ClassName&lt; arg_list1 &gt; obj1;              // Utilizes the generic version.
ClassName&lt; arg_list2, arg_list3 &gt; obj2;   // Utilizes the specialized version.
</code></pre>
<pre><code class="language-CPP">// Definition syntax.
template&lt; typename T1, typename T2, ... &gt; class ClassName {
      // Implementation.
};

// Partial specialization for generic reference types.
template&lt; typename T1, typename T2, ... &gt; class ClassName&lt; T1&amp;, T2&amp;, ... &gt; {
      // Another implementation.
};
</code></pre>
<pre><code class="language-CPP">// Definition syntax.
template&lt; typename T1, typename T2, ... &gt; class ClassName {
      // Implementation.
};

// Partial specialization for generic pointer types.
template&lt; typename T1, typename T2, ... &gt; class ClassName&lt; T1*, T2*, ... &gt; {
      // Another implementation.
};
</code></pre>
<pre><code class="language-CPP">// Definition syntax.
template&lt; typename T, typename... Args &gt; class ClassName {
      // Implementation.
};

// Partial specialization for function types.
template&lt; typename T, typename... Args &gt; class ClassName&lt; T(... Args) &gt; {
      // Another implementation.
};
</code></pre>
<h3 id="variadic-templates-template-packs">Variadic Templates (Template Packs)</h3>
<h4 id="explanation_6">Explanation</h4>
<ol>
<li>Variadic templates are <strong>templates</strong> that <strong>contain at least one parameter pack</strong>.</li>
<li><strong>A template parameter pack</strong> is <strong>a template parameter</strong> that <strong>accepts zero or more template
   arguments</strong> (non-types, types, or templates).</li>
<li>The <strong>common way</strong> to <strong>store the arguments of a template parameter pack</strong> and <strong>access them</strong> is
   by using <strong><code>std::tuple</code></strong> and <strong><code>std::get</code></strong>.</li>
<li>This feature is beneficial for functions that need to <strong>handle a flexible number of arguments</strong>,
   thereby enhancing versatility.</li>
<li>For <strong>a function template</strong>, <strong>multiple parameter packs</strong> can be defined, while <strong>a class
   template</strong> can <strong>only have one</strong>.</li>
<li>For <strong>a function template</strong>, a template parameter pack can <strong>automatically deduce types</strong> and the
   types are not explicitly specified when the function is called.</li>
<li>However, <strong>for a class template</strong> (such as <code>std::tuple</code> or <code>std::vector</code>), <strong>the types must be
   explicitly specified</strong> because template parameter packs are typically not deduced in class
   templates.</li>
</ol>
<h4 id="common-syntax">Common Syntax</h4>
<pre><code class="language-CPP">#include &lt;iostream&gt;
#include &lt;tuple&gt;

// Be mindful of the Ellipsis.
template&lt; typename... Args &gt; class ClassName {
   public:
      // explicit ClassName( Args&amp;... args ):
      // explicit ClassName( Args&amp;&amp;... args ):
      explicit ClassName( Args... args ):
         _mem( args... ), _mem_ptr( &amp;args... ) {
         // Method to print all arguments in order without adding any extra characters.
         ( std::cout &lt;&lt; ... &lt;&lt; args ) &lt;&lt; std::endl;
         // Method to print all arguments'addresses in order without adding any extra characters.
         ( std::cout &lt;&lt; ... &lt;&lt; &amp;args ) &lt;&lt; std::endl;
         // Method to print all ++arguments in order without adding any extra characters.
         ( std::cout &lt;&lt; ... &lt;&lt; ++args ) &lt;&lt; std::endl;
         // Method to add all arguments in order and print the result.
         std::cout &lt;&lt; ( ... + args ) &lt;&lt; std::endl;
         // Method to multiple all arguments in order and print the result.
         std::cout &lt;&lt; ( ... * args ) &lt;&lt; std::endl;
         // Method to &amp;&amp; all arguments in order and print the result.
         std::cout &lt;&lt; ( ... &amp;&amp; args ) &lt;&lt; std::endl;
         // Method to || all arguments in order and print the result.
         std::cout &lt;&lt; ( ... || args ) &lt;&lt; std::endl;
      };

      // Method to get an element by index.
      template&lt; std::size_t Index &gt; decltype( auto ) get() {
         return std::get&lt; Index &gt;( _mem );
      };

      // Others.

   private:
      std::tuple&lt; Args... &gt; _mem;        // Store arguments in a tuple.
      std::tuple&lt; Args*... &gt; _mem_ptr;   // Store arguments's addresses in a tuple.
      // Others
};

int main() {
   ClassName&lt; ArgType1, ArgType2, ArgType3, /* and so on */ &gt; obj(
      arg1, arg2, arg3, /* and so on */ );

   // Access specific elements by index.
   std::cout &lt;&lt; &quot;First element: &quot; &lt;&lt; obj.get&lt; 0 &gt;() &lt;&lt; std::endl;    // arg1.
   std::cout &lt;&lt; &quot;Second element: &quot; &lt;&lt; obj.get&lt; 1 &gt;() &lt;&lt; std::endl;   // arg2.
   std::cout &lt;&lt; &quot;Third element: &quot; &lt;&lt; obj.get&lt; 2 &gt;() &lt;&lt; std::endl;    // arg3.
   // Others.

   return 0;
};
</code></pre>
<h4 id="link">Link</h4>
<ol>
<li><a href=""><code>parameter packs</code> in cplusplus</a>.</li>
<li><a href="https://en.cppreference.com/w/cpp/language/parameter_pack"><code>parameter packs</code> in cppreference</a>.</li>
</ol>
<h3 id="template-parameters-with-non-type-parameters">Template Parameters with Non-type Parameters</h3>
<h4 id="explanation_7">Explanation</h4>
<ol>
<li>Template parameters can include <strong>non-type parameters</strong>, which are constants of integral or
   enumeration types, pointers, references, or even certain types of non-type template parameters.</li>
<li>This feature allows you to create templates that are more flexible and capable of <strong>handling
   specific values alongside types</strong>, enabling <strong>additional control over template behavior and
   structure</strong>.</li>
</ol>
<h4 id="syntax_4">Syntax</h4>
<pre><code class="language-CPP">// Definition syntax.
template&lt; typename T, ..., Type N, ... &gt; class ClassName {
   ...;
};
</code></pre>
<pre><code class="language-CPP">// Usage syntax.
ClassName&lt; TType, ..., val, ... &gt; var_name;
</code></pre>
<h3 id="constraints-and-concepts">Constraints and Concepts</h3>
<h4 id="explanation_8">Explanation</h4>
<ol>
<li>Class templates, function templates, and non-template functions (typically members of class
   templates) might be associated with <strong>a constraint</strong>, which <strong>specifies the requirements on
   template arguments</strong>, which can be <strong>used to select the most appropriate function overloads and
   template specializations</strong>.</li>
<li><strong>Named sets of such requirements</strong> are called <strong>concepts</strong>. Each concept is a predicate,
   evaluated at compile time, and becomes a part of the interface of a template where it is used as
   a constraint:</li>
</ol>
<h4 id="links">Links</h4>
<ol>
<li><a href=""><code>constraints and concepts</code> in cplusplus</a>.</li>
<li><a href="https://en.cppreference.com/w/cpp/language/constraints"><code>constraints and concepts</code> in cppreference</a>.</li>
</ol>
<h3 id="sfinae-substitution-failure-is-not-an-error">SFINAE (Substitution Failure Is Not An Error)</h3>
<h4 id="explanation_9">Explanation</h4>
<ol>
<li>It is <strong>a principle</strong> that <strong>allows template substitutions to fail</strong> and <strong>may</strong> still <strong>result
   in a compilation error</strong> â€” <strong>but</strong> it is <strong>not treated as an error</strong> in the context of template
   instantiation.</li>
<li>This is useful for <strong>enabling or disabling templates based on certain conditions</strong>.</li>
<li><strong><code>std::enable_if</code></strong> is a common tool for implementing SFINAE, there are other techniques and
   constructs that can also be used, such as function overloading, template specialization, type
   traits, constraints and concepts in templates, and more.</li>
<li>If a function template cannot be instantiated due to type mismatches, the compiler simply
     ignores that overload instead of producing an error.</li>
<li>If a template specialization cannot be matched, it will not result in an error but rather allow
     the compiler to try other template.</li>
<li>Its declaration syntax:
     <code>CPP
     template&lt; bool B, class T = void &gt; struct enable_if; // It has a public member typedef `type`, equal to `T`.</code></li>
<li>Its implementation syntax:
     <code>CPP
     template&lt; bool B, class T = void &gt; struct enable_if {};   // Primary template.
     // Partial specialization for the case when B is true.
     template&lt; class T &gt; struct enable_if&lt; true, T &gt; {
           using type = T;
     };</code></li>
<li>Its helper types:
     <code>CPP
     template&lt; bool B, class T = void &gt;
     using enable_if_t = typename enable_if&lt; B, T &gt;::type;</code></li>
</ol>
<h4 id="syntax_5">Syntax</h4>
<pre><code class="language-CPP">// With `std::enable_if`.
#include &lt;type_traits&gt;

// In this, `TypeTrait` is a template function (or class or structure,
// even with the `constexpr` keyword) in the header `&lt;type_traits&gt;`,
// for example, `std::is_integral`.
template&lt; typename T, ... &gt;
typename std::enable_if&lt; TypeTrait&lt; T, ... &gt;::value &gt;::type funcName( T para, ... ) {
   // If T, ... meet specific conditions.
   // Do something.
};

template&lt; typename T, ... &gt;
typename std::enable_if&lt; !TypeTrait&lt; T &gt;::value &gt;::type funcName( T para, ... ) {
   // If T is not a specific type.
   // Do something.
};
</code></pre>
<pre><code class="language-CPP">// With `std::enable_if`.
#include &lt;type_traits&gt;

// In this, `TypeTrait` is a template function (or class or structure,
// even with the `constexpr` keyword) in the header `&lt;type_traits&gt;`,
// for example, `std::is_integral`.
template&lt; typename T,
          typename std::enable_if&lt; TypeTrait&lt; T, ... &gt;::value &gt;::type,
          ... &gt;
RetType funcName( T para, ... ) {
   // If T, ... meet specific conditions.
   // Do something.
};

template&lt; typename T,
          typename std::enable_if&lt; !TypeTrait&lt; T &gt;::value &gt;::type,
          ... &gt;
RetType funcName( T para, ... ) {
   // If T is not a specific type.
   // Do something.
};
</code></pre>
<pre><code class="language-CPP">// With constraints and concepts.
#include &lt;type_traits&gt;

// In this, `TypeTrait` is a template function (or class or structure,
// even with the `constexpr` keyword) in the header &lt;type_traits&gt;,
// for example, std::is_integral
template&lt; typename T, ... &gt; concept TempName = TypeTrait&lt; T, ... &gt;;
template&lt; TempName T, ... &gt; RetType funcName( T para, ... ) {
   // This function is only enabled for specific conditions
};
</code></pre>
<h3 id="type-traits">Type Traits</h3>
<h4 id="explanation_10">Explanation</h4>
<ol>
<li>Type traits are <strong>a set of template classes (or structures or functions</strong> even with the
   <code>constexpr</code> keyword) provided by the C++ Standard Library that allow you to <strong>query and
   manipulate type information at compile time</strong>.</li>
<li>They can be <strong>combined</strong> with various techniques used to <strong>complete evaluations at compile
   time</strong>, such as <code>static const</code>, <code>constexpr</code>, <code>templates</code>, <code>std::enable_if</code>, <code>static_assert</code>, and
   more.</li>
<li>All type traits are in the header <strong><code>&lt;type_traits&gt;</code></strong>.</li>
</ol>
<h4 id="syntax_6">Syntax</h4>
<pre><code class="language-CPP">// Using templates and `static_assert` to implement a type trait.
template&lt; typename T &gt; struct IsPointer {
      static const bool val = false;   // Default case.
};

template&lt; typename T &gt; struct IsPointer&lt; T* &gt; {
      static const bool val = true;   // Specialization for pointers.
};

// Usage.
static_assert( IsPointer&lt; int* &gt;::val, &quot;Should be a pointer type&quot; );
static_assert( !IsPointer&lt; int &gt;::val, &quot;Should not be a pointer type&quot; );
</code></pre>
<pre><code class="language-CPP">// Using a type trait with `static_assert`.
#include &lt;type_traits&gt;

// In this, `TypeTrait` is a template function (or class or structure,
// even with the `constexpr` keyword) in the header &lt;type_traits&gt;,
// for example, `std::is_integral`.
template&lt; typename T, ... &gt; RetType funcName( T t, ... ) {
   static_assert( TypeTrait&lt; T &gt;::value, &quot;T must be a specific type&quot; );
   // Do something.
};
</code></pre>
<h3 id="template-aliases">Template Aliases</h3>
<ol>
<li><a href="../UsingTypedefNameSpaces/#using"><code>using</code></a></li>
</ol>
<h3 id="universial-references-forward-references">Universial References (Forward References)</h3>
<ol>
<li>A universal reference is <strong>a type of reference</strong> in C++ that <strong>can bind to both lvalues and
   rvalues</strong>.</li>
<li>It is also called <strong>a forwarding reference</strong> in modern C++ terminology.</li>
<li>The term "universal reference" is <strong>particularly used in the context of template functions</strong>.</li>
<li>A universal reference typically appears in a template function parameter when the type is
   declared as <code>T&amp;&amp;</code> but is not a reference type (such as in <code>T&amp;&amp;</code> where <code>T</code> is a template
   parameter). This is a special case of rvalue reference, which can either bind to:</li>
<li>An rvalue (temporary object).</li>
<li>An lvalue (persistent object) if it's used in the context of a template.</li>
<li>Lvalue reference (<code>T&amp;</code>) and rvalue reference (<code>T&amp;&amp;</code>) are distinct in C++. But when template type
   deduction is used, the compiler deduces the right reference type depending on the value category
   of the argument passed.</li>
<li>When an lvalue is passed, <code>T</code> is deduced as <code>Type&amp;</code>, so the universal reference becomes
     <code>Type&amp; &amp;</code>, which is collapsed to <code>Type&amp;</code>.</li>
<li>When an rvalue is passed, <code>T</code> is deduced as <code>Type&amp;</code>, and the universal reference becomes
     <code>Type&amp; &amp;</code>.</li>
<li>Universal references are often used in <strong>perfect forwarding</strong>, where you want to forward the
   arguments exactly as received, keeping their value category intact.</li>
</ol></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
