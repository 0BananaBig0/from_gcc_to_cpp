{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Algorithms/","text":"Algorithms Links Non-modifying Sequence Operations Batch Operations Search Operations Fold Operations Modifying Sequence Operations Copy Operations Swap Operations Transformation Operations Generation Operations Removing Operations Order-changing Operations Sampling Operations Sorting and Related Operations Requirements Participationing Operations Sorting Operations Binary Search Operations (on Partitioned Ranges) Set Operations (on Sorted Ranges) Merge Operations (on Sorted Ranges) Heap Operations Minimum or Maximum Operations Lexicographical Comparison Operations Permutation Operations Numeric Operations Operations on Uninitialized Memory Random Number Generation C Library Algorithms Links algorithms in cplusplus . algorithms in cppreference . Non-modifying Sequence Operations Batch Operations Search Operations Fold Operations Modifying Sequence Operations Copy Operations Swap Operations Transformation Operations Generation Operations Removing Operations Order-changing Operations Sampling Operations Sorting and Related Operations Requirements Participationing Operations Sorting Operations Binary Search Operations (on Partitioned Ranges) Set Operations (on Sorted Ranges) Merge Operations (on Sorted Ranges) Heap Operations Minimum or Maximum Operations Lexicographical Comparison Operations Permutation Operations Numeric Operations Operations on Uninitialized Memory Random Number Generation C Library","title":"Algorithms"},{"location":"Algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"Algorithms/#links","text":"algorithms in cplusplus . algorithms in cppreference .","title":"Links"},{"location":"Algorithms/#non-modifying-sequence-operations","text":"","title":"Non-modifying Sequence Operations"},{"location":"Algorithms/#batch-operations","text":"","title":"Batch Operations"},{"location":"Algorithms/#search-operations","text":"","title":"Search Operations"},{"location":"Algorithms/#fold-operations","text":"","title":"Fold Operations"},{"location":"Algorithms/#modifying-sequence-operations","text":"","title":"Modifying Sequence Operations"},{"location":"Algorithms/#copy-operations","text":"","title":"Copy Operations"},{"location":"Algorithms/#swap-operations","text":"","title":"Swap Operations"},{"location":"Algorithms/#transformation-operations","text":"","title":"Transformation Operations"},{"location":"Algorithms/#generation-operations","text":"","title":"Generation Operations"},{"location":"Algorithms/#removing-operations","text":"","title":"Removing Operations"},{"location":"Algorithms/#order-changing-operations","text":"","title":"Order-changing Operations"},{"location":"Algorithms/#sampling-operations","text":"","title":"Sampling Operations"},{"location":"Algorithms/#sorting-and-related-operations","text":"","title":"Sorting and Related Operations"},{"location":"Algorithms/#requirements","text":"","title":"Requirements"},{"location":"Algorithms/#participationing-operations","text":"","title":"Participationing Operations"},{"location":"Algorithms/#sorting-operations","text":"","title":"Sorting Operations"},{"location":"Algorithms/#binary-search-operations-on-partitioned-ranges","text":"","title":"Binary Search Operations (on Partitioned Ranges)"},{"location":"Algorithms/#set-operations-on-sorted-ranges","text":"","title":"Set Operations (on Sorted Ranges)"},{"location":"Algorithms/#merge-operations-on-sorted-ranges","text":"","title":"Merge Operations (on Sorted Ranges)"},{"location":"Algorithms/#heap-operations","text":"","title":"Heap Operations"},{"location":"Algorithms/#minimum-or-maximum-operations","text":"","title":"Minimum or Maximum Operations"},{"location":"Algorithms/#lexicographical-comparison-operations","text":"","title":"Lexicographical Comparison Operations"},{"location":"Algorithms/#permutation-operations","text":"","title":"Permutation Operations"},{"location":"Algorithms/#numeric-operations","text":"","title":"Numeric Operations"},{"location":"Algorithms/#operations-on-uninitialized-memory","text":"","title":"Operations on Uninitialized Memory"},{"location":"Algorithms/#random-number-generation","text":"","title":"Random Number Generation"},{"location":"Algorithms/#c-library","text":"","title":"C Library"},{"location":"Arrays/","text":"Arrays Explanation Static Arrays (Raw Arrays) Explanation One-dimensional Raw Arrays Declaration Syntax Initialization Syntax Syntax for Deleting One-dimensional Raw Array Pointers Three Kinds of Pointers Related to Array Multidimensional Raw Arrays ( Not Recommend ) Declaration Syntax Initialization Syntax Syntax for Deleting Multidimensional Raw Array Pointers Static Arrays ( std::array ) Explanation One-dimensional std::array Declaration Syntax Initialization Syntax Syntax for Deleting One-dimensional std::array Pointers Multidimensional std::array ( Not Recommend ) Declaration Syntax Initialization Syntax Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Helper Classes Lexicographical Comparison or Lexicographical Order Notes Dynamic Arrays ( std::vector ) Arrays Explanation Arrays are a collection of elements , all of the same type , that are stored in contiguous memory locations. The Contiguous memory improves cache performance . They are used to store multiple values in a single variable , making it easier to manage and manipulate data efficiently . Static Arrays (Raw Arrays) Explanation Raw arrays refer to traditional C-style arrays that are built into the language. They are a fixed-size sequence of elements of the same type and provides very minimal functionality compared to containers like std::array or std::vector . They are the fastest structure but are not safe enough.. The size of a raw array is defined at compile time and cannot be changed during runtime . This means that once an array is declared, its size is fixed. Array pointer (pointer to an array) : A pointer that points to an entire array ( rather than individual elements). Pointer array (array of pointers) : An array where each element is a pointer. Element pointer (pointer to an element, pointer to an specific index, array element pointer) : A pointer that points to an element in an array. One-dimensional Raw Arrays Declaration Syntax // No initialization, contain garbage values and behave unpredictably. Type arr_name[size]; Type* arr_ptr = new Type[size]; Type arr_name[size]; Type* arr_ptr = arr_name; Initialization Syntax // Aggregate Initialization. Type arr_name[size] = { ... }; // Default Initialization. Type arr_name[size] = {}; Type arr_name1 = { ... }; // Copy Initialization. Type arr_name2 = arr_name1; // Implicit size: If the size isn't specified, it is inferred from the initializer list. Type arr_name[] = { ... }; Type* arr_ptr = new Type[size]{ ... }; Type* arr_ptr = new Type[]{ ... }; Syntax for Deleting One-dimensional Raw Array Pointers delete[] arr_ptr; Three Kinds of Pointers Related to Array Type arr_name[size] = { ... }; Type (*arr_ptr)[size] = &arr_name; // Array pointer. // array pointer + 1 = element pointer + size; Type arr_name[size] = { ... }; Type* arr_ptr[szie] = { ... }; // Pointer array. Type arr_name[size] = { ... }; Type* arr_ptr = arr_name; // Element pointer points to the first element of arr_name. Type arr_name[size] = { ... }; Type* arr_ptr = &arr_name[index]; // Element pointer points to the `index` element of arr_name. // array pointer + 1 = element pointer + size; Multidimensional Raw Arrays ( Not Recommend ) Declaration Syntax // No initialization, contain garbage values and behave unpredictably. Type arr_name[size_x][size_y]; // No initialization, contain garbage values and behave unpredictably. Type arr_name[size_x][size_y][size_z]; // `a2d` is an array that stores size_x pointers, each of which points to an array that stores size_y values. Type** a2d = new Type*[size_x]; for( size_t i = 0; i < size_x; i++ ) { a2d[i] = new Type[size_y]; }; Type*** a3d = new Type**[size_x]; for( size_t i = 0; i < size_x; i++ ) { a3d[i] = new Type*[size_y]; for( size_t j = 0; j < size_y; j++ ) a3d[i][j] = new Type[size_z]; }; Initialization Syntax // Aggregate initialization. Type arr_name[size_x][size_y] = { { ... /* size_y */ }, { ... }, ... /* size_x */ }; // Default initialization. Type arr_name[size_x][size_y] = {}; Type arr_name1[size_x][size_y] = { { ... /* size_y */ }, { ... }, ... /* size_x */ }; // Copy Initialization. Type arr_name2[size_x][size_y] = arr_name1; // Aggregate initialization. Type arr_name[size_x][size_y][size_z] = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ }; // Default initialization. Type arr_name[size_x][size_y][size_z] = {}; Type arr_name1[size_x][size_y][size_z] = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ }; // Copy initialization. Type arr_name2[size_x][size_y][size_z] = arr_name1; Syntax for Deleting Multidimensional Raw Array Pointers for( size_t i = 0; i < size_x; i++ ) { delete[] a2d[i]; }; delete[] a2d; for( size_t i = 0; i < size_x; i++ ) { for( size_t j = 0; j < size_y; j++ ) delete[] a3d[i][j]; delete[] a3d[i]; }; delete[] a3d; Static Arrays ( std::array ) Explanation std::array is a container from the C++ STL that provides a fixed-size array . It is a template class , and all syntax applicable to template classes applies to it. Its simple implementation: CPP template< typename T, size_t size > class Array { T _array[size] }; std::array is slower than the raw array, but std::array is safer than a raw array. std::array is used like a raw array but provides member functions and allows us to use many standard C++ functions to manage it. In debug mode, std::array can help us debug like bounds checking, thanks to its debug macros and code. std::array is a template . Its size can be gotten by its functions, but it doesn't store the size as a value . The size of a std::array is defined at compile time and cannot be changed during runtime . This means that once an array is declared, its size is fixed. Their header file is <array> . One-dimensional std::array Declaration Syntax // No initialization, contain garbage values and behave unpredictably. std::array< Type, size > arr_name; std::array< Type, size >* arr_ptr = new std::array< Type, size >; std::array< Type, size > arr_name; std::array< Type, size >* arr_ptr = &arr_name; Initialization Syntax // Aggregate initialization or uniform initialization (C++11 and later). std::array< Type, size > arr_name = { val1, val2, val3, ... }; // Default initialization. std::array< Type, size > arr_name = {}; // Aggregate initialization or uniform initialization (C++11 and later). std::array< Type, size > arr_name{ val1, val2, val3, ... }; // Aggregate initialization or uniform initialization (C++11 and later). std::array< Type, size > arr_name1( { ... } ); // Move constructor. std::array< Type, size > arr_name2( std::move( arr_name1 ) ); // Aggregate initialization. std::array< Type, size > arr_name1 = { ... }; // Copy constructor. std::array< Type, size > arr_name2(arr_name1); // Aggregate initialization. std::array< Type, size > arr_name1 = { ... }; // Copy constructor. std::array< Type, size > arr_name2 = arr_name1; std::array< Type, size > arr_name1 = { val1, val2, val3, ... }; // Copy initialization. std::array< Type, size > arr_name2 = arr_name1; std::array< Type, size >* arr_ptr = new std::array< Type, size >{ ... }; Syntax for Deleting One-dimensional std::array Pointers delete arr_ptr; Multidimensional std::array ( Not Recommend ) Declaration Syntax // No initialization, contain garbage values and behave unpredictably. std::array< std::array< Type, size_y >, size_x > arr_name; // No initialization, contain garbage values and behave unpredictably. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name; Initialization Syntax // Aggregate Initialization. std::array< std::array< Type, size_y >, size_x > arr_name = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; // Default initialization. std::array< std::array< Type, size_y >, size_x > arr_name = {}; // Uniform initialization (C++11 and later). std::array< std::array< Type, size_y >, size_x > arr_name{ { { ... /* size_y */}, { ... }, ... /* size_x */ } }; std::array< std::array< Type, size_y >, size_x > arr_name1 = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; // Copy initialization. std::array< std::array< Type, size_y >, size_x > arr_name2 = arr_name1; // Aggregate initialization. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name = { { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ } }; // Default initialization. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name = {}; // Uniform initialization (C++11 and later). std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name{ { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ } }; std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name1 = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ }; // Copy initialization. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name2 = arr_name1; Members and Related Stuffs Links std::array in cplusplus . std::array in cppreference . Template Parameters T : Element type. N : The number of elements in the array or 0. Member Types alue_type : T . ize_typ : std::size_t . ifference_type : std::ptrdiff_t . eference : value_type& . onst_reference : const value_type& . ointer : value_type . onst_pointer : const value_type . terator : LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++17), LegacyRandomAccessIterator and LegacyContiguousIterator that is a LiteralType (since C++17) to value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20). const_iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++17), LegacyRandomAccessIterator and LegacyContiguousIterator that is a LiteralType (since C++17) to const value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20). reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Functions (constructor) (implicitly declared): Initializes the array following the rules of aggregate initialization (note that default initialization may result in indeterminate values for non-class T) (public member function). (destructor) (implicitly declared): Destroys every element of the array (public member function) operator= (implicitly declared): overwrites every element of the array with the corresponding element of another array (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access specified element (public member function). front : Access the first element (public member function). back : Access the last element (public member function). data : Direct access to the underlying contiguous storage (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). fill : Fill the container with specified value (public member function).. swap : Swaps the contents (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two arrays (function template). get( std::array ) : Accesses an element of an array (function template). std::swap( std::array ) : Specializes the std::swap algorithm (function template). to_array (C++20): Creates a std::array object from a built-in array (function template). Helper Classes std::tuple_size< std::array > : Obtains the size of an array (class template specialization). std::tuple_element< std::array > : Obtains the type of the elements of array (class template specialization). Lexicographical Comparison or Lexicographical Order Lexicographical comparison means that the elements of the arrays are compared in sequence , similar to how words are compared in a dictionary. The comparison starts from the first element and proceeds until a difference is found or one of the arrays is exhausted . Notes Do not use an actual multidimensional array . If you need a multidimensional array, flatten it and use a one-dimensional array instead. For example, Type a2d[size_x * size_y]; and Type* a2d = new Type[size_x * size_y]; Both examples create a two-dimensional array using a one-dimensional array.. When working with actual multidimensional arrays, performance and memory issues with pointers can arise depending on how the array is allocated and accessed, as not all elements may be contiguous in memory . This can lead to problems such as memory fragmentation and cache misses . size_t is an unsigned integer type specifically designed to represent the size of objects or array indices. It is widely used to ensure portability across platforms and avoid overflow issues when working with memory sizes, since it matches the size of the addressable memory range on the system. Dynamic Arrays ( std::vector ) Dynamic Arrays ( std::vector )","title":"Arrays"},{"location":"Arrays/#arrays","text":"","title":"Arrays"},{"location":"Arrays/#explanation","text":"Arrays are a collection of elements , all of the same type , that are stored in contiguous memory locations. The Contiguous memory improves cache performance . They are used to store multiple values in a single variable , making it easier to manage and manipulate data efficiently .","title":"Explanation"},{"location":"Arrays/#static-arrays-raw-arrays","text":"","title":"Static Arrays (Raw Arrays)"},{"location":"Arrays/#explanation_1","text":"Raw arrays refer to traditional C-style arrays that are built into the language. They are a fixed-size sequence of elements of the same type and provides very minimal functionality compared to containers like std::array or std::vector . They are the fastest structure but are not safe enough.. The size of a raw array is defined at compile time and cannot be changed during runtime . This means that once an array is declared, its size is fixed. Array pointer (pointer to an array) : A pointer that points to an entire array ( rather than individual elements). Pointer array (array of pointers) : An array where each element is a pointer. Element pointer (pointer to an element, pointer to an specific index, array element pointer) : A pointer that points to an element in an array.","title":"Explanation"},{"location":"Arrays/#one-dimensional-raw-arrays","text":"","title":"One-dimensional Raw Arrays"},{"location":"Arrays/#declaration-syntax","text":"// No initialization, contain garbage values and behave unpredictably. Type arr_name[size]; Type* arr_ptr = new Type[size]; Type arr_name[size]; Type* arr_ptr = arr_name;","title":"Declaration Syntax"},{"location":"Arrays/#initialization-syntax","text":"// Aggregate Initialization. Type arr_name[size] = { ... }; // Default Initialization. Type arr_name[size] = {}; Type arr_name1 = { ... }; // Copy Initialization. Type arr_name2 = arr_name1; // Implicit size: If the size isn't specified, it is inferred from the initializer list. Type arr_name[] = { ... }; Type* arr_ptr = new Type[size]{ ... }; Type* arr_ptr = new Type[]{ ... };","title":"Initialization Syntax"},{"location":"Arrays/#syntax-for-deleting-one-dimensional-raw-array-pointers","text":"delete[] arr_ptr;","title":"Syntax for Deleting One-dimensional Raw Array Pointers"},{"location":"Arrays/#three-kinds-of-pointers-related-to-array","text":"Type arr_name[size] = { ... }; Type (*arr_ptr)[size] = &arr_name; // Array pointer. // array pointer + 1 = element pointer + size; Type arr_name[size] = { ... }; Type* arr_ptr[szie] = { ... }; // Pointer array. Type arr_name[size] = { ... }; Type* arr_ptr = arr_name; // Element pointer points to the first element of arr_name. Type arr_name[size] = { ... }; Type* arr_ptr = &arr_name[index]; // Element pointer points to the `index` element of arr_name. // array pointer + 1 = element pointer + size;","title":"Three Kinds of Pointers Related to Array"},{"location":"Arrays/#multidimensional-raw-arrays-not-recommend","text":"","title":"Multidimensional Raw Arrays (Not Recommend)"},{"location":"Arrays/#declaration-syntax_1","text":"// No initialization, contain garbage values and behave unpredictably. Type arr_name[size_x][size_y]; // No initialization, contain garbage values and behave unpredictably. Type arr_name[size_x][size_y][size_z]; // `a2d` is an array that stores size_x pointers, each of which points to an array that stores size_y values. Type** a2d = new Type*[size_x]; for( size_t i = 0; i < size_x; i++ ) { a2d[i] = new Type[size_y]; }; Type*** a3d = new Type**[size_x]; for( size_t i = 0; i < size_x; i++ ) { a3d[i] = new Type*[size_y]; for( size_t j = 0; j < size_y; j++ ) a3d[i][j] = new Type[size_z]; };","title":"Declaration Syntax"},{"location":"Arrays/#initialization-syntax_1","text":"// Aggregate initialization. Type arr_name[size_x][size_y] = { { ... /* size_y */ }, { ... }, ... /* size_x */ }; // Default initialization. Type arr_name[size_x][size_y] = {}; Type arr_name1[size_x][size_y] = { { ... /* size_y */ }, { ... }, ... /* size_x */ }; // Copy Initialization. Type arr_name2[size_x][size_y] = arr_name1; // Aggregate initialization. Type arr_name[size_x][size_y][size_z] = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ }; // Default initialization. Type arr_name[size_x][size_y][size_z] = {}; Type arr_name1[size_x][size_y][size_z] = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ }; // Copy initialization. Type arr_name2[size_x][size_y][size_z] = arr_name1;","title":"Initialization Syntax"},{"location":"Arrays/#syntax-for-deleting-multidimensional-raw-array-pointers","text":"for( size_t i = 0; i < size_x; i++ ) { delete[] a2d[i]; }; delete[] a2d; for( size_t i = 0; i < size_x; i++ ) { for( size_t j = 0; j < size_y; j++ ) delete[] a3d[i][j]; delete[] a3d[i]; }; delete[] a3d;","title":"Syntax for Deleting Multidimensional Raw Array Pointers"},{"location":"Arrays/#static-arrays-stdarray","text":"","title":"Static Arrays (std::array)"},{"location":"Arrays/#explanation_2","text":"std::array is a container from the C++ STL that provides a fixed-size array . It is a template class , and all syntax applicable to template classes applies to it. Its simple implementation: CPP template< typename T, size_t size > class Array { T _array[size] }; std::array is slower than the raw array, but std::array is safer than a raw array. std::array is used like a raw array but provides member functions and allows us to use many standard C++ functions to manage it. In debug mode, std::array can help us debug like bounds checking, thanks to its debug macros and code. std::array is a template . Its size can be gotten by its functions, but it doesn't store the size as a value . The size of a std::array is defined at compile time and cannot be changed during runtime . This means that once an array is declared, its size is fixed. Their header file is <array> .","title":"Explanation"},{"location":"Arrays/#one-dimensional-stdarray","text":"","title":"One-dimensional std::array"},{"location":"Arrays/#declaration-syntax_2","text":"// No initialization, contain garbage values and behave unpredictably. std::array< Type, size > arr_name; std::array< Type, size >* arr_ptr = new std::array< Type, size >; std::array< Type, size > arr_name; std::array< Type, size >* arr_ptr = &arr_name;","title":"Declaration Syntax"},{"location":"Arrays/#initialization-syntax_2","text":"// Aggregate initialization or uniform initialization (C++11 and later). std::array< Type, size > arr_name = { val1, val2, val3, ... }; // Default initialization. std::array< Type, size > arr_name = {}; // Aggregate initialization or uniform initialization (C++11 and later). std::array< Type, size > arr_name{ val1, val2, val3, ... }; // Aggregate initialization or uniform initialization (C++11 and later). std::array< Type, size > arr_name1( { ... } ); // Move constructor. std::array< Type, size > arr_name2( std::move( arr_name1 ) ); // Aggregate initialization. std::array< Type, size > arr_name1 = { ... }; // Copy constructor. std::array< Type, size > arr_name2(arr_name1); // Aggregate initialization. std::array< Type, size > arr_name1 = { ... }; // Copy constructor. std::array< Type, size > arr_name2 = arr_name1; std::array< Type, size > arr_name1 = { val1, val2, val3, ... }; // Copy initialization. std::array< Type, size > arr_name2 = arr_name1; std::array< Type, size >* arr_ptr = new std::array< Type, size >{ ... };","title":"Initialization Syntax"},{"location":"Arrays/#syntax-for-deleting-one-dimensional-stdarray-pointers","text":"delete arr_ptr;","title":"Syntax for Deleting One-dimensional std::array Pointers"},{"location":"Arrays/#multidimensional-stdarray-not-recommend","text":"","title":"Multidimensional std::array ( Not Recommend )"},{"location":"Arrays/#declaration-syntax_3","text":"// No initialization, contain garbage values and behave unpredictably. std::array< std::array< Type, size_y >, size_x > arr_name; // No initialization, contain garbage values and behave unpredictably. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name;","title":"Declaration Syntax"},{"location":"Arrays/#initialization-syntax_3","text":"// Aggregate Initialization. std::array< std::array< Type, size_y >, size_x > arr_name = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; // Default initialization. std::array< std::array< Type, size_y >, size_x > arr_name = {}; // Uniform initialization (C++11 and later). std::array< std::array< Type, size_y >, size_x > arr_name{ { { ... /* size_y */}, { ... }, ... /* size_x */ } }; std::array< std::array< Type, size_y >, size_x > arr_name1 = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; // Copy initialization. std::array< std::array< Type, size_y >, size_x > arr_name2 = arr_name1; // Aggregate initialization. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name = { { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ } }; // Default initialization. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name = {}; // Uniform initialization (C++11 and later). std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name{ { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ } }; std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name1 = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ }; // Copy initialization. std::array< std::array< std::array< Type, size_z >, size_y >, size_x > arr_name2 = arr_name1;","title":"Initialization Syntax"},{"location":"Arrays/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"Arrays/#links","text":"std::array in cplusplus . std::array in cppreference .","title":"Links"},{"location":"Arrays/#template-parameters","text":"T : Element type. N : The number of elements in the array or 0.","title":"Template Parameters"},{"location":"Arrays/#member-types","text":"alue_type : T . ize_typ : std::size_t . ifference_type : std::ptrdiff_t . eference : value_type& . onst_reference : const value_type& . ointer : value_type . onst_pointer : const value_type . terator : LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++17), LegacyRandomAccessIterator and LegacyContiguousIterator that is a LiteralType (since C++17) to value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20). const_iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++17), LegacyRandomAccessIterator and LegacyContiguousIterator that is a LiteralType (since C++17) to const value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20). reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"Arrays/#member-functions","text":"(constructor) (implicitly declared): Initializes the array following the rules of aggregate initialization (note that default initialization may result in indeterminate values for non-class T) (public member function). (destructor) (implicitly declared): Destroys every element of the array (public member function) operator= (implicitly declared): overwrites every element of the array with the corresponding element of another array (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access specified element (public member function). front : Access the first element (public member function). back : Access the last element (public member function). data : Direct access to the underlying contiguous storage (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). fill : Fill the container with specified value (public member function).. swap : Swaps the contents (public member function).","title":"Member Functions"},{"location":"Arrays/#non-member-functions","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two arrays (function template). get( std::array ) : Accesses an element of an array (function template). std::swap( std::array ) : Specializes the std::swap algorithm (function template). to_array (C++20): Creates a std::array object from a built-in array (function template).","title":"Non-member Functions"},{"location":"Arrays/#helper-classes","text":"std::tuple_size< std::array > : Obtains the size of an array (class template specialization). std::tuple_element< std::array > : Obtains the type of the elements of array (class template specialization).","title":"Helper Classes"},{"location":"Arrays/#lexicographical-comparison-or-lexicographical-order","text":"Lexicographical comparison means that the elements of the arrays are compared in sequence , similar to how words are compared in a dictionary. The comparison starts from the first element and proceeds until a difference is found or one of the arrays is exhausted .","title":"Lexicographical Comparison or Lexicographical Order"},{"location":"Arrays/#notes","text":"Do not use an actual multidimensional array . If you need a multidimensional array, flatten it and use a one-dimensional array instead. For example, Type a2d[size_x * size_y]; and Type* a2d = new Type[size_x * size_y]; Both examples create a two-dimensional array using a one-dimensional array.. When working with actual multidimensional arrays, performance and memory issues with pointers can arise depending on how the array is allocated and accessed, as not all elements may be contiguous in memory . This can lead to problems such as memory fragmentation and cache misses . size_t is an unsigned integer type specifically designed to represent the size of objects or array indices. It is widely used to ensure portability across platforms and avoid overflow issues when working with memory sizes, since it matches the size of the addressable memory range on the system.","title":"Notes"},{"location":"Arrays/#dynamic-arrays-stdvector","text":"Dynamic Arrays ( std::vector )","title":"Dynamic Arrays (std::vector)"},{"location":"AutoAndDecltype/","text":"auto and decltype auto Explanation Syntax Usage Notes decltype Explanation Syntax Usage Notes auto and decltype auto Explanation auto is a type specifier that allows the compiler to automatically deduce the type of a variable from its initializer at compile time . This feature, introduced in C++11, is especially useful for simplifying complex type declarations, avoiding redundancy, and making code more readable . auto creates a copy of the original type unless specified otherwise (e.g., auto& for lvalue references). If the variable is initialized with a const value , auto deduces a non-const type . When the variable is initialized with an initializer list , auto deduces the type to be the corresponding container type (e.g., std::initializer_list ). auto maintains type safety by ensuring that the deduced type matches the initializer. Syntax auto var_name = initializer; Usage Variable declarations: Declare variables without specifying their type. Simplifying complex types. Range-based for loops. For example, for( auto var_name : object_name ) . Lambda expressions. Deduce a return type of a function. CPP auto funcName( para_list ) { }; CPP auto funcName( para_list ) -> RetType { }; Using auto with structured bindings. For example for( auto [x, y] : object_pair_name ) . Structured bindings , introduced in C++17, provide a way to unpack tuple-like objects (such as std::pair , std::tuple , and user-defined types with std::get ) into individual named variables. Structured Binding Notes auto can deduce whether a reference is const based on the initializer variable. However, for non-reference types, auto only deduces the type without adding const . Therefore, if you want variables deduced with auto to be const , you'd better explicitly specify const . auto can deduce whether a type is a pointer based on the initializer. auto var_name = ptr_name; <=> auto* var_name = ptr_name; \\\\ **Better** However, if you use auto to deduce a type with a pointer as the initializer, you'd better specify it explicitly with a star ( * ) . auto cannot deduce whether a type is a reference based on the initializer. Therefore, If you want the type to be deduced as a reference, specify it explicitly with & . auto & var_name = ini_name; Specifically, if the initializer is a const char pointer or a const char array (such as a string literal, \"xxx\"), auto deduces the variable to be a const char pointer . If you change the return types of your functions or APIs , auto can help us reduce the amount of code that needs to be modified. However, the code will become less readable, and some bugs may occur because the compiler will not tell us where changes are needed to adapt to these new functions. Therefore, you should avoid using auto in this case . Use auto when working with an iterator , as it can make the code more readable. When calling a function whose return type has a long name , you can use auto to make the code more readable. decltype Explanation decltype is a keyword allows you to query the type of an expression at compile time without evaluating it . This is particularly useful in template programming and situations where types are complex or unknown . The inference result is a reference type if the expression is an lvalue enclosed in parentheses . Otherwise , the inference result is the the actual type of the expression. decltype does not evaluate the expression ; it merely inspects it to determine the type. It ensures that the deduced type is consistent with the expression, aiding in type-safe code . Syntax decltype( expression ) Usage Type deductions: Determine the type of a variable based on another variable. Type deduction in templates. Defining function pointers. Use decltype to deduce return types of functions: Using with auto . CPP decltype( auto ) funcName( ... ) { }; Notes Use decltype( expression )& instead of decltype( ( lvalue ) ) , or decltype( ( expression ) )& if you want to deduce a result as a reference type , even if the expression is already a reference. Although these four expressions yield the same inference result, the first option is preferred. Add const as a prefix to decltype( expression ) if you want to deduce a result as a const type , even if the expression is already a const type. Use decltype( expression ) instead of decltype( expression )* , decltype( ( expression ) ) , or decltype( ( expression ) )* if the expression is a pointer ; the latter three do not yield the same inference result as the former.","title":"auto and decltype"},{"location":"AutoAndDecltype/#auto-and-decltype","text":"","title":"auto and decltype"},{"location":"AutoAndDecltype/#auto","text":"","title":"auto"},{"location":"AutoAndDecltype/#explanation","text":"auto is a type specifier that allows the compiler to automatically deduce the type of a variable from its initializer at compile time . This feature, introduced in C++11, is especially useful for simplifying complex type declarations, avoiding redundancy, and making code more readable . auto creates a copy of the original type unless specified otherwise (e.g., auto& for lvalue references). If the variable is initialized with a const value , auto deduces a non-const type . When the variable is initialized with an initializer list , auto deduces the type to be the corresponding container type (e.g., std::initializer_list ). auto maintains type safety by ensuring that the deduced type matches the initializer.","title":"Explanation"},{"location":"AutoAndDecltype/#syntax","text":"auto var_name = initializer;","title":"Syntax"},{"location":"AutoAndDecltype/#usage","text":"Variable declarations: Declare variables without specifying their type. Simplifying complex types. Range-based for loops. For example, for( auto var_name : object_name ) . Lambda expressions. Deduce a return type of a function. CPP auto funcName( para_list ) { }; CPP auto funcName( para_list ) -> RetType { }; Using auto with structured bindings. For example for( auto [x, y] : object_pair_name ) . Structured bindings , introduced in C++17, provide a way to unpack tuple-like objects (such as std::pair , std::tuple , and user-defined types with std::get ) into individual named variables. Structured Binding","title":"Usage"},{"location":"AutoAndDecltype/#notes","text":"auto can deduce whether a reference is const based on the initializer variable. However, for non-reference types, auto only deduces the type without adding const . Therefore, if you want variables deduced with auto to be const , you'd better explicitly specify const . auto can deduce whether a type is a pointer based on the initializer. auto var_name = ptr_name; <=> auto* var_name = ptr_name; \\\\ **Better** However, if you use auto to deduce a type with a pointer as the initializer, you'd better specify it explicitly with a star ( * ) . auto cannot deduce whether a type is a reference based on the initializer. Therefore, If you want the type to be deduced as a reference, specify it explicitly with & . auto & var_name = ini_name; Specifically, if the initializer is a const char pointer or a const char array (such as a string literal, \"xxx\"), auto deduces the variable to be a const char pointer . If you change the return types of your functions or APIs , auto can help us reduce the amount of code that needs to be modified. However, the code will become less readable, and some bugs may occur because the compiler will not tell us where changes are needed to adapt to these new functions. Therefore, you should avoid using auto in this case . Use auto when working with an iterator , as it can make the code more readable. When calling a function whose return type has a long name , you can use auto to make the code more readable.","title":"Notes"},{"location":"AutoAndDecltype/#decltype","text":"","title":"decltype"},{"location":"AutoAndDecltype/#explanation_1","text":"decltype is a keyword allows you to query the type of an expression at compile time without evaluating it . This is particularly useful in template programming and situations where types are complex or unknown . The inference result is a reference type if the expression is an lvalue enclosed in parentheses . Otherwise , the inference result is the the actual type of the expression. decltype does not evaluate the expression ; it merely inspects it to determine the type. It ensures that the deduced type is consistent with the expression, aiding in type-safe code .","title":"Explanation"},{"location":"AutoAndDecltype/#syntax_1","text":"decltype( expression )","title":"Syntax"},{"location":"AutoAndDecltype/#usage_1","text":"Type deductions: Determine the type of a variable based on another variable. Type deduction in templates. Defining function pointers. Use decltype to deduce return types of functions: Using with auto . CPP decltype( auto ) funcName( ... ) { };","title":"Usage"},{"location":"AutoAndDecltype/#notes_1","text":"Use decltype( expression )& instead of decltype( ( lvalue ) ) , or decltype( ( expression ) )& if you want to deduce a result as a reference type , even if the expression is already a reference. Although these four expressions yield the same inference result, the first option is preferred. Add const as a prefix to decltype( expression ) if you want to deduce a result as a const type , even if the expression is already a const type. Use decltype( expression ) instead of decltype( expression )* , decltype( ( expression ) ) , or decltype( ( expression ) )* if the expression is a pointer ; the latter three do not yield the same inference result as the former.","title":"Notes"},{"location":"Bindings/","text":"Function Binding Explanation Static Binding (Early Binding) Dynamic Binding (Late Binding) C++17 Bindings Explanation Structured Binding Explanation Syntax std::tie Explanation Syntax Differences Between Structured Binding and std::tie Pairs and Tuples std::bind Other Bindings Variable Binding Name Binding Object Binding Template Binding Scope Binding Reference Binding Constant Binding Function Binding Explanation Function binding refers to the association between a function call and the actual function definition that gets executed . This process can occur at different times , leading to two main types of binding: static binding and dynamic binding. Static Binding (Early Binding) Static binding, also known as early binding , occurs at compile time . The compiler determines which function to call based on the type of the reference or pointer , not the actual object. This means that the function call is resolved before the program runs , leading to faster execution since no additional checks are needed at runtime. Static binding is used for non-virtual functions , function overloading , and static method calls . This binding method is generally more efficient due to compile-time resolution, making it a preferred choice when polymorphism is not needed. Dynamic Binding (Late Binding) Dynamic binding, or late binding , occurs at runtime . The actual function to call is determined by the type of the object being pointed to rather than the type of the reference or pointer. This allows for polymorphic behavior , where the program can decide which function to invoke based on the actual object at runtime . Dynamic binding is primarily used with virtual functions in class hierarchies, enabling polymorphism . This approach provides greater flexibility but incurs a slight performance overhead due to the need for runtime type checks , typically using a virtual table (vtable) to resolve function calls. C++17 Bindings Explanation C++17 bindings provide a way to unpack elements from tuple-like objects, making it easier to work with multiple return values from functions or complex data structures. This improves code clarity and reduces boilerplate code . Structured Binding Explanation Structured binding allows you to declare multiple variables that can simultaneously hold the values extracted from tuple-like structures (such as std::tuple , std::pair , arrays, or user-defined types). It simplifies the syntax for unpacking values and allows for more expressive code. The number of variables in [var1, var2, ...] is equal to the number of values provided by the initializer . Syntax auto [var1, var2, ...] = initializer; auto& [var1, var2, ...] = initializer; // Use it with a range-based for loop. for ( auto& [var1, var2, ...] : container ); std::tie Explanation std::tie creates a tuple of non-const references , allowing you to unpack values from a tuple-like structure (such as std::tuple , std::pair , or similar) without copying them. This is particularly useful when working with functions that return multiple values in tuple format . The initializer passed to std::tie must evaluate to a tuple-like structure , such as std::tuple or std::pair . It will not work with types that lack a tuple-like interface , such as std::get . std::tie should not be used to bind a temporary object to avoid undefined behavior . Syntax Type1 var1; Type2 var2; ...; std::tie( var1, var2, ... ) = initializer; Differences Between Structured Binding and std::tie Their syntax differs. Structured binding can unpack all values from the initializer into new variables or references , while std::tie only binds these values to references . Structured binding can bind a wider variety of types than std::tie , as it can unpack values from any tuple-like structure, including arrays and user-defined types that implement the necessary interface, while std::tie is limited to binding only to existing variables and specifically works with tuples or pairs . Pairs and Tuples Pairs and Tuples std::bind std::bind Other Bindings Variable Binding Variable binding involves associating a variable with a specific memory location where its value is stored. The binding defines the variable's lifetime and scope within the program. Once a variable is declared, it remains bound to its memory location until it goes out of scope or is explicitly deallocated. Name Binding Name binding refers to the process of associating an identifier (such as a variable, function, or class name) with its corresponding entity during the compilation phase. This binding is crucial for resolving names and ensuring that the correct entity is referenced throughout the program. Object Binding Object binding involves associating an object instance with its class definition . This binding allows the object to access the class's member functions and variables . The object is bound to the class's interface , providing the necessary context for member function calls. Template Binding Template binding occurs when template parameters are associated with specific types or values during the instantiation of templates. This process allows C++ to create type-safe generic functions and classes , enabling code reuse without sacrificing type safety. The binding is determined by the types provided at the point of instantiation. Scope Binding Scope binding defines the region within which a name is valid . Names can be bound to different scopes , including local, global, and class scopes . This binding determines the visibility and lifetime of the name, influencing how and where it can be accessed in the code. Reference Binding Reference binding occurs when a reference variable is associated with an existing variable . The reference serves as an alias for the original variable , allowing modifications made through the reference to affect the original. This binding provides a way to create direct connections to existing variables without copying their values. Constant Binding Constant binding refers to the association of a variable with a constant value that cannot be changed after its initialization. This binding is important for enforcing immutability, ensuring that certain values remain fixed throughout the program's execution. Constant binding helps maintain program integrity and prevents unintended modifications.","title":"Bindings"},{"location":"Bindings/#function-binding","text":"","title":"Function Binding"},{"location":"Bindings/#explanation","text":"Function binding refers to the association between a function call and the actual function definition that gets executed . This process can occur at different times , leading to two main types of binding: static binding and dynamic binding.","title":"Explanation"},{"location":"Bindings/#static-binding-early-binding","text":"Static binding, also known as early binding , occurs at compile time . The compiler determines which function to call based on the type of the reference or pointer , not the actual object. This means that the function call is resolved before the program runs , leading to faster execution since no additional checks are needed at runtime. Static binding is used for non-virtual functions , function overloading , and static method calls . This binding method is generally more efficient due to compile-time resolution, making it a preferred choice when polymorphism is not needed.","title":"Static Binding (Early Binding)"},{"location":"Bindings/#dynamic-binding-late-binding","text":"Dynamic binding, or late binding , occurs at runtime . The actual function to call is determined by the type of the object being pointed to rather than the type of the reference or pointer. This allows for polymorphic behavior , where the program can decide which function to invoke based on the actual object at runtime . Dynamic binding is primarily used with virtual functions in class hierarchies, enabling polymorphism . This approach provides greater flexibility but incurs a slight performance overhead due to the need for runtime type checks , typically using a virtual table (vtable) to resolve function calls.","title":"Dynamic Binding (Late Binding)"},{"location":"Bindings/#c17-bindings","text":"","title":"C++17 Bindings"},{"location":"Bindings/#explanation_1","text":"C++17 bindings provide a way to unpack elements from tuple-like objects, making it easier to work with multiple return values from functions or complex data structures. This improves code clarity and reduces boilerplate code .","title":"Explanation"},{"location":"Bindings/#structured-binding","text":"","title":"Structured Binding"},{"location":"Bindings/#explanation_2","text":"Structured binding allows you to declare multiple variables that can simultaneously hold the values extracted from tuple-like structures (such as std::tuple , std::pair , arrays, or user-defined types). It simplifies the syntax for unpacking values and allows for more expressive code. The number of variables in [var1, var2, ...] is equal to the number of values provided by the initializer .","title":"Explanation"},{"location":"Bindings/#syntax","text":"auto [var1, var2, ...] = initializer; auto& [var1, var2, ...] = initializer; // Use it with a range-based for loop. for ( auto& [var1, var2, ...] : container );","title":"Syntax"},{"location":"Bindings/#stdtie","text":"","title":"std::tie"},{"location":"Bindings/#explanation_3","text":"std::tie creates a tuple of non-const references , allowing you to unpack values from a tuple-like structure (such as std::tuple , std::pair , or similar) without copying them. This is particularly useful when working with functions that return multiple values in tuple format . The initializer passed to std::tie must evaluate to a tuple-like structure , such as std::tuple or std::pair . It will not work with types that lack a tuple-like interface , such as std::get . std::tie should not be used to bind a temporary object to avoid undefined behavior .","title":"Explanation"},{"location":"Bindings/#syntax_1","text":"Type1 var1; Type2 var2; ...; std::tie( var1, var2, ... ) = initializer;","title":"Syntax"},{"location":"Bindings/#differences-between-structured-binding-and-stdtie","text":"Their syntax differs. Structured binding can unpack all values from the initializer into new variables or references , while std::tie only binds these values to references . Structured binding can bind a wider variety of types than std::tie , as it can unpack values from any tuple-like structure, including arrays and user-defined types that implement the necessary interface, while std::tie is limited to binding only to existing variables and specifically works with tuples or pairs .","title":"Differences Between Structured Binding and std::tie"},{"location":"Bindings/#pairs-and-tuples","text":"Pairs and Tuples","title":"Pairs and Tuples"},{"location":"Bindings/#stdbind","text":"std::bind","title":"std::bind"},{"location":"Bindings/#other-bindings","text":"","title":"Other Bindings"},{"location":"Bindings/#variable-binding","text":"Variable binding involves associating a variable with a specific memory location where its value is stored. The binding defines the variable's lifetime and scope within the program. Once a variable is declared, it remains bound to its memory location until it goes out of scope or is explicitly deallocated.","title":"Variable Binding"},{"location":"Bindings/#name-binding","text":"Name binding refers to the process of associating an identifier (such as a variable, function, or class name) with its corresponding entity during the compilation phase. This binding is crucial for resolving names and ensuring that the correct entity is referenced throughout the program.","title":"Name Binding"},{"location":"Bindings/#object-binding","text":"Object binding involves associating an object instance with its class definition . This binding allows the object to access the class's member functions and variables . The object is bound to the class's interface , providing the necessary context for member function calls.","title":"Object Binding"},{"location":"Bindings/#template-binding","text":"Template binding occurs when template parameters are associated with specific types or values during the instantiation of templates. This process allows C++ to create type-safe generic functions and classes , enabling code reuse without sacrificing type safety. The binding is determined by the types provided at the point of instantiation.","title":"Template Binding"},{"location":"Bindings/#scope-binding","text":"Scope binding defines the region within which a name is valid . Names can be bound to different scopes , including local, global, and class scopes . This binding determines the visibility and lifetime of the name, influencing how and where it can be accessed in the code.","title":"Scope Binding"},{"location":"Bindings/#reference-binding","text":"Reference binding occurs when a reference variable is associated with an existing variable . The reference serves as an alias for the original variable , allowing modifications made through the reference to affect the original. This binding provides a way to create direct connections to existing variables without copying their values.","title":"Reference Binding"},{"location":"Bindings/#constant-binding","text":"Constant binding refers to the association of a variable with a constant value that cannot be changed after its initialization. This binding is important for enforcing immutability, ensuring that certain values remain fixed throughout the program's execution. Constant binding helps maintain program integrity and prevents unintended modifications.","title":"Constant Binding"},{"location":"CPPPerface/","text":"Preface Some Basic Concepts Declarations General Explanations Forward Declarations Definitions Variables, Instances, Objects, Initializers and Values Variables Explanation Characteristics Temporary Variables Instances Explanation Characteristics Objects Explanation Characteristics Temporary Objects Initializers Explanation Values Explanation Relationships Between Them Variables Instances Objects Pointers and References Pointers Explanation Void Pointers Null Pointers Dangling Pointers Wild Pointers References Parameters Arguments Expressions Explanation Types of Expressions in C++ Lvalues and Rvalues: Value Categories in C++ Lvalues (Left Values) Rvalues (Right Values) Lvalue References ( Type& ) Explanation Usage Notes How to Identify Whether a Value is an Lvalue or an Rvalue Rvalue References ( Type&& ) Explanation Usage Move Semantics Explanation Usage std::move Explanation Usage Interface Keyword Type Specifier Segmentation Fault (Linux) and Access Violation (Win) Notes Preface If you have sufficient experience with C++ projects, you can proceed with reading this additional summary. It may also be beneficial to revisit C++ tutorial videos and relearn the language from scratch. Personally, I follow an influencer named Cherno, a game and game engine developer. He uploads numerous C++ tutorial series, from which I can learn various C++ techniques. Additionally, if you have time, you can try implementing some standard libraries on your own. You don\u2019t need to implement all their functions, just their core functionality. If you\u2019re unsure how to implement them, you can search for online tutorials or examine the source code. Although the source code may be difficult to understand, studying it can still be beneficial. Moreover, if you want to explore certain features or functions provided by C++, you can consult ChatGPT on topics like how to effectively use specific libraries or discover lesser-known functions. ChatGPT is a helpful tool for learning a wide range of topics. However, you shouldn't rely on it too heavily, as that might hinder your ability to study independently. Each time ChatGPT provides an answer, you should verify it and consider whether it is accurate, as ChatGPT does not guarantee 100% correctness. You should also read and internalize the results to retain the information. You can also refer to C++ tutorial books or websites, such as <<The C++ Programming Language>> and <<C++ Primer Plus>> , cplusplus , cppreference , learncpp and tutorialspoint or a command cppman in Linux. When reading any tutorial, including this one, focus on the basic concepts , their definitions, explanations, and key characteristics, paying particular attention to the bold text, as these concepts often appear in other contexts. You\u2019d better take notes and create a mind map to retain everything you consider necessary, like a simple tutorial. Lastly, it\u2019s important to note that different compilers have slightly different implementations of the Standard Template Library (STL). While they provide the same library, there may be minor variations in implementation. For instance, in std::vector, if the size exceeds its capacity, it grows by 50% in Clang, whereas it grows by 100% in GCC. Ask ChatGPT the following question to learn more: There are many different STL implementations in C++; some are more efficient than the default STL, such as EASTL. Why hasn't the default STL been replaced with these more efficient alternatives? Some Basic Concepts Declarations General Explanations The term declaration refers to the introduction of a variable, function, class, or other entity to the program, specifying its name and type without allocating storage or providing an implementation . It merely states that a function, class, struct or variable exists without concerning itself with a definition. Forward Declarations It is a declaration of a class, function, or variable that informs the compiler of its existence without providing the full definition at that point. It allows the compiler to handle references to an entity (e.g., a class or a function) without needing to know all the details at that time. The complete definition is provided later in the code. This is typically used to improve compilation times , resolve circular dependencies , or when the full details of the entity are not yet required. Definitions A definition provides a body that implements a function, class, struct or variable. It includes an actual value or implementation and allocates storage for variables . Variables, Instances, Objects, Initializers and Values Variables Explanation A variable is a named storage location in memory that holds a value . It has a specific type (such as int , float , or a custom class) and is declared in the program to store data that can be accessed and modified. Characteristics A name (identifier) is required. A type is specified (determining the kind of value it can hold). It occupies memory in the program. Temporary Variables A temporary variable is a variable that is created to hold a value temporarily during the execution of a program. It typically exists only within a specific scope or block of code , often used for intermediate calculations or to store results of expressions . Traditionally , a temporary variable must have a name . However, in C++ , temporary variables can also refer to unnamed temporary objects that arise during operations, such as the result of a function call or type conversion, which exist only for the duration of their use. They help simplify code without requiring permanent storage. Instances Explanation An instance is a concrete occurrence of a particular data type . This term is most commonly used in the context of user-defined types like classes or structs . When you create an instance of a class, you're creating an object of that class type. Characteristics Refers to a specific occurrence of a class or struct . Instances of a class are often called objects . Objects Explanation An object is a region of memory that has a type, value , and, in most cases, a name (optional) . Every variable is an object, and every instance of a class is also an object. The term object is more general and refers to any instance of a type that occupies memory, whether it\u2019s built-in (like int , double ) or user-defined (like a class ). An object is generally defined as an instance of a data type that occupies memory and has attributes (data members) and behaviors (methods) when it comes to user-defined types (classes) . For built-in types (like int , char , etc.), the term \"object\" can also apply . Characteristics An instance of any type (built-in or user-defined). Occupies memory and has a type . May or may not have a name (temporary objects don\u2019t have names). Includes variables, class instances, dynamically allocated memory, and temporary values . Temporary Objects A temporary object in C++ is an unnamed object that is created during the evaluation of an expression or as a result of a function call. Temporary objects typically exist for a short duration and are automatically destroyed at the end of the full expression in which they were created. Initializers Explanation An initializer is a way to assign a value to a variable or an object at the time of its creation . It can be an object, a function, a variable, a value, an expression, and so on. All items used to initialize a target are referred to as initializers. Values Explanation A value represents data that can be stored in variables or objects . It is a specific instance of data, such as numbers, characters, or more complex data types. Values can be of various types, including: Primitive types. Composite types. Classes: Objects created from class definitions that can hold data and methods (e.g., ClassName obj_name; ). Relationships Between Them Variables A variable is a named object . Every variable is an object , but not all objects are variables . A variable always refers to an object, but it also provides a name for it, allowing it to be used and modified in the code. Traditionally , temprorary variables are named objects while temporary objects are unnamed objects . However, in C++ , temporary variables can also refer to unnamed temporary objects . Instances An instance is a specific object of a class or user-defined type . It represents a concrete realization of that class, holding data and having behaviors defined by the class. When you create an instance of a class, you are creating an object of that class. Objects An object is the most general term . It refers to any entity that occupies memory and has a type . Objects can be variables, instances of classes, temporary objects, or even dynamically allocated memory that doesn't have a name (like objects created with new ). Pointers and References Pointers Explanation A pointer is a variable that stores the memory address of another variable or an object . Pointers enable dynamic memory allocation , efficient array handling, and the ability to pass large data structures to functions without copying them. They require careful management of memory (allocation/deallocation). They can be null ( nullptr ) . After a pointer is released using delete or free , it should be set to nullptr . After a pointer is declared , it should be initialized with nullptr or a concret address immediately . Before releasing a pointer, it should be checked to ensure it is not nullptr . It is possible to encapsulate safe and efficient resource release functions within a macro , and conditionally enable or disable them based on the selected build configuration. Void Pointers A void pointer, also known as a generic pointer , is a type of pointer that can point to any data type . It is declared using the void keyword and is often used for functions that need to handle different data types or for dynamic memory allocation . However, because a void pointer does not have a specific type associated with it, you cannot dereference it directly without first casting it to a specific pointer type . Functions like malloc and calloc return void pointer which must be cast to the appropriate type. Null Pointers nullptr is a null pointer constant introduced in C++11. It represents a pointer that does not point to any valid memory location . It provides type safety compared to the traditional NULL, which is typically defined as 0 . Access nullptr: segmentation fault (Linux), access violation (Win) . Dangling Pointers A dangling pointer is a pointer that points to a memory location that has been deallocated or released . Accessing or dereferencing a dangling pointer can lead to undefined behavior , such as crashes or corrupted data. Wild Pointers A wild pointer, or uninitialized pointer, refers to a pointer that has not been initialized to point to a specific memory address. Accessing a wild pointer can lead to unpredictable results since it may point to any arbitrary location in memory. References A reference is an alias for an existing variable . It allows you to create another name for a variable without making a copy of it. References are declared using an ampersand ( & ) in the declaration. A reference must be initialized when it is declared and cannot be changed to refer to another variable later. Unlike pointers, references cannot be null . They must always refer to a valid object. A reference is defined as a type. However, I believe it is merely an alias , not a distinct type, because auto cannot deduce a type as a reference without using & . A reference is neither a variable nor an object . Categories: Lvalue References ( Type& ) Rvalue References ( Type&& ) Universial References (Forward References) Parameters A parameter is a variable declared in a function definition . It serves as a placeholder for the values that will be passed to the function when it is called. Parameters are used to receive input values within the function and specify the type of data the function expects. Arguments An argument is an actual value, variable, object or reference passed to the function when it is called. Arguments are the specific data supplied to the function's parameters. Expressions Explanation An expression is any valid combination of variables, literals, operators, or function calls that evaluates to a value . Expressions are the building blocks of C++ programs and can range from simple values like 42 to complex operations involving multiple variables and function calls. They are evaluated at runtime to produce a result, which may or may not be used further in the program. Types of Expressions in C++ Literal expressions A literal (such as 42 , a , or 3.14 ) is the simplest form of an expression. It evaluates to its own value. Variable expressions A variable by itself is also an expression, and it evaluates to the value it stores. For example, CPP int x = 10; x; // Evaluates to 10. Arithmetic expressions These use arithmetic operators ( + , - , * , / , % ) to produce numeric results. For example, CPP int y = 5 + 3 * 2; // Evaluates to 11. Logical and relational expressions Logical expressions ( && , || , ! ) produce a boolean result. Relational expressions ( == , != , < , > , <= , >= ) compare values and return true or false. For example, CPP bool result = (x > && (y < 10); // Evaluates to true. Assignment expressions An assignment operation is also an expression that returns the assigned value. For example, CPP int z; z = 20; // Evaluates to 20. Function call expressions A function call acts as an expression, with the result being the return value of the function. For example, CPP int absValue = std::abs( -5 ); // Evaluates to 5. Conditional (ternary) expressions A ternary expression evaluates a condition and returns one of two values based on the result. For example, CPP int max = (x > y) ? x : y; // Returns x if x > y, otherwise y. Member access expressions Accessing a member of an object or a struct is also an expression. For example, CPP struct Point { int x, y; }; Point p = {3, 4}; p.x; // Evaluates to 3. Pointer expressions Dereferencing a pointer or using the & operator to take the address of a variable forms an expression. For example, CPP int* ptr = &x; // Evaluates to the address of x. *ptr; // Evaluates to the value of x (10). Lvalues and Rvalues: Value Categories in C++ Lvalues (Left Values) A lvalue refers to an object or memory location that persists beyond a single expression and occupies some identifiable location in memory (i.e., it has an address). It can appear on the left side or the right side of an assignment Typically , it refers to variables , array elements , or dereferenced pointers . It can take the address of an lvalue using the address-of operator ( & ). Rvalues (Right Values) An rvalue refers to temporary objects or values that do not persist beyond the expression in which they are used. An rvalue does not have a specific memory address , meaning it cannot be assigned a memory location. It cannot appear on the left-hand side of an assignment. Its examples include literals , temporary results of expressions, and return values of functions without & . Lvalue References ( Type& ) Explanation An lvalue reference is a reference to a persistent object (i.e., an object with a well-defined memory address, such as variables or class members). It binds only to lvalues \u2014 objects that can appear on the left side of an assignment. However, a const lvalue reference can bind to a literal value . Usage Modify the value of an existing object. Pass objects by reference to functions, avoiding unnecessary copying . Notes A normal reference can't store an rvalue but a const reference can . A normal reference parameter of a function can't accept an rvalue but a const reference parameter can . How to Identify Whether a Value is an Lvalue or an Rvalue Define a normal reference for a value, if it can be store by a reference, it is an lvalur. Otherwise, it is an rvalue. Rvalue References ( Type&& ) Explanation An rvalue reference is a reference to a temporary object (an rvalue) that is about to expire. It can bind only to rvalues , such as the result of expressions or moved objects (e.g., via std::move ). This makes rvalue references ideal for move semantics , allowing efficient transfer of resources. However, for primitive types , using std::move does not provide any meaningful advantage, as it behaves much like a copy . This is primarily because primitive types do not have complex resource management like objects that own dynamic memory. When an rvalue reference is named (i.e., bound to a variable), the compiler treats it as an lvalue . Rvalue references are a way for the compiler to distinguish between lvalues (objects that have a name and can be assigned to) and rvalues (temporary objects that are about to go out of scope). However, just accepting an rvalue reference in a function does not automatically mean that the object will be moved . Rvalue reference simply indicates that the function can accept an rvalue (temporary object). std::move is the mechanism used to cast an lvalue into an rvalue, signaling that you want to move the object instead of copying it. Even when a function receives arguments as rvalue references (i.e., when they are passed as Type&& ), you still need to use std::move explicitly to transfer ownership of these arguments to other objects. Usage Implement move constructors and move assignment operators to avoid unnecessary copying . Optimize performance by transferring resources from one object to another. Move Semantics Explanation Move semantics, introduced in C++11, optimizes program performance by transferring resources from one object to another instead of copying them. It uses rvalue references ( Type&& ) to efficiently move resources, such as dynamically allocated memory, from temporary or \"expired\" objects without incurring the overhead of deep copies . Essentially, move semantics functions like assigning one pointer to another . Rather than copying data, ownership of the resources is transferred between objects, reducing unnecessary copying and enhancing performance . Usage Rvalue references ( Type&& ) bind to temporary or \"soon-to-expire\" objects . These references allow you to move resources , leaving the original object in a valid but empty state. The compiler may optimize your code when you use move semantics in move constructors , move assignment operators , and when returning objects by value . std::move Explanation A utility function that casts an object to an rvalue reference , enabling move semantics . It does not perform any movement itself but indicates that the object can be moved. For all primitive-type variables including poiners and references, it does nothing, only copys them directly. It only tells the compiler to treat an object as an rvalue reference . Even when a function receives arguments as rvalue references (i.e., when they are passed as Type&& ), you still need to use std::move explicitly to transfer ownership of these arguments to other objects. Usage Everytime, if you want to assign an object that you want to remove after assigning to a variable, you can use std::move . To deal with double deletion , the original pointer should point a nullptr after std::move moved its data to another pointer. Interface In C++, the term \"interface\" does not have a formal definition like it does in some other programming languages (like Java). However, in C++, an interface is generally understood to be a class that defines a set of pure virtual functions , which means that it declares functions that must be implemented by derived classes but does not provide any implementation of its own . It only contains pure virtual functions . Keyword A keyword is a reserved word that has a predefined meaning in the language and cannot be used as an identifier (such as a variable name, function name, etc.). Keywords are part of the C++ syntax and represent fundamental constructs or operations in the language. Type Specifier A type specifier is used to define the type of a variable, function return value, or object . Type specifiers tell the compiler what kind of data the variable will hold or the function will return. They are an essential part of variable declarations and type definitions. Segmentation Fault (Linux) and Access Violation (Win) Access nullptr, for example, Type *ptr = nullptr; (*ptr) = val; . Access protected addredd, for example, Type *ptr = 0; (*ptr) = val; . Modify read-only memory, for example, const Type var_name = val1; var_name = val2; . Stack overflow, infinite loop. Multiple destruction or multiple deletion. Notes C++: performance, memory, optimization, safe or not; scope ({})( where we can access the function/object/... ) and lifetime; make code clearer.","title":"CPP Perface"},{"location":"CPPPerface/#preface","text":"If you have sufficient experience with C++ projects, you can proceed with reading this additional summary. It may also be beneficial to revisit C++ tutorial videos and relearn the language from scratch. Personally, I follow an influencer named Cherno, a game and game engine developer. He uploads numerous C++ tutorial series, from which I can learn various C++ techniques. Additionally, if you have time, you can try implementing some standard libraries on your own. You don\u2019t need to implement all their functions, just their core functionality. If you\u2019re unsure how to implement them, you can search for online tutorials or examine the source code. Although the source code may be difficult to understand, studying it can still be beneficial. Moreover, if you want to explore certain features or functions provided by C++, you can consult ChatGPT on topics like how to effectively use specific libraries or discover lesser-known functions. ChatGPT is a helpful tool for learning a wide range of topics. However, you shouldn't rely on it too heavily, as that might hinder your ability to study independently. Each time ChatGPT provides an answer, you should verify it and consider whether it is accurate, as ChatGPT does not guarantee 100% correctness. You should also read and internalize the results to retain the information. You can also refer to C++ tutorial books or websites, such as <<The C++ Programming Language>> and <<C++ Primer Plus>> , cplusplus , cppreference , learncpp and tutorialspoint or a command cppman in Linux. When reading any tutorial, including this one, focus on the basic concepts , their definitions, explanations, and key characteristics, paying particular attention to the bold text, as these concepts often appear in other contexts. You\u2019d better take notes and create a mind map to retain everything you consider necessary, like a simple tutorial. Lastly, it\u2019s important to note that different compilers have slightly different implementations of the Standard Template Library (STL). While they provide the same library, there may be minor variations in implementation. For instance, in std::vector, if the size exceeds its capacity, it grows by 50% in Clang, whereas it grows by 100% in GCC. Ask ChatGPT the following question to learn more: There are many different STL implementations in C++; some are more efficient than the default STL, such as EASTL. Why hasn't the default STL been replaced with these more efficient alternatives?","title":"Preface"},{"location":"CPPPerface/#some-basic-concepts","text":"","title":"Some Basic Concepts"},{"location":"CPPPerface/#declarations","text":"","title":"Declarations"},{"location":"CPPPerface/#general-explanations","text":"The term declaration refers to the introduction of a variable, function, class, or other entity to the program, specifying its name and type without allocating storage or providing an implementation . It merely states that a function, class, struct or variable exists without concerning itself with a definition.","title":"General Explanations"},{"location":"CPPPerface/#forward-declarations","text":"It is a declaration of a class, function, or variable that informs the compiler of its existence without providing the full definition at that point. It allows the compiler to handle references to an entity (e.g., a class or a function) without needing to know all the details at that time. The complete definition is provided later in the code. This is typically used to improve compilation times , resolve circular dependencies , or when the full details of the entity are not yet required.","title":"Forward Declarations"},{"location":"CPPPerface/#definitions","text":"A definition provides a body that implements a function, class, struct or variable. It includes an actual value or implementation and allocates storage for variables .","title":"Definitions"},{"location":"CPPPerface/#variables-instances-objects-initializers-and-values","text":"","title":"Variables, Instances, Objects, Initializers and Values"},{"location":"CPPPerface/#variables","text":"","title":"Variables"},{"location":"CPPPerface/#explanation","text":"A variable is a named storage location in memory that holds a value . It has a specific type (such as int , float , or a custom class) and is declared in the program to store data that can be accessed and modified.","title":"Explanation"},{"location":"CPPPerface/#characteristics","text":"A name (identifier) is required. A type is specified (determining the kind of value it can hold). It occupies memory in the program.","title":"Characteristics"},{"location":"CPPPerface/#temporary-variables","text":"A temporary variable is a variable that is created to hold a value temporarily during the execution of a program. It typically exists only within a specific scope or block of code , often used for intermediate calculations or to store results of expressions . Traditionally , a temporary variable must have a name . However, in C++ , temporary variables can also refer to unnamed temporary objects that arise during operations, such as the result of a function call or type conversion, which exist only for the duration of their use. They help simplify code without requiring permanent storage.","title":"Temporary Variables"},{"location":"CPPPerface/#instances","text":"","title":"Instances"},{"location":"CPPPerface/#explanation_1","text":"An instance is a concrete occurrence of a particular data type . This term is most commonly used in the context of user-defined types like classes or structs . When you create an instance of a class, you're creating an object of that class type.","title":"Explanation"},{"location":"CPPPerface/#characteristics_1","text":"Refers to a specific occurrence of a class or struct . Instances of a class are often called objects .","title":"Characteristics"},{"location":"CPPPerface/#objects","text":"","title":"Objects"},{"location":"CPPPerface/#explanation_2","text":"An object is a region of memory that has a type, value , and, in most cases, a name (optional) . Every variable is an object, and every instance of a class is also an object. The term object is more general and refers to any instance of a type that occupies memory, whether it\u2019s built-in (like int , double ) or user-defined (like a class ). An object is generally defined as an instance of a data type that occupies memory and has attributes (data members) and behaviors (methods) when it comes to user-defined types (classes) . For built-in types (like int , char , etc.), the term \"object\" can also apply .","title":"Explanation"},{"location":"CPPPerface/#characteristics_2","text":"An instance of any type (built-in or user-defined). Occupies memory and has a type . May or may not have a name (temporary objects don\u2019t have names). Includes variables, class instances, dynamically allocated memory, and temporary values .","title":"Characteristics"},{"location":"CPPPerface/#temporary-objects","text":"A temporary object in C++ is an unnamed object that is created during the evaluation of an expression or as a result of a function call. Temporary objects typically exist for a short duration and are automatically destroyed at the end of the full expression in which they were created.","title":"Temporary Objects"},{"location":"CPPPerface/#initializers","text":"","title":"Initializers"},{"location":"CPPPerface/#explanation_3","text":"An initializer is a way to assign a value to a variable or an object at the time of its creation . It can be an object, a function, a variable, a value, an expression, and so on. All items used to initialize a target are referred to as initializers.","title":"Explanation"},{"location":"CPPPerface/#values","text":"","title":"Values"},{"location":"CPPPerface/#explanation_4","text":"A value represents data that can be stored in variables or objects . It is a specific instance of data, such as numbers, characters, or more complex data types. Values can be of various types, including: Primitive types. Composite types. Classes: Objects created from class definitions that can hold data and methods (e.g., ClassName obj_name; ).","title":"Explanation"},{"location":"CPPPerface/#relationships-between-them","text":"","title":"Relationships Between Them"},{"location":"CPPPerface/#variables_1","text":"A variable is a named object . Every variable is an object , but not all objects are variables . A variable always refers to an object, but it also provides a name for it, allowing it to be used and modified in the code. Traditionally , temprorary variables are named objects while temporary objects are unnamed objects . However, in C++ , temporary variables can also refer to unnamed temporary objects .","title":"Variables"},{"location":"CPPPerface/#instances_1","text":"An instance is a specific object of a class or user-defined type . It represents a concrete realization of that class, holding data and having behaviors defined by the class. When you create an instance of a class, you are creating an object of that class.","title":"Instances"},{"location":"CPPPerface/#objects_1","text":"An object is the most general term . It refers to any entity that occupies memory and has a type . Objects can be variables, instances of classes, temporary objects, or even dynamically allocated memory that doesn't have a name (like objects created with new ).","title":"Objects"},{"location":"CPPPerface/#pointers-and-references","text":"","title":"Pointers and References"},{"location":"CPPPerface/#pointers","text":"","title":"Pointers"},{"location":"CPPPerface/#explanation_5","text":"A pointer is a variable that stores the memory address of another variable or an object . Pointers enable dynamic memory allocation , efficient array handling, and the ability to pass large data structures to functions without copying them. They require careful management of memory (allocation/deallocation). They can be null ( nullptr ) . After a pointer is released using delete or free , it should be set to nullptr . After a pointer is declared , it should be initialized with nullptr or a concret address immediately . Before releasing a pointer, it should be checked to ensure it is not nullptr . It is possible to encapsulate safe and efficient resource release functions within a macro , and conditionally enable or disable them based on the selected build configuration.","title":"Explanation"},{"location":"CPPPerface/#void-pointers","text":"A void pointer, also known as a generic pointer , is a type of pointer that can point to any data type . It is declared using the void keyword and is often used for functions that need to handle different data types or for dynamic memory allocation . However, because a void pointer does not have a specific type associated with it, you cannot dereference it directly without first casting it to a specific pointer type . Functions like malloc and calloc return void pointer which must be cast to the appropriate type.","title":"Void Pointers"},{"location":"CPPPerface/#null-pointers","text":"nullptr is a null pointer constant introduced in C++11. It represents a pointer that does not point to any valid memory location . It provides type safety compared to the traditional NULL, which is typically defined as 0 . Access nullptr: segmentation fault (Linux), access violation (Win) .","title":"Null Pointers"},{"location":"CPPPerface/#dangling-pointers","text":"A dangling pointer is a pointer that points to a memory location that has been deallocated or released . Accessing or dereferencing a dangling pointer can lead to undefined behavior , such as crashes or corrupted data.","title":"Dangling Pointers"},{"location":"CPPPerface/#wild-pointers","text":"A wild pointer, or uninitialized pointer, refers to a pointer that has not been initialized to point to a specific memory address. Accessing a wild pointer can lead to unpredictable results since it may point to any arbitrary location in memory.","title":"Wild Pointers"},{"location":"CPPPerface/#references","text":"A reference is an alias for an existing variable . It allows you to create another name for a variable without making a copy of it. References are declared using an ampersand ( & ) in the declaration. A reference must be initialized when it is declared and cannot be changed to refer to another variable later. Unlike pointers, references cannot be null . They must always refer to a valid object. A reference is defined as a type. However, I believe it is merely an alias , not a distinct type, because auto cannot deduce a type as a reference without using & . A reference is neither a variable nor an object . Categories: Lvalue References ( Type& ) Rvalue References ( Type&& ) Universial References (Forward References)","title":"References"},{"location":"CPPPerface/#parameters","text":"A parameter is a variable declared in a function definition . It serves as a placeholder for the values that will be passed to the function when it is called. Parameters are used to receive input values within the function and specify the type of data the function expects.","title":"Parameters"},{"location":"CPPPerface/#arguments","text":"An argument is an actual value, variable, object or reference passed to the function when it is called. Arguments are the specific data supplied to the function's parameters.","title":"Arguments"},{"location":"CPPPerface/#expressions","text":"","title":"Expressions"},{"location":"CPPPerface/#explanation_6","text":"An expression is any valid combination of variables, literals, operators, or function calls that evaluates to a value . Expressions are the building blocks of C++ programs and can range from simple values like 42 to complex operations involving multiple variables and function calls. They are evaluated at runtime to produce a result, which may or may not be used further in the program.","title":"Explanation"},{"location":"CPPPerface/#types-of-expressions-in-c","text":"Literal expressions A literal (such as 42 , a , or 3.14 ) is the simplest form of an expression. It evaluates to its own value. Variable expressions A variable by itself is also an expression, and it evaluates to the value it stores. For example, CPP int x = 10; x; // Evaluates to 10. Arithmetic expressions These use arithmetic operators ( + , - , * , / , % ) to produce numeric results. For example, CPP int y = 5 + 3 * 2; // Evaluates to 11. Logical and relational expressions Logical expressions ( && , || , ! ) produce a boolean result. Relational expressions ( == , != , < , > , <= , >= ) compare values and return true or false. For example, CPP bool result = (x > && (y < 10); // Evaluates to true. Assignment expressions An assignment operation is also an expression that returns the assigned value. For example, CPP int z; z = 20; // Evaluates to 20. Function call expressions A function call acts as an expression, with the result being the return value of the function. For example, CPP int absValue = std::abs( -5 ); // Evaluates to 5. Conditional (ternary) expressions A ternary expression evaluates a condition and returns one of two values based on the result. For example, CPP int max = (x > y) ? x : y; // Returns x if x > y, otherwise y. Member access expressions Accessing a member of an object or a struct is also an expression. For example, CPP struct Point { int x, y; }; Point p = {3, 4}; p.x; // Evaluates to 3. Pointer expressions Dereferencing a pointer or using the & operator to take the address of a variable forms an expression. For example, CPP int* ptr = &x; // Evaluates to the address of x. *ptr; // Evaluates to the value of x (10).","title":"Types of Expressions in C++"},{"location":"CPPPerface/#lvalues-and-rvalues-value-categories-in-c","text":"","title":"Lvalues and Rvalues: Value Categories in C++"},{"location":"CPPPerface/#lvalues-left-values","text":"A lvalue refers to an object or memory location that persists beyond a single expression and occupies some identifiable location in memory (i.e., it has an address). It can appear on the left side or the right side of an assignment Typically , it refers to variables , array elements , or dereferenced pointers . It can take the address of an lvalue using the address-of operator ( & ).","title":"Lvalues (Left Values)"},{"location":"CPPPerface/#rvalues-right-values","text":"An rvalue refers to temporary objects or values that do not persist beyond the expression in which they are used. An rvalue does not have a specific memory address , meaning it cannot be assigned a memory location. It cannot appear on the left-hand side of an assignment. Its examples include literals , temporary results of expressions, and return values of functions without & .","title":"Rvalues (Right Values)"},{"location":"CPPPerface/#lvalue-references-type","text":"","title":"Lvalue References (Type&amp;)"},{"location":"CPPPerface/#explanation_7","text":"An lvalue reference is a reference to a persistent object (i.e., an object with a well-defined memory address, such as variables or class members). It binds only to lvalues \u2014 objects that can appear on the left side of an assignment. However, a const lvalue reference can bind to a literal value .","title":"Explanation"},{"location":"CPPPerface/#usage","text":"Modify the value of an existing object. Pass objects by reference to functions, avoiding unnecessary copying .","title":"Usage"},{"location":"CPPPerface/#notes","text":"A normal reference can't store an rvalue but a const reference can . A normal reference parameter of a function can't accept an rvalue but a const reference parameter can .","title":"Notes"},{"location":"CPPPerface/#how-to-identify-whether-a-value-is-an-lvalue-or-an-rvalue","text":"Define a normal reference for a value, if it can be store by a reference, it is an lvalur. Otherwise, it is an rvalue.","title":"How to Identify Whether a Value is an Lvalue or an Rvalue"},{"location":"CPPPerface/#rvalue-references-type","text":"","title":"Rvalue References (Type&amp;&amp;)"},{"location":"CPPPerface/#explanation_8","text":"An rvalue reference is a reference to a temporary object (an rvalue) that is about to expire. It can bind only to rvalues , such as the result of expressions or moved objects (e.g., via std::move ). This makes rvalue references ideal for move semantics , allowing efficient transfer of resources. However, for primitive types , using std::move does not provide any meaningful advantage, as it behaves much like a copy . This is primarily because primitive types do not have complex resource management like objects that own dynamic memory. When an rvalue reference is named (i.e., bound to a variable), the compiler treats it as an lvalue . Rvalue references are a way for the compiler to distinguish between lvalues (objects that have a name and can be assigned to) and rvalues (temporary objects that are about to go out of scope). However, just accepting an rvalue reference in a function does not automatically mean that the object will be moved . Rvalue reference simply indicates that the function can accept an rvalue (temporary object). std::move is the mechanism used to cast an lvalue into an rvalue, signaling that you want to move the object instead of copying it. Even when a function receives arguments as rvalue references (i.e., when they are passed as Type&& ), you still need to use std::move explicitly to transfer ownership of these arguments to other objects.","title":"Explanation"},{"location":"CPPPerface/#usage_1","text":"Implement move constructors and move assignment operators to avoid unnecessary copying . Optimize performance by transferring resources from one object to another.","title":"Usage"},{"location":"CPPPerface/#move-semantics","text":"","title":"Move Semantics"},{"location":"CPPPerface/#explanation_9","text":"Move semantics, introduced in C++11, optimizes program performance by transferring resources from one object to another instead of copying them. It uses rvalue references ( Type&& ) to efficiently move resources, such as dynamically allocated memory, from temporary or \"expired\" objects without incurring the overhead of deep copies . Essentially, move semantics functions like assigning one pointer to another . Rather than copying data, ownership of the resources is transferred between objects, reducing unnecessary copying and enhancing performance .","title":"Explanation"},{"location":"CPPPerface/#usage_2","text":"Rvalue references ( Type&& ) bind to temporary or \"soon-to-expire\" objects . These references allow you to move resources , leaving the original object in a valid but empty state. The compiler may optimize your code when you use move semantics in move constructors , move assignment operators , and when returning objects by value .","title":"Usage"},{"location":"CPPPerface/#stdmove","text":"","title":"std::move"},{"location":"CPPPerface/#explanation_10","text":"A utility function that casts an object to an rvalue reference , enabling move semantics . It does not perform any movement itself but indicates that the object can be moved. For all primitive-type variables including poiners and references, it does nothing, only copys them directly. It only tells the compiler to treat an object as an rvalue reference . Even when a function receives arguments as rvalue references (i.e., when they are passed as Type&& ), you still need to use std::move explicitly to transfer ownership of these arguments to other objects.","title":"Explanation"},{"location":"CPPPerface/#usage_3","text":"Everytime, if you want to assign an object that you want to remove after assigning to a variable, you can use std::move . To deal with double deletion , the original pointer should point a nullptr after std::move moved its data to another pointer.","title":"Usage"},{"location":"CPPPerface/#interface","text":"In C++, the term \"interface\" does not have a formal definition like it does in some other programming languages (like Java). However, in C++, an interface is generally understood to be a class that defines a set of pure virtual functions , which means that it declares functions that must be implemented by derived classes but does not provide any implementation of its own . It only contains pure virtual functions .","title":"Interface"},{"location":"CPPPerface/#keyword","text":"A keyword is a reserved word that has a predefined meaning in the language and cannot be used as an identifier (such as a variable name, function name, etc.). Keywords are part of the C++ syntax and represent fundamental constructs or operations in the language.","title":"Keyword"},{"location":"CPPPerface/#type-specifier","text":"A type specifier is used to define the type of a variable, function return value, or object . Type specifiers tell the compiler what kind of data the variable will hold or the function will return. They are an essential part of variable declarations and type definitions.","title":"Type Specifier"},{"location":"CPPPerface/#segmentation-fault-linux-and-access-violation-win","text":"Access nullptr, for example, Type *ptr = nullptr; (*ptr) = val; . Access protected addredd, for example, Type *ptr = 0; (*ptr) = val; . Modify read-only memory, for example, const Type var_name = val1; var_name = val2; . Stack overflow, infinite loop. Multiple destruction or multiple deletion.","title":"Segmentation Fault (Linux) and Access Violation (Win)"},{"location":"CPPPerface/#notes_1","text":"C++: performance, memory, optimization, safe or not; scope ({})( where we can access the function/object/... ) and lifetime; make code clearer.","title":"Notes"},{"location":"CharsAndStrings/","text":"Chars and Strings Chars ( char ) Explanation Syntax Char Types Raw Strings ( char Arrays ) Explanation Syntax std::string Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links Template Parameters Member Types Member Functions Constants Non-member Functions Numeric Conversions Literals Helper Classes String Types in STL Small String optimization How to Make Strings Faster in C++ (C++17) std::string_view Explanation Syntax Member Functions Links Template Parameters Member Types Member Functions Constants Non-member Functions Literals Helper Classes Helper Templates std::literals Namespace Notes Chars and Strings Chars ( char ) Explanation A char is a fundamental data type in C++ that stores a single character. It can represent letters, digits, punctuation, and other symbols. The value is enclosed in single quotes ( ' ) . The size of a char is typically one byte , allowing for 256 different values (0 to 255), which correspond to the ASCII character set . 'a letter' : A char literal, a char type value. Syntax char var_name = 'a letter'; char var_name; var_name = 'a letter'; Char Types char , wchar_t , char16_t , and others represent different character types in C++. While they all store character data, there are notable differences in their size and intended use . Raw Strings ( char Arrays ) Explanation A raw string or a character array is a sequence of characters terminated by a null character ( '\\0' ). This means there is a termination character called null ( zero value ) at the end of a string-type variable by default, which indicates where the end of the string is. The value is enclosed in double quotes ( \" ) and the size of the string is determined by the number of characters plus one for the null terminator. \"a string\" : A string literal, a const char array. A string literal is stored in the read-only section of memory. However, if it is used to initialize a non-const char array , its contents will be copied to the array , which can then be modified like any other array . When single quotes or memcpy are used to assign or copy values to a char array or a char pointer, '\\0' or 0 should be explicitly included at the end. A char array is a type of array , meaning that all syntax applicable to arrays is also suitable for char arrays . Syntax // Implicit conversion occurs, \"a string\" is a `const char` array. char var_name[] = \"a string\"; char var_name[letter_count + 1] = \"a string\"; // `'\\0'` or `0` should be explicitly included at the end. char var_name[] = { 'a letter', 'a letter', ..., '\\0' }; // `'\\0'` or `0` should be explicitly included at the end. char var_name[letter_count + 1] = { 'a letter', 'a letter', ..., '\\0' }; char var_name[] = \"a string\"; // Allowed, a non-const `char` pointer points to a non-const `char` array. char* var_ptr = var_name; // A string literal is a `const char` array. When using a pointer to reference it, use a `const char` pointer. const char* var_ptr = \"a string\"; // char* var_ptr = \"a string\"; // Not allowed, an undefined operation. char var_name = var_ptr[index]; std::string Explanation std::string is a class in the C++ STL that represents a sequence of characters . It has several features, including the following: Dynamic sizing : std::string can grow and shrink in size automatically, allowing for easy modifications without the need for manual memory management. Memory management : It handles memory allocation and deallocation internally, reducing the risk of memory leaks and buffer overflows. Null-termination : Unlike C-style strings, which require a null terminator to indicate the end of the string, std::string manages this internally . Compatibility : It can easily be converted to and from C-style strings using the c_str() member function. The std::string type is safer than the char pointer or the char array, but slower than the latter. Declaration Syntax std::string var_name; Initialization Syntax // Direct initialization. std::string var_name = \"a string\"; // Constructor initialization. std::string var_name( \"a string\" ); // Initializer list constructor. std::string var_name{ 'letter1', 'letter2', ... }; // Concatenation. std::string var_name = std::string( \"a string\" ) + \"another string\"; // += has been overloaded in std::string type. var_name += \"...\"; // Allowed. // Error: a string literal is a `const char` array. Two arrays cannot be concatenated without overloading the `+` operator. // std::string var_name = \"a string\" + \"another string\"; // Not allowed. // Initializer list constructor. std::string var_name1{ 'letter1', 'letter2', ... }; // Copy constructor. std::string var_name2( var_name1 ); // Initializer list constructor. std::string var_name1{ 'letter1', 'letter2', ... }; // Move constructor. std::string var_name2( std::move( var_name1 ) ); // Initializer list constructor. std::string var_name1{ 'letter1', 'letter2', ... }; // Constructs the string with the contents of the range `[first, last)`. std::string var_name2( var_name1.begin(), var_name1.end() ); char ch = 'a letter'; // Constructs the string with `count` copies of character `ch`. std::string var_name( count, ch ); char* ch_ptr = \"a string\"; // Constructs the string with the first `count` characters of character string pointed to by `ch`. std::string var_name( ch_ptr, count ); Members and Related Stuffs Links std::string in cplusplus . std::string in cppreference . Template Parameters CharT : Character type. Traits : Traits class specifying the operations on the character type. Allocator : Allocator type used to allocate internal storage. Member Types traits_type : Traits . value_type : CharT . allocator_type : Allocator . size_type : Allocator::size_type (until C++11), std::allocator_traits< Allocator >::size_type (since C++11). difference_type : Allocator::difference_type (until C++11), std::allocator_traits< Allocator >::difference_type (since C++11). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20). const_iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20). reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Functions (constructor): Constructs a basic_string (public member function). (destructor): Destroys the string, deallocating internal storage if used (public member function). operator= : Assigns values to the string (public member function). assign : Assign characters to a string (public member function). assign_range (C++23): Assign a range of characters to a string (public member function). get_allocator : Returns the associated allocator (public member function). at : Accesses the specified character with bounds checking (public member function). operator[] : Accesses the specified character (public member function). front ( DR* ): Accesses the first character (public member function). back ( DR* ): Accesses the last character (public member function). data : Returns a pointer to the first character of a string (public member function). c_str : Returns a non-modifiable standard C character array version of the string (public member function). operator basic_string_view (C++17): Returns a non-modifiable string_view into the entire string (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the string is empty (public member function). size , length : Returns the number of characters (public member function). max_size : Returns the maximum number of characters (public member function). reserve : Reserves storage (public member function). capacity : Returns the number of characters that can be held in currently allocated storage (public member function). shrink_to_fit ( DR* ): Reduces memory usage by freeing unused memory (public member function). clear : Clears the contents (public member function). insert : Inserts characters (public member function). insert_range (C++23): Inserts a range of characters (public member function). erase : Removes characters and returns a valid iterator (public member function). push_back : Appends a character to the end (public member function). pop_back ( DR* ): Removes the last character (public member function). append : Appends characters to the end (public member function). append_range (C++23): Appends a range of characters to the end (public member function). operator+= : Appends characters to the end (public member function). replace : Replaces specified portion of a string (public member function). replace_with_range (C++23): Replaces specified portion of a string with a range of characters (public member function). copy : Copies characters (public member function). resize : Changes the number of characters stored (public member function). resize_and_overwrite (C++23): Changes the number of characters stored and possibly overwrites indeterminate contents via user-provided operation (public member function). swap : Swaps the contents (public member function). find : Finds the first occurrence of the given substring (public member function). rfind : Find the last occurrence of a substring (public member function). find_first_of : Find first occurrence of characters (public member function). find_first_not_of : Find first absence of characters (public member function). find_last_of : Find last occurrence of characters (public member function). find_last_not_of : Find last absence of characters (public member function). compare : Compares two strings (public member function). starts_with (C++20): Checks if the string starts with the given prefix (public member function). ends_with (C++20): Checks if the string ends with the given suffix (public member function). contains (C++23): Checks if the string contains the given substring or character (public member function). substr : Returns a substring (public member function). Constants npos [ static ]: Special value. The exact meaning depends on the context (public static member constant). Non-member Functions operator+ : Concatenates two strings, a string and a char , or a string and string_view (function template). operator==/!=//<=/>= (removed in C++20), operator<=> (C++20): Lexicographically compares two strings (function template). std::swap( std::string ) : Specializes the std::swap algorithm (function template). erase( std::string ) , erase_if( std::string ) (C++20): Erases all elements satisfying specific criteria (function template). operator<< , operator>> : Performs stream input and output on strings (function template). getline : Read data from an I/O stream into a string (function template). Numeric Conversions stoi , stol , stoll : Converts a string to a signed integer (function). stoul , stoull : Converts a string to an unsigned integer (function). stof , stod , stold : Converts a string to a floating point value (function). to_string : Converts an integral or floating-point value to string (function). to_wstring : Converts an integral or floating-point value to wstring (function). Literals Defined in inline namespace std::literals::string_literals . operator\"\"s (C++14): Converts a character array literal to basic_string (function). Helper Classes std::hash< std::string > : Hash support for strings (class template specialization). String Types in STL std::string , std::wstring , std::u32string and others represent different string types in C++. While they all store character sequences, there are notable differences in character encoding , size of characters , and intended use . Small String optimization C++ STL stores a string with a small size depending on how to implement the standard library, usually which is smaller than 16 characters , on stack . Otherwise , it stores a string on heap . Therefore, if the string is small enough , we define it as a std::string type instad of const char pointer type. However, if the code compiled in debug mode , even the string is small enough , it still causes a head allocation . How to Make Strings Faster in C++ (C++17) Use std::string_view to get a substring of a std::string , instead of std::string::substr() . Use const char pointer to store a string , instead of std::string . std::string requires one memory allocation, while const char pointer does not. When a const char pointer is passed to a function whose argument is a const std::string reference , one memory allocation occurs. However, if the argument of the function is changed from a const std::string reference to a std::string_view , no memory allocation occurs. Every time, a char pointer or a char array is converted into a std::string implicitly , although the argument of the function is a std::string reference , one memory allocation occurs . std::string_view Explanation std::string_view is a lightweight, non-owning reference to a sequence of characters in C++. It provides a way to efficiently work with strings without copying them, making it particularly useful for accessing substrings or interfacing with C-style strings . Since it does not manage the memory it points to, users must ensure that the referenced data remains valid for the duration of the string_view . This class allows for read-only access to character sequences, improving performance in scenarios where string immutability is required. Syntax // Direct initialization. std::string_view var_name = \"a string\"; // Constructor initialization. std::string_view var_name( \"a string\" ); // Initializer list constructor. std::string_view var_name{ 'letter1', 'letter2', ... }; // Initializer list constructor. std::string str = { 'letter1', 'letter2', ... }; // Constructs a `std::string_view` over the range `[first, last)`. std::string_view var_name( str.begin(), str.end() ); char* ch_ptr = \"a string\"; // Constructs the `std::string_view` with the first `count` characters of character string pointed to by `ch`. std::string_view var_name( ch_ptr, count ); Member Functions Links std::string_view in cplusplus . std::string_view in cppreference . Template Parameters CharT : Character type. Traits : CharTraits class specifying the operations on the character type. Like for std::string , Traits::char_type must name the same type as CharT or the program is ill-formed. Member Types traits_type : Traits . value_type : CharT . pointer : CharT* . const_pointer : const CharT* . reference : CharT& . const_reference : const CharT& . const_iterator : Implementation-defined constant LegacyRandomAccessIterator , and LegacyContiguousIterator (until C++20), ConstexprIterator , and contiguous_iterator (since C++20) whose value_type is CharT . iterator : const_iterator . const_reverse_iterator : std::reverse_iterator< const_iterator > . reverse_iterator : const_reverse_iterator . size_type : std::size_t . difference_type : std::ptrdiff_t . Notes: iterator and const_iterator are the same type because string views are views into constant character sequences. All requirements on the iterator types of a Container applies to the iterator and const_iterator types of basic_string_view as well. Member Functions (constructor): Constructs a std::string_view (public member function). operator= : Assigns a view (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). operator[] : Accesses the specified character (public member function). at : Accesses the specified character with bounds checking (public member function). front : Accesses the first character (public member function). back : Accesses the last character (public member function). data : Returns a pointer to the first character of a view (public member function). size , length : Returns the number of characters (public member function). max_size : Returns the maximum number of characters (public member function). empty : Checks whether the view is empty (public member function). remove_prefix : Shrinks the view by moving its start forward (public member function). remove_suffix : Shrinks the view by moving its end backward (public member function). swap : Swaps the contents (public member function). copy : Copies characters (public member function). substr : Returns a substring (public member function). compare : Compares two views (public member function). starts_with (C++20): Checks if the string view starts with the given prefix (public member function). ends_with (C++20): Checks if the string view ends with the given suffix (public member function). contains (C++23): Checks if the string view contains the given substring or character (public member function). find : Find characters in the view (public member function). rfind : Find the last occurrence of a substring (public member function). find_first_of : Find first occurrence of characters (public member function). find_last_of : Find last occurrence of characters (public member function). find_first_not_of : Find first absence of characters (public member function). find_last_not_of : Find last absence of characters (public member function). Constants npos [ static ]: Special value. The exact meaning depends on the context (public static member constant). Non-member Functions operator== (C++17), operator!=//<=/>= (removed in C++20), operator<=> (C++20): Lexicographically compares two string views (function template). operator<< (C++17): Performs stream output on string views (function template). Literals Defined in inline namespace std::literals::string_view_literals . operator\"\"sv (C++17): Creates a string view of a character array literal (function). Helper Classes std::hash< std::string_view > (C++17), std::hash< std::wstring_view > (C++17), std::hash< std::u8string_view > (C++20), std::hash< std::u16string_view > (C++17), std::hash< std::u32string_view > (C++17): Hash support for string views (class template specialization). Helper Templates template< class CharT, class Traits > inline constexpr bool ranges::enable_borrowed_range< std::string_view< CharT, Traits > > = true; (since C++20): This specialization of ranges::enable_borrowed_range makes basic_string_view satisfy borrowed_range . template< class CharT, class Traits > inline constexpr bool ranges::enable_view< std::string_view < CharT, Traits > > = true; (since C++20): This specialization of ranges::enable_view makes basic_string_view satisfy view. std::literals Namespace std::literals in cplusplus . std::literals in cppreference . Notes The strings stored in const char arrays, const char pointers, and char pointers cannot be modified. It is not recommended to store a string in a char pointer. Only strings stored in char arrays or std::string can be modified.","title":"Chars and Strings"},{"location":"CharsAndStrings/#chars-and-strings","text":"","title":"Chars and Strings"},{"location":"CharsAndStrings/#chars-char","text":"","title":"Chars (char)"},{"location":"CharsAndStrings/#explanation","text":"A char is a fundamental data type in C++ that stores a single character. It can represent letters, digits, punctuation, and other symbols. The value is enclosed in single quotes ( ' ) . The size of a char is typically one byte , allowing for 256 different values (0 to 255), which correspond to the ASCII character set . 'a letter' : A char literal, a char type value.","title":"Explanation"},{"location":"CharsAndStrings/#syntax","text":"char var_name = 'a letter'; char var_name; var_name = 'a letter';","title":"Syntax"},{"location":"CharsAndStrings/#char-types","text":"char , wchar_t , char16_t , and others represent different character types in C++. While they all store character data, there are notable differences in their size and intended use .","title":"Char Types"},{"location":"CharsAndStrings/#raw-strings-char-arrays","text":"","title":"Raw Strings (char Arrays)"},{"location":"CharsAndStrings/#explanation_1","text":"A raw string or a character array is a sequence of characters terminated by a null character ( '\\0' ). This means there is a termination character called null ( zero value ) at the end of a string-type variable by default, which indicates where the end of the string is. The value is enclosed in double quotes ( \" ) and the size of the string is determined by the number of characters plus one for the null terminator. \"a string\" : A string literal, a const char array. A string literal is stored in the read-only section of memory. However, if it is used to initialize a non-const char array , its contents will be copied to the array , which can then be modified like any other array . When single quotes or memcpy are used to assign or copy values to a char array or a char pointer, '\\0' or 0 should be explicitly included at the end. A char array is a type of array , meaning that all syntax applicable to arrays is also suitable for char arrays .","title":"Explanation"},{"location":"CharsAndStrings/#syntax_1","text":"// Implicit conversion occurs, \"a string\" is a `const char` array. char var_name[] = \"a string\"; char var_name[letter_count + 1] = \"a string\"; // `'\\0'` or `0` should be explicitly included at the end. char var_name[] = { 'a letter', 'a letter', ..., '\\0' }; // `'\\0'` or `0` should be explicitly included at the end. char var_name[letter_count + 1] = { 'a letter', 'a letter', ..., '\\0' }; char var_name[] = \"a string\"; // Allowed, a non-const `char` pointer points to a non-const `char` array. char* var_ptr = var_name; // A string literal is a `const char` array. When using a pointer to reference it, use a `const char` pointer. const char* var_ptr = \"a string\"; // char* var_ptr = \"a string\"; // Not allowed, an undefined operation. char var_name = var_ptr[index];","title":"Syntax"},{"location":"CharsAndStrings/#stdstring","text":"","title":"std::string"},{"location":"CharsAndStrings/#explanation_2","text":"std::string is a class in the C++ STL that represents a sequence of characters . It has several features, including the following: Dynamic sizing : std::string can grow and shrink in size automatically, allowing for easy modifications without the need for manual memory management. Memory management : It handles memory allocation and deallocation internally, reducing the risk of memory leaks and buffer overflows. Null-termination : Unlike C-style strings, which require a null terminator to indicate the end of the string, std::string manages this internally . Compatibility : It can easily be converted to and from C-style strings using the c_str() member function. The std::string type is safer than the char pointer or the char array, but slower than the latter.","title":"Explanation"},{"location":"CharsAndStrings/#declaration-syntax","text":"std::string var_name;","title":"Declaration Syntax"},{"location":"CharsAndStrings/#initialization-syntax","text":"// Direct initialization. std::string var_name = \"a string\"; // Constructor initialization. std::string var_name( \"a string\" ); // Initializer list constructor. std::string var_name{ 'letter1', 'letter2', ... }; // Concatenation. std::string var_name = std::string( \"a string\" ) + \"another string\"; // += has been overloaded in std::string type. var_name += \"...\"; // Allowed. // Error: a string literal is a `const char` array. Two arrays cannot be concatenated without overloading the `+` operator. // std::string var_name = \"a string\" + \"another string\"; // Not allowed. // Initializer list constructor. std::string var_name1{ 'letter1', 'letter2', ... }; // Copy constructor. std::string var_name2( var_name1 ); // Initializer list constructor. std::string var_name1{ 'letter1', 'letter2', ... }; // Move constructor. std::string var_name2( std::move( var_name1 ) ); // Initializer list constructor. std::string var_name1{ 'letter1', 'letter2', ... }; // Constructs the string with the contents of the range `[first, last)`. std::string var_name2( var_name1.begin(), var_name1.end() ); char ch = 'a letter'; // Constructs the string with `count` copies of character `ch`. std::string var_name( count, ch ); char* ch_ptr = \"a string\"; // Constructs the string with the first `count` characters of character string pointed to by `ch`. std::string var_name( ch_ptr, count );","title":"Initialization Syntax"},{"location":"CharsAndStrings/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"CharsAndStrings/#links","text":"std::string in cplusplus . std::string in cppreference .","title":"Links"},{"location":"CharsAndStrings/#template-parameters","text":"CharT : Character type. Traits : Traits class specifying the operations on the character type. Allocator : Allocator type used to allocate internal storage.","title":"Template Parameters"},{"location":"CharsAndStrings/#member-types","text":"traits_type : Traits . value_type : CharT . allocator_type : Allocator . size_type : Allocator::size_type (until C++11), std::allocator_traits< Allocator >::size_type (since C++11). difference_type : Allocator::difference_type (until C++11), std::allocator_traits< Allocator >::difference_type (since C++11). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20). const_iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20). reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"CharsAndStrings/#member-functions","text":"(constructor): Constructs a basic_string (public member function). (destructor): Destroys the string, deallocating internal storage if used (public member function). operator= : Assigns values to the string (public member function). assign : Assign characters to a string (public member function). assign_range (C++23): Assign a range of characters to a string (public member function). get_allocator : Returns the associated allocator (public member function). at : Accesses the specified character with bounds checking (public member function). operator[] : Accesses the specified character (public member function). front ( DR* ): Accesses the first character (public member function). back ( DR* ): Accesses the last character (public member function). data : Returns a pointer to the first character of a string (public member function). c_str : Returns a non-modifiable standard C character array version of the string (public member function). operator basic_string_view (C++17): Returns a non-modifiable string_view into the entire string (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the string is empty (public member function). size , length : Returns the number of characters (public member function). max_size : Returns the maximum number of characters (public member function). reserve : Reserves storage (public member function). capacity : Returns the number of characters that can be held in currently allocated storage (public member function). shrink_to_fit ( DR* ): Reduces memory usage by freeing unused memory (public member function). clear : Clears the contents (public member function). insert : Inserts characters (public member function). insert_range (C++23): Inserts a range of characters (public member function). erase : Removes characters and returns a valid iterator (public member function). push_back : Appends a character to the end (public member function). pop_back ( DR* ): Removes the last character (public member function). append : Appends characters to the end (public member function). append_range (C++23): Appends a range of characters to the end (public member function). operator+= : Appends characters to the end (public member function). replace : Replaces specified portion of a string (public member function). replace_with_range (C++23): Replaces specified portion of a string with a range of characters (public member function). copy : Copies characters (public member function). resize : Changes the number of characters stored (public member function). resize_and_overwrite (C++23): Changes the number of characters stored and possibly overwrites indeterminate contents via user-provided operation (public member function). swap : Swaps the contents (public member function). find : Finds the first occurrence of the given substring (public member function). rfind : Find the last occurrence of a substring (public member function). find_first_of : Find first occurrence of characters (public member function). find_first_not_of : Find first absence of characters (public member function). find_last_of : Find last occurrence of characters (public member function). find_last_not_of : Find last absence of characters (public member function). compare : Compares two strings (public member function). starts_with (C++20): Checks if the string starts with the given prefix (public member function). ends_with (C++20): Checks if the string ends with the given suffix (public member function). contains (C++23): Checks if the string contains the given substring or character (public member function). substr : Returns a substring (public member function).","title":"Member Functions"},{"location":"CharsAndStrings/#constants","text":"npos [ static ]: Special value. The exact meaning depends on the context (public static member constant).","title":"Constants"},{"location":"CharsAndStrings/#non-member-functions","text":"operator+ : Concatenates two strings, a string and a char , or a string and string_view (function template). operator==/!=//<=/>= (removed in C++20), operator<=> (C++20): Lexicographically compares two strings (function template). std::swap( std::string ) : Specializes the std::swap algorithm (function template). erase( std::string ) , erase_if( std::string ) (C++20): Erases all elements satisfying specific criteria (function template). operator<< , operator>> : Performs stream input and output on strings (function template). getline : Read data from an I/O stream into a string (function template).","title":"Non-member Functions"},{"location":"CharsAndStrings/#numeric-conversions","text":"stoi , stol , stoll : Converts a string to a signed integer (function). stoul , stoull : Converts a string to an unsigned integer (function). stof , stod , stold : Converts a string to a floating point value (function). to_string : Converts an integral or floating-point value to string (function). to_wstring : Converts an integral or floating-point value to wstring (function).","title":"Numeric Conversions"},{"location":"CharsAndStrings/#literals","text":"Defined in inline namespace std::literals::string_literals . operator\"\"s (C++14): Converts a character array literal to basic_string (function).","title":"Literals"},{"location":"CharsAndStrings/#helper-classes","text":"std::hash< std::string > : Hash support for strings (class template specialization).","title":"Helper Classes"},{"location":"CharsAndStrings/#string-types-in-stl","text":"std::string , std::wstring , std::u32string and others represent different string types in C++. While they all store character sequences, there are notable differences in character encoding , size of characters , and intended use .","title":"String Types in STL"},{"location":"CharsAndStrings/#small-string-optimization","text":"C++ STL stores a string with a small size depending on how to implement the standard library, usually which is smaller than 16 characters , on stack . Otherwise , it stores a string on heap . Therefore, if the string is small enough , we define it as a std::string type instad of const char pointer type. However, if the code compiled in debug mode , even the string is small enough , it still causes a head allocation .","title":"Small String optimization"},{"location":"CharsAndStrings/#how-to-make-strings-faster-in-c-c17","text":"Use std::string_view to get a substring of a std::string , instead of std::string::substr() . Use const char pointer to store a string , instead of std::string . std::string requires one memory allocation, while const char pointer does not. When a const char pointer is passed to a function whose argument is a const std::string reference , one memory allocation occurs. However, if the argument of the function is changed from a const std::string reference to a std::string_view , no memory allocation occurs. Every time, a char pointer or a char array is converted into a std::string implicitly , although the argument of the function is a std::string reference , one memory allocation occurs .","title":"How to Make Strings Faster in C++ (C++17)"},{"location":"CharsAndStrings/#stdstring_view","text":"","title":"std::string_view"},{"location":"CharsAndStrings/#explanation_3","text":"std::string_view is a lightweight, non-owning reference to a sequence of characters in C++. It provides a way to efficiently work with strings without copying them, making it particularly useful for accessing substrings or interfacing with C-style strings . Since it does not manage the memory it points to, users must ensure that the referenced data remains valid for the duration of the string_view . This class allows for read-only access to character sequences, improving performance in scenarios where string immutability is required.","title":"Explanation"},{"location":"CharsAndStrings/#syntax_2","text":"// Direct initialization. std::string_view var_name = \"a string\"; // Constructor initialization. std::string_view var_name( \"a string\" ); // Initializer list constructor. std::string_view var_name{ 'letter1', 'letter2', ... }; // Initializer list constructor. std::string str = { 'letter1', 'letter2', ... }; // Constructs a `std::string_view` over the range `[first, last)`. std::string_view var_name( str.begin(), str.end() ); char* ch_ptr = \"a string\"; // Constructs the `std::string_view` with the first `count` characters of character string pointed to by `ch`. std::string_view var_name( ch_ptr, count );","title":"Syntax"},{"location":"CharsAndStrings/#member-functions_1","text":"","title":"Member Functions"},{"location":"CharsAndStrings/#links_1","text":"std::string_view in cplusplus . std::string_view in cppreference .","title":"Links"},{"location":"CharsAndStrings/#template-parameters_1","text":"CharT : Character type. Traits : CharTraits class specifying the operations on the character type. Like for std::string , Traits::char_type must name the same type as CharT or the program is ill-formed.","title":"Template Parameters"},{"location":"CharsAndStrings/#member-types_1","text":"traits_type : Traits . value_type : CharT . pointer : CharT* . const_pointer : const CharT* . reference : CharT& . const_reference : const CharT& . const_iterator : Implementation-defined constant LegacyRandomAccessIterator , and LegacyContiguousIterator (until C++20), ConstexprIterator , and contiguous_iterator (since C++20) whose value_type is CharT . iterator : const_iterator . const_reverse_iterator : std::reverse_iterator< const_iterator > . reverse_iterator : const_reverse_iterator . size_type : std::size_t . difference_type : std::ptrdiff_t . Notes: iterator and const_iterator are the same type because string views are views into constant character sequences. All requirements on the iterator types of a Container applies to the iterator and const_iterator types of basic_string_view as well.","title":"Member Types"},{"location":"CharsAndStrings/#member-functions_2","text":"(constructor): Constructs a std::string_view (public member function). operator= : Assigns a view (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). operator[] : Accesses the specified character (public member function). at : Accesses the specified character with bounds checking (public member function). front : Accesses the first character (public member function). back : Accesses the last character (public member function). data : Returns a pointer to the first character of a view (public member function). size , length : Returns the number of characters (public member function). max_size : Returns the maximum number of characters (public member function). empty : Checks whether the view is empty (public member function). remove_prefix : Shrinks the view by moving its start forward (public member function). remove_suffix : Shrinks the view by moving its end backward (public member function). swap : Swaps the contents (public member function). copy : Copies characters (public member function). substr : Returns a substring (public member function). compare : Compares two views (public member function). starts_with (C++20): Checks if the string view starts with the given prefix (public member function). ends_with (C++20): Checks if the string view ends with the given suffix (public member function). contains (C++23): Checks if the string view contains the given substring or character (public member function). find : Find characters in the view (public member function). rfind : Find the last occurrence of a substring (public member function). find_first_of : Find first occurrence of characters (public member function). find_last_of : Find last occurrence of characters (public member function). find_first_not_of : Find first absence of characters (public member function). find_last_not_of : Find last absence of characters (public member function).","title":"Member Functions"},{"location":"CharsAndStrings/#constants_1","text":"npos [ static ]: Special value. The exact meaning depends on the context (public static member constant).","title":"Constants"},{"location":"CharsAndStrings/#non-member-functions_1","text":"operator== (C++17), operator!=//<=/>= (removed in C++20), operator<=> (C++20): Lexicographically compares two string views (function template). operator<< (C++17): Performs stream output on string views (function template).","title":"Non-member Functions"},{"location":"CharsAndStrings/#literals_1","text":"Defined in inline namespace std::literals::string_view_literals . operator\"\"sv (C++17): Creates a string view of a character array literal (function).","title":"Literals"},{"location":"CharsAndStrings/#helper-classes_1","text":"std::hash< std::string_view > (C++17), std::hash< std::wstring_view > (C++17), std::hash< std::u8string_view > (C++20), std::hash< std::u16string_view > (C++17), std::hash< std::u32string_view > (C++17): Hash support for string views (class template specialization).","title":"Helper Classes"},{"location":"CharsAndStrings/#helper-templates","text":"template< class CharT, class Traits > inline constexpr bool ranges::enable_borrowed_range< std::string_view< CharT, Traits > > = true; (since C++20): This specialization of ranges::enable_borrowed_range makes basic_string_view satisfy borrowed_range . template< class CharT, class Traits > inline constexpr bool ranges::enable_view< std::string_view < CharT, Traits > > = true; (since C++20): This specialization of ranges::enable_view makes basic_string_view satisfy view.","title":"Helper Templates"},{"location":"CharsAndStrings/#stdliterals-namespace","text":"std::literals in cplusplus . std::literals in cppreference .","title":"std::literals Namespace"},{"location":"CharsAndStrings/#notes","text":"The strings stored in const char arrays, const char pointers, and char pointers cannot be modified. It is not recommended to store a string in a char pointer. Only strings stored in char arrays or std::string can be modified.","title":"Notes"},{"location":"Classes/","text":"Classes ( class ) Explanation Visibility Declaration Syntax Definition Syntax Common Objects Declaration Syntax Initialization Syntax Limitations of Aggregate Initialization Class Pointers Declaration Syntax Definition or Initialization Syntax Class References const Instance of Classes constexpr Instances of Classes static Instances of Classes Anonymous Classes Explanation Syntax Member Variables Explanation Syntax this Explanation Syntax const Member Variables constexpr Member Variables static Member Variables mutable Member Variables Explanation Syntax Pointer Member Variables Explanation Syntax Reference Member Variables Explanation Syntax Methods Explanation Syntax const Methods ( const Member Functions) constexpr Methods ( constexprt Member Functions) static Methods ( static Member Functions) virtual Methods ( virtual Functions) ( virtual Memeber Functions) Pure virtual Functions and Abstract Class override Methods Explanation Syntax Notes Constructors Explanation Syntax Defalut Constructors and default Constructors Explanation Syntax Parameterized Constructors Explanation Syntax Constructor Initializer Lists Explanation Syntax Notes Copy Constructors Explanation Default Copy ( default ) (Avoid) (Double Destructions) Explanation Syntax Shallow Copy (e.g. memcpy ) (Avoid) (Double Destructions) Explanation Syntax Deep Copy (Recommend) Explanation Syntax Move Constructors Explanation Default Move Constructors Explanation Syntax Custom Move Constructor Explanation Syntax Conversion Constructors Explanation Syntax virtual Constructors explicit Constructors Destructors Explanation Syntax Default Destructors Explanation Syntax virtual Destructors Operator Overloading Copy-assignment Operator Move-assignment Operator Conversion Operator explicit Conversion Operator How to Determine Which Constructor or Assignment Operator Is Invoked Inheritance Explanation Definition Syntax Code Categories Initialization Syntax Code Explanation Construction Order Destruction Order virtual Inheritance virtual Explanation virtual Methods ( virtual Functions) ( virtual Memeber Functions) Explanation Syntax Static Binding and Dynamic Binding Polymorphism and Problems Notes Pure virtual Functions and Abstract Class Explanation Syntax virtual Destructors Explanation Syntax Notes virtual Inheritance Explanation Definition Syntax Initialization Syntax Construction Order Destruction Order friend Explanation friend Functions Explanation Syntax friend Classes Explanation Syntax final Explanation final Functions Explanation Syntax final Classes Explanation Syntax explicit using Hiding, Overloading, Overriding, and Overwriting Notes Classes ( class ) Explanation A class is a user-defined type that serves as a blueprint for creating objects. It encapsulates data members (variables) and member functions (methods) that operate on these data. A class provides a way to group related behaviors and attributes into a cohesive unit, promoting data abstraction and encapsulation. A class helps enforce encapsulation by limiting access to internal details and exposing only the necessary functionalities, making code more modular, reusable , and easier to maintain . An empty object occupy at least one byte memory. Creating an object on the stack is faster than on the heap. Structures( Stored as the class ) + Functions( Stored outside of the class ) = Classes . Visibility The visibility makes code more readable, not affect the performance . private ( default visibility ): The owner class, friend class. protected : The owner class, friend class, sub-class. public : All. Declaration Syntax class ClassName; Definition Syntax class ClassName { ...; }; Common Objects Declaration Syntax ClassName obj_name; Initialization Syntax // Default constructor. ClassName obj_name; // Parameterized constructor. ClassName obj_name( para_list ); // Parameterized constructor. ClassName obj_name1( para_list ); // Copy constructor. ClassName obj_name2( obj_name1 ); // Not recommend, although the compiler may optimize it so that only one constructor is called. // First, parameterized constructor. // Second, copy constructor. ClassName obj_name = ClassName( para_list ); // Parameterized constructor. ClassName obj_name1( para_list ); // Move constructor. ClassName obj_name2( std::move( obj_name1 ) ); // Parameterized constructor. ClassName obj_name1( para_list ); // Move constructor. ClassName obj_name2 = std::move( obj_name1 ); // Conversion construcotr, implicit conversion. ClassName obj_name = initializer; // Without related parameterized constructors and all members are public, aggregate initialization. // With related parameterized constructors, parameterized constructor or uniform initialization or brace initialization. ClassName obj_name{ para_list }; // With default construcotr, default constructor. // Otherwise, aggregate initialization. // All members are initialized to 0. ClassName obj_name{ }; // Aggregate initialization. ClassName obj_name = { para_list }; // When defining a class, assigning default values to its members. class ClassName { private: Type _mem1 = initializer1; ...; }; class ClassName { public: // Move constructor definition. ...; // Factory methods for initialization. static ClassName createClassName() { return std::move( ClassName( para_list ); // Parameterized constructor. }; ...; }; // First, create a temporary object with the parameterized constructor in the createClassName. // Second, create `obj_name` with the move constructor. ClassName obj_name = ClassName::createClassName(); Limitations of Aggregate Initialization No user-defined constructors : Aggregate initialization is only applicable to aggregate types that lack user-defined constructors. If a class has any constructor defined, aggregate initialization cannot be used. Public members only : Only public members can be initialized via aggregate initialization. Private or protected members cannot be accessed. No default member initializers : Default member initializers in aggregates are ignored during aggregate initialization, meaning you must explicitly specify values for all members. Order of initialization : Members are initialized in the order they are declared. This can lead to issues if one member relies on another being initialized first. No designated initializers : C++ does not support designated initializers (as in C99), preventing the ability to initialize specific members without initializing all preceding members. Type matching : The types in the initializer list must match the types of the aggregate's members exactly. A mismatch results in a compilation error. No implicit conversions : Aggregate initialization does not allow implicit type conversions, which can limit flexibility. No inheritance : Aggregate initialization is not applicable for derived classes, limiting its use in inheritance scenarios. Class Pointers Declaration Syntax ClassName* obj_ptr; Definition or Initialization Syntax // Default constructor. ClassName* obj_ptr = new ClassName; // Parameterized constructor. ClassName* obj_ptr = new ClassName( para_list ); // Default constructor. ClassName obj_name; ClassName* obj_ptr = &obj_name; Class References // Default constructor. ClassName obj_name; ClassName& obj_ref = &obj_name; const Instance of Classes const Instance of Classes constexpr Instances of Classes constexpr Instances of Classes static Instances of Classes static Instances of Classes Anonymous Classes Explanation An anonymous class (also known as an unnamed class ) is a class that is defined inline without a name . These classes are typically used for creating objects on the fly or as part of data structures without the need to define a separate named class Syntax class { ...; } obj_name; union { class { ...; }; ...; }; // In this case, members should all be public. class { ...; } obj_name{ para_list }; Member Variables Explanation Member variables, also known as instance variables or fields , are attributes of a class that hold data specific to the instances (objects) of that class. They define the state of an object. Member variables can be assigned default values when they are defined . Syntax class ClassName { private: Type _mem; // Declaration or definition of a member variable. }; this Explanation this is a pointer available within a class's member function that points to the object that invoked the member function. It allows access to the calling object's members. this is implicitly passed to all non-static member functions . It can be useful for disambiguation when member variables and parameters have the same name. It is not available in static member functions as there is no associated object. Syntax this->_mem; // (*this)._mem; const Member Variables const Member Variables constexpr Member Variables constexpr Member Variables static Member Variables static Member Variables mutable Member Variables Explanation mutable member variables can be modified even in const member functions . This allows certain aspects of an object to change while keeping its overall state constant. Generally, they are used for caching or lazy evaluation purposes . They break the const-correctness for that particular member variable. In 90% of cases, the mutable keyword will be used in a class with the const keyword. Syntax class ClassName { private: mutable Type _mem; // Declaration or definition of a member variable. }; Pointer Member Variables Explanation Pointer member variables hold memory addresses of instances or other data types. They allow dynamic memory management and manipulation of resources. Syntax class ClassName { private: Type* _mem_ptr; // Declaration or definition of a member pointer. }; Reference Member Variables Explanation Reference member variables are alternatives to pointers that refer to existing objects . They cannot be reassigned once established. Theyt must be initialized when defined and cannot be null . There are only two ways to initialize a reference member: In-Class Initialization : It can be overridden by the constructor. Constructor Initialization . When initializing a reference member in a class, the reference must be bound to either another member variable of the class or an external variable passed as a reference during object construction. Syntax class ClassName { public: // Initialization through constructor explicit ClassName( Type& ref ): _memRef( ref ) {}; private: Type _mem; // In-Class Initialization Type& _memRef = _mem; }; Methods Explanation A method in C++ is a function that belongs to a class or struct. It is used to perform operations or manipulate the data members (attributes) of that class. Methods encapsulate behavior specific to an object of the class. Methods can be overloaded by defining multiple versions with different parameter types. Methods defined inside the class are automatically considered inline , improving performance by reducing function call overhead. Syntax // Declared and defined inside the class. class ClassName { public: RetType funcName( para_list ) { ... }; }; // Declared inside the class. class ClassName { public: RetType funcName( para_list ) { ... }; }; // Defined outside the class. RetType ClassName::funcName( para_list ) { ... }; const Methods ( const Member Functions) const Methods ( const Member Functions) constexpr Methods ( constexprt Member Functions) constexpr Functions ( constexpr Return Values) static Methods ( static Member Functions) static Methods ( static Member Functions) virtual Methods ( virtual Functions) ( virtual Memeber Functions) virtual Methods ( virtual Functions) ( virtual Memeber Functions) Pure virtual Functions and Abstract Class Pure virtual Functions and Abstract Class override Methods Explanation override is a keyword used to explicitly indicate that a method in a derived class is meant to override a virtual method in the base class . It ensures that the method signature in the derived class matches a virtual method in the base class. If the method signature does not match , the compiler will generate an error , which helps prevent subtle bugs caused by accidental method hiding. Syntax class Base { public: virtual RetType funcName( para_list ){ // `virtual` method in base class }; }; class Derived: public Base { public: RetType funcName( para_list ) override{ // Override the base class method }; }; Notes You should always use the override keyword when overriding functions in a derived class, as it helps prevent errors. Constructors Explanation Constructors are special member functions of a class that are automatically called when an object of that class is created . They are used to initialize the object's properties and set up any necessary resources. Syntax class ClassName { public: ClassName( para_list ){ }; }; Defalut Constructors and default Constructors Explanation A default constructor is a constructor with no parameters or with all parameters having default values . It is called when an object is instantiated without any arguments . It initializes data members to their default values ( primitive types remain uninitialized ). If no other constructors are defined, the compiler provides a default constructor. The non-customized default constructor will initialize all non-user-defined type members to their zero values . The = default syntax explicitly requests the compiler to generate the default constructor . Syntax class ClassName { public: // If no other constructors are defined, // this default constructor is provided by the compiler. ClassName(){}; }; class ClassName { public: // Default constructor. ClassName(){ ... }; }; class ClassName { public: // Default constructor. ClassName() = default; // Default constructor. // Parameterized constructor. ClassName( parameters with default values ){ }; }; Parameterized Constructors Explanation A parameterized constructor is a type of constructor in a class that allows you to initialize an object with specific values upon creation. Unlike a default constructor (which takes no arguments), a parameterized constructor accepts one or more arguments that enable you to set the initial state of an object with specific values. It is called when an object is instantiated with specific arguments . Syntax class ClassName { public: // Parameterized constructor. ClassName( para_list ){ }; }; Constructor Initializer Lists Explanation Constructor initializer lists are used to initialize member variables of a class in the constructor's initialization phase before the body of the constructor executes. Member variables are initialized in the order they are declared in the class, not the order they appear in the initializer list . Using initializer lists can be more efficient , as it allows direct initialization of the member variables, avoiding unnecessary default construction followed by assignment. An initializer list is required to initialize const and reference members , as they cannot be assigned after construction. If members are initialized in the constructor's body , those members are first default-initialized before being assigned, which can lead to additional overhead compared to direct initialization in the initializer list. Syntax class ClassName { public: ClassName( Type1 para1, Type2 para2, ... ): _mem1( para1 ), _mem2( para2 ), ...{}; private: Type1 _mem1; Type2 _mem2; ...; }; Notes In the constructor initializer list, you'd better initialize the members in the order in which they are defined in the class. If a class has a class or struct member , we should use the constructor initializer to initialize the class or struct member; otherwise , the initialization will call the object's constructors twice : first the default constructor, and then the other constructor. Copy Constructors Explanation A copy constructor is a special constructor that initializes a new object as a copy of an existing object . This is essential for managing resource ownership and ensuring that objects behave properly when passed, returned, or assigned. The parameter of a copy constructor and copy assignment operator should not be passed by value , as this can lead to issues. When passing the argument by value, the copy constructor will be called to create a temporary object for the parameter. This temporary object creation requires another call to the copy constructor, which leads to a recursive cycle. The cycle continues until the call stack overflows, causing a stack overflow error. In other words, passing by value in the copy constructor or copy assignment operator triggers an infinite loop , as each invocation requires another copy of the argument, which again invokes the copy constructor. Default Copy ( default ) (Avoid) (Double Destructions) Explanation A default copy constructor is automatically generated by the compiler if no user-defined copy constructor is present. It performs a shallow copy of the object's members. For primitive types, this is a straightforward copy, but for pointer members , both the original and copied objects will reference the same memory . This can lead to issues such as: Double destructions : When both objects are destroyed , they attempt to free the same memory location , resulting in undefined behavior . Dangling pointers : When one object is deleted , the other retains a pointer to the deallocated memory , leading to program crashes if accessed . The copy is performed quickly since it merely copies the pointer (for pointer types) rather than the pointed-to values. The default copy constructor is typically marked as noexcept , improving performance by ensuring compatibility with standard containers, such as std::vector . The = default syntax explicitly requests the compiler to generate the default copy constructor . Syntax class ClassName { public: // Compiler-generated default copy constructor. }; class ClassName { public: // Default copy constructor. ClassName( const ClassName& ) = default; }; Shallow Copy (e.g. memcpy ) (Avoid) (Double Destructions) Explanation A shallow copy occurs when the copy constructor simply copies the pointer values instead of the data they point to. This can lead to multiple instances trying to manage the same resource . This can lead to issues such as: Double destructions : When both objects are destroyed , they attempt to free the same memory location , resulting in undefined behavior . Dangling pointers : When one object is deleted , the other retains a pointer to the deallocated memory , leading to program crashes if accessed . The copy is performed quickly since it merely copies the pointer (for pointer types) rather than the pointed-to values. Syntax class ClassName { public: Type* _mem_ptr; // Shallow copy constructor. ClassName( const ClassName& other ) { _mem_ptr = other._mem_ptr; ...; }; // Destructor. ~ClassName() { // Free allocated memory: Error, double destruction. delete _mem_ptr; ...; }; }; Deep Copy (Recommend) Explanation A deep copy ensures that the copy constructor creates a new instance of any dynamically allocated memory, so that two objects do not reference the same location . This prevents double deletion and dangling pointer issues, as each object manages its own memory independently. Although slower than shallow copying due to memory allocation, deep copying is generally much safer , particularly for complex data structures. When implementing a copy constructor, it is also recommended to implement a corresponding copy assignment operator to maintain consistent behavior and proper resource management. Syntax class ClassName { public: Type* _mem_ptr; // Deep copy constructor. ClassName( const ClassName& other ) { _mem_ptr = new Type( *other._mem_ptr ); ...; }; // Destructor ~ClassName() { // Free allocated memory. delete _mem_ptr; ...; }; Move Constructors Explanation A move constructor is a constructor that transfers resources from one object to another , rather than performing a deep copy. This enables efficient handling of temporary objects and avoids unnecessary data copying . It is ideal for rvalue references , which represent temporary objects that do not need to retain their original state. Move constructors should be marked noexcept to ensure compatibility with standard containers and to optimize performance . Default Move Constructors Explanation The compiler generates a default move constructor only if: The class does not explicitly define a copy constructor, copy assignment operator, move constructor, or move assignment operator . All data members and base classes are movable (i.e., they also support move semantics). The default move constructor performs a shallow move , transferring (not copying) each member from the source object to the destination. However, it treats all members as if they were primitive types, performing a shallow transfer without resetting any pointer members of the original object to nullptr . This can cause issues such as double deletions and dangling pointers . While terms like \"shallow move\" and \"deep move\" are not part of standard C++ terminology , \"unsafe copy\" and \"safe copy\" better convey the risks and benefits of different copying strategies. The default move constructor is typically marked as noexcept , improving performance by ensuring compatibility with standard containers, such as std::vector . The = default syntax explicitly requests the compiler to generate the default move constructor . Syntax class ClassName { public: // Compiler-generated default move constructor. }; class ClassName { public: // Default move constructor. ClassName( ClassName&& ) = default; }; Custom Move Constructor Explanation A custom move constructor is defined under the following circumstances: When a class manages resources that necessitate specialized management , such as dynamic memory allocation or file handles. When there is a need to reset the original object to a valid state (e.g., to nullptr ) following the transfer of ownership. Move constructors should be marked noexcept to ensure compatibility with standard containers and to optimize performance . containers like std::vector . Syntax class ClassName { public: Type* _mem_ptr; // Custom move constructor. ClassName( ClassName&& other ) noexcept: _mem_ptr( std::move( other._mem_ptr ) { // Deep move. Safe move. other._mem_ptr = nullptr; ...; }; // Destructor. ~ClassName() { // Free allocated memory. delete _mem_ptr; // Leave 'other' in a valid state ...; }; }; Conversion Constructors Explanation A conversion constructor allows implicit (should avoid it with the explicit keyword) or explicit conversion from a given type to the class type. It takes a single parameter of a different type and initializes an object of the class with it. These constructors facilitate the integration of custom classes with existing code by allowing automatic type conversion where appropriate. When the target class holds additional information, conversion constructors ensure that initialization aligns with the class's intended use. Syntax class ClassName { public: // Conversion constructor. ClassName( Type para_name ); }; virtual Constructors The concept of a \" virtual constructor\" does not exist. explicit Constructors explicit Destructors Explanation A destructor is a special member function that is automatically called when an object goes out of scope or is explicitly deleted . Its primary purpose is to release resources (such as dynamically allocated memory or file handles) associated with the object. If a class has base classes or member objects, their destructors are called in reverse order of construction . Syntax class ClassName { public: ~ClassName() { }; // Destructor. }; Default Destructors Explanation A default destructor is automatically generated by the compiler if the class does not explicitly define one . It handles destruction according to the rules of the language, ensuring that all member variables and base classes are properly destroyed. If the class directly manages resources (e.g., raw pointers), a custom destructor is necessary to avoid resource leaks . The default destructor is typically marked as noexcept , improving performance by ensuring compatibility with standard containers, such as std::vector . The = default syntax explicitly requests the compiler to generate the default destructor . Syntax class ClassName { public: // Default destructor. ~ClassName() = default; }; virtual Destructors virtual Destructors Operator Overloading Operator Overloading Copy-assignment Operator Copy-assignment Operator Move-assignment Operator Move-assignment Operator Conversion Operator Conversion Operator explicit Conversion Operator explicit Conversion Operator How to Determine Which Constructor or Assignment Operator Is Invoked If an object is being defined , the appropriate constructor will be called: No argument : default constructor. Single argument of a different type: conversion constructor. Single argument of the same type ( lvalue reference ): copy constructor. Single argument of the same type ( rvalue reference ): move constructor. Multiple arguments: parameterized constructor. If an object already exists and is assigned a new object, the assignment operator will be called: Same type ( lvalue reference ): copy -assignment operator. Same type ( rvalue reference ): move -assignment operator. Inheritance Explanation Inheritance allows a class to acquire the properties and behaviors of another class. It promotes code reuse and establishes a hierarchical relationship between a base class and one or more derived classes. C++ supports multiple inheritance and virtual inheritance to address complexities arising from overlapping base classes. Inheritance also facilitates polymorphism , enabling derived classes to override virtual functions . Definition Syntax Code class public Base{ // Members of base class. }; class Derived: public Base { // Members of derived class. }; template< class T, ... > class public Base{ // Members of base class. }; template< class T, ... > class Derived: public Base< class T, ... > { // Members of derived class. }; Categories public inheritance: The visibility of base class members remains unchanged in the derived class. protected inheritance: Public members of the base class become protected in the derived class. private inheritance: All base class members (public and protected) become private in the derived class. Initialization Syntax Code class Derived: public Base { public: Derived( para_list1 ): Base( para_list2 ), ... {}; private: ...; }; Explanation When creating a derived class object, constructor delegation allows initializing the base class part of the object. The initialization of the base class members must be done via an initializer list in the derived class constructor. Construction Order Base class constructor: Called first, initializing the base portion of the object. Derived class constructor: Called after the base class constructor. Member initializations: Member variables of the derived class are initialized after the base class part. Destruction Order Derived class destructor: Called first to release resources specific to the derived class. Base class destructor: Called last to release resources inherited from the base class. virtual Inheritance virtual Inheritance virtual Explanation The virtual keyword in C++ is integral to enabling dynamic polymorphism and ensuring the correct behavior of objects in inheritance hierarchies. virtual Methods ( virtual Functions) ( virtual Memeber Functions) Explanation A virtual method is a member function declared with the virtual keyword in a base class , allowing derived classes to provide their own implementation . When invoked through a base class pointer or reference , the function from the most derived class is called, enabling runtime polymorphism . virtual methods ensure dynamic dispatch by resolving function calls at runtime based on the object's actual type. They can be overridden in derived classes using the same function signature. The override keyword is optional but recommended , as it ensures that the derived class correctly overrides a virtual function. If a derived class does not override the virtual function, the base class's implementation will be invoked. Syntax class Base { public: virtual RetType funcName() const { // Base class implementation. }; }; class Derived: public Base { public: // Override keyword for clarity. RetType funcName() const override{ // Derived class implementation. }; }; Static Binding and Dynamic Binding Polymorphism and Problems Polymorphism : virtual functions enable polymorphic behavior, allowing a program to treat objects of different derived classes through a base class pointer or reference. This allows different objects to be operated on using the same interface , meaning the same operation can be applied to different objects , exhibiting different behaviors . This makes it easier to write flexible and reusable code. Performance overhead : virtual functions introduce a performance penalty due to the dynamic dispatch mechanism. The program must go through the V table to look up the correct function to call at runtime, which can be slower than static binding. Memory overhead : Each class that uses virtual functions typically includes a virtual table (vtable) , which adds some memory overhead. Each object of such classes contains a pointer to the vtable, increasing the size of the object. Debugging Challenges : Debugging issues related to virtual functions can be more challenging, especially when it comes to understanding the flow of execution and object lifetimes in the presence of polymorphism. Potential for Resource Leaks : If a base class has virtual functions , its destructor should also be virtual to ensure proper cleanup of derived class resources. Failing to declare a virtual destructor can lead to resource leaks. Bindings Notes In cases where performance is very important, you should avoid using virtual functions as much as possible. Pure virtual Functions and Abstract Class Explanation A pure virtual function is declared by assigning = 0 to a virtual function , indicating that it does not provide any implementation in the base class. Pure virtual functions enforce a contract that derived classes must fulfill, promoting design consistency . A class containing at least one pure virtual function is termed an abstract class and cannot be instantiated . The abstract class is not restricted to only contain virtual functions . If a class only contains pure virtual functions , it serves as an interface or a base type for deriving more specific implementations. All derived classes must override the pure virtual functions ; otherwise , they also become abstract . Abstract classes may contain non-virtual member functions in addition to pure virtual ones. Syntax class ClassName { public: // Pure `virtual` function. virtual RetType funcName const = 0; }; virtual Destructors Explanation A virtual destructor ensures that when an object is deleted via a base class pointer , the destructor of the derived class is invoked , followed by the base class\u2019s destructor . This guarantees that all resources allocated by the derived class are correctly released , thereby preventing memory leaks and ensuring complete destruction of the object. Destructors should be declared virtual in any base class intended for inheritance to avoid undefined behavior during object destruction. Without a virtual destructor, only the base class destructor would execute , leaving resources specific to the derived class unreleased . Although virtual destructors add a slight performance overhead , they are critical for safe and correct resource management . Syntax class Base { public: virtual ~Base() { // Cleanup logic for the base class. }; }; class Derived: public Base { public: ~Derived() { // Cleanup logic for the derived class. }; }; Notes It's used to delete a subclass object pointed to by a parent class pointer in a polymorphic context . A virtual destructor differs from other virtual functions. The subclass's virtual destructor does not override its parent class's virtual destructor; both will be called. If we allow our class to be derived into a subclass, we should declare its destructor as virtual to avoid issues like memory leaks. virtual Inheritance Explanation virtual inheritance prevents ambiguity when a class indirectly inherits from the same base class multiple times . It ensures that only one instance of the base class exists in the final derived class. It resolves the diamond inheritance problem , where two base classes share a common ancestor. The base class constructor must be invoked from the most-derived class . Definition Syntax class Base { ...; }; class A: virtual public Base {}; class B: virtual public Base {}; class Derived: public A, public B {}; Initialization Syntax class Derived: public A, public B { public: Derived( para_list1 ): Base( para_list2 ), A( para_list3 ), B( para_list4 ){}; }; Construction Order virtual base class constructor: Called first, even if it's inherited indirectly. Other base class constructors: Called next. Derived class constructor: Called last. Destruction Order Derived class destructor: Invoked first. Non-virtual base class destructors: Called next. virtual base class destructor: Called last. friend Explanation The friend keyword grants non-member functions or other classes access to the private and protected members of a class. The friend keyword is commonly used when specific functions or classes require access to a class's internal details but are not part of its public interface Friendship in C++ is not inherited \u2014a derived class does not inherit the friendship relationships of its base class. Additionally, friendship is unidirectional : the class or function granted access does not automatically reciprocate that privilege . friend Functions Explanation A friend function is a non-member function that is allowed access to the private and protected members of a class. If the friend function needs access to non-static non-public members , the class instance should be passed to the friend function . If the friend function only accesses static members or performs operations unrelated to a specific object , the class instance does not need to be passed . Syntax class ClassName { public: // Friend function declaration. friend RetType funcName( const ClassName& obj ); }; class ClassName { public: // Friend function declaration. friend RetType funcName(); }; friend Classes Explanation A friend class is a non-member class that is granted access to the private and protected members of another class. If the member functions of the friend class need to access non-static non-static members , the class instance should be passed to those functions . If the member functions of the friend class access static members or perform operations unrelated to a specific object , the class instance does not need to be passed . Syntax class ClassA { public: friend class ClassB; // Declaring ClassB as a friend }; class ClassB { public: RetType funcName( const ClassA& obj ) { ... }; }; class ClassA { public: friend class ClassB; // Declaring ClassB as a friend }; class ClassB { public: RetType funcName() { ... }; }; final Explanation The final keyword in C++ is used to prevent further inheritance or overriding of classes and virtual functions. It plays a crucial role in controlling the behavior of classes in the inheritance hierarchy. final Functions Explanation A final function is a virtual function that cannot be overridden by any derived class. The final specifier ensures that the function's implementation remains fixed in the class that declares it as final. This feature can improve performance by devirtualizing calls to the final function, as the compiler can safely inline such calls , knowing that no further overrides exist and not add this function to vtable . Syntax class Base { public: virtual RetType funcName() final; // Declaration of a final function. }; final Classes Explanation A final class is a class that cannot be inherited from. Declaring a class as final ensures that no further subclassing is allowed, which can prevent misuse of inheritance and unintended extensions of the class\u2019s functionality. Marking a class as final can improve runtime performance , as the compiler can optimize calls and remove virtual dispatch overhead . Final classes are often used for singleton patterns , utility classes , or performance-critical components to prevent inheritance overhead . Syntax class FinalClass final {}; // class Derived: public FinalClass {}; // Error: Cannot inherit from a final class explicit explicit using using Hiding, Overloading, Overriding, and Overwriting Hiding, Overloading, Overriding, and Overwriting Notes All destructors of base classes (parent classes) should be declared as virtual functions. All functions of base classes (parent classes) that you intend to override in derived classes need to be declared as virtual. The parameter of a copy constructor and copy assignment operator should not be passed by value, as this can lead to a issue, an infinite loop.","title":"Classes"},{"location":"Classes/#classes-class","text":"","title":"Classes (class)"},{"location":"Classes/#explanation","text":"A class is a user-defined type that serves as a blueprint for creating objects. It encapsulates data members (variables) and member functions (methods) that operate on these data. A class provides a way to group related behaviors and attributes into a cohesive unit, promoting data abstraction and encapsulation. A class helps enforce encapsulation by limiting access to internal details and exposing only the necessary functionalities, making code more modular, reusable , and easier to maintain . An empty object occupy at least one byte memory. Creating an object on the stack is faster than on the heap. Structures( Stored as the class ) + Functions( Stored outside of the class ) = Classes .","title":"Explanation"},{"location":"Classes/#visibility","text":"The visibility makes code more readable, not affect the performance . private ( default visibility ): The owner class, friend class. protected : The owner class, friend class, sub-class. public : All.","title":"Visibility"},{"location":"Classes/#declaration-syntax","text":"class ClassName;","title":"Declaration Syntax"},{"location":"Classes/#definition-syntax","text":"class ClassName { ...; };","title":"Definition Syntax"},{"location":"Classes/#common-objects","text":"","title":"Common Objects"},{"location":"Classes/#declaration-syntax_1","text":"ClassName obj_name;","title":"Declaration Syntax"},{"location":"Classes/#initialization-syntax","text":"// Default constructor. ClassName obj_name; // Parameterized constructor. ClassName obj_name( para_list ); // Parameterized constructor. ClassName obj_name1( para_list ); // Copy constructor. ClassName obj_name2( obj_name1 ); // Not recommend, although the compiler may optimize it so that only one constructor is called. // First, parameterized constructor. // Second, copy constructor. ClassName obj_name = ClassName( para_list ); // Parameterized constructor. ClassName obj_name1( para_list ); // Move constructor. ClassName obj_name2( std::move( obj_name1 ) ); // Parameterized constructor. ClassName obj_name1( para_list ); // Move constructor. ClassName obj_name2 = std::move( obj_name1 ); // Conversion construcotr, implicit conversion. ClassName obj_name = initializer; // Without related parameterized constructors and all members are public, aggregate initialization. // With related parameterized constructors, parameterized constructor or uniform initialization or brace initialization. ClassName obj_name{ para_list }; // With default construcotr, default constructor. // Otherwise, aggregate initialization. // All members are initialized to 0. ClassName obj_name{ }; // Aggregate initialization. ClassName obj_name = { para_list }; // When defining a class, assigning default values to its members. class ClassName { private: Type _mem1 = initializer1; ...; }; class ClassName { public: // Move constructor definition. ...; // Factory methods for initialization. static ClassName createClassName() { return std::move( ClassName( para_list ); // Parameterized constructor. }; ...; }; // First, create a temporary object with the parameterized constructor in the createClassName. // Second, create `obj_name` with the move constructor. ClassName obj_name = ClassName::createClassName();","title":"Initialization Syntax"},{"location":"Classes/#limitations-of-aggregate-initialization","text":"No user-defined constructors : Aggregate initialization is only applicable to aggregate types that lack user-defined constructors. If a class has any constructor defined, aggregate initialization cannot be used. Public members only : Only public members can be initialized via aggregate initialization. Private or protected members cannot be accessed. No default member initializers : Default member initializers in aggregates are ignored during aggregate initialization, meaning you must explicitly specify values for all members. Order of initialization : Members are initialized in the order they are declared. This can lead to issues if one member relies on another being initialized first. No designated initializers : C++ does not support designated initializers (as in C99), preventing the ability to initialize specific members without initializing all preceding members. Type matching : The types in the initializer list must match the types of the aggregate's members exactly. A mismatch results in a compilation error. No implicit conversions : Aggregate initialization does not allow implicit type conversions, which can limit flexibility. No inheritance : Aggregate initialization is not applicable for derived classes, limiting its use in inheritance scenarios.","title":"Limitations of Aggregate Initialization"},{"location":"Classes/#class-pointers","text":"","title":"Class Pointers"},{"location":"Classes/#declaration-syntax_2","text":"ClassName* obj_ptr;","title":"Declaration Syntax"},{"location":"Classes/#definition-or-initialization-syntax","text":"// Default constructor. ClassName* obj_ptr = new ClassName; // Parameterized constructor. ClassName* obj_ptr = new ClassName( para_list ); // Default constructor. ClassName obj_name; ClassName* obj_ptr = &obj_name;","title":"Definition or Initialization Syntax"},{"location":"Classes/#class-references","text":"// Default constructor. ClassName obj_name; ClassName& obj_ref = &obj_name;","title":"Class References"},{"location":"Classes/#const-instance-of-classes","text":"const Instance of Classes","title":"const Instance of Classes"},{"location":"Classes/#constexpr-instances-of-classes","text":"constexpr Instances of Classes","title":"constexpr Instances of Classes"},{"location":"Classes/#static-instances-of-classes","text":"static Instances of Classes","title":"static Instances of Classes"},{"location":"Classes/#anonymous-classes","text":"","title":"Anonymous Classes"},{"location":"Classes/#explanation_1","text":"An anonymous class (also known as an unnamed class ) is a class that is defined inline without a name . These classes are typically used for creating objects on the fly or as part of data structures without the need to define a separate named class","title":"Explanation"},{"location":"Classes/#syntax","text":"class { ...; } obj_name; union { class { ...; }; ...; }; // In this case, members should all be public. class { ...; } obj_name{ para_list };","title":"Syntax"},{"location":"Classes/#member-variables","text":"","title":"Member Variables"},{"location":"Classes/#explanation_2","text":"Member variables, also known as instance variables or fields , are attributes of a class that hold data specific to the instances (objects) of that class. They define the state of an object. Member variables can be assigned default values when they are defined .","title":"Explanation"},{"location":"Classes/#syntax_1","text":"class ClassName { private: Type _mem; // Declaration or definition of a member variable. };","title":"Syntax"},{"location":"Classes/#this","text":"","title":"this"},{"location":"Classes/#explanation_3","text":"this is a pointer available within a class's member function that points to the object that invoked the member function. It allows access to the calling object's members. this is implicitly passed to all non-static member functions . It can be useful for disambiguation when member variables and parameters have the same name. It is not available in static member functions as there is no associated object.","title":"Explanation"},{"location":"Classes/#syntax_2","text":"this->_mem; // (*this)._mem;","title":"Syntax"},{"location":"Classes/#const-member-variables","text":"const Member Variables","title":"const Member Variables"},{"location":"Classes/#constexpr-member-variables","text":"constexpr Member Variables","title":"constexpr Member Variables"},{"location":"Classes/#static-member-variables","text":"static Member Variables","title":"static Member Variables"},{"location":"Classes/#mutable-member-variables","text":"","title":"mutable Member Variables"},{"location":"Classes/#explanation_4","text":"mutable member variables can be modified even in const member functions . This allows certain aspects of an object to change while keeping its overall state constant. Generally, they are used for caching or lazy evaluation purposes . They break the const-correctness for that particular member variable. In 90% of cases, the mutable keyword will be used in a class with the const keyword.","title":"Explanation"},{"location":"Classes/#syntax_3","text":"class ClassName { private: mutable Type _mem; // Declaration or definition of a member variable. };","title":"Syntax"},{"location":"Classes/#pointer-member-variables","text":"","title":"Pointer Member Variables"},{"location":"Classes/#explanation_5","text":"Pointer member variables hold memory addresses of instances or other data types. They allow dynamic memory management and manipulation of resources.","title":"Explanation"},{"location":"Classes/#syntax_4","text":"class ClassName { private: Type* _mem_ptr; // Declaration or definition of a member pointer. };","title":"Syntax"},{"location":"Classes/#reference-member-variables","text":"","title":"Reference Member Variables"},{"location":"Classes/#explanation_6","text":"Reference member variables are alternatives to pointers that refer to existing objects . They cannot be reassigned once established. Theyt must be initialized when defined and cannot be null . There are only two ways to initialize a reference member: In-Class Initialization : It can be overridden by the constructor. Constructor Initialization . When initializing a reference member in a class, the reference must be bound to either another member variable of the class or an external variable passed as a reference during object construction.","title":"Explanation"},{"location":"Classes/#syntax_5","text":"class ClassName { public: // Initialization through constructor explicit ClassName( Type& ref ): _memRef( ref ) {}; private: Type _mem; // In-Class Initialization Type& _memRef = _mem; };","title":"Syntax"},{"location":"Classes/#methods","text":"","title":"Methods"},{"location":"Classes/#explanation_7","text":"A method in C++ is a function that belongs to a class or struct. It is used to perform operations or manipulate the data members (attributes) of that class. Methods encapsulate behavior specific to an object of the class. Methods can be overloaded by defining multiple versions with different parameter types. Methods defined inside the class are automatically considered inline , improving performance by reducing function call overhead.","title":"Explanation"},{"location":"Classes/#syntax_6","text":"// Declared and defined inside the class. class ClassName { public: RetType funcName( para_list ) { ... }; }; // Declared inside the class. class ClassName { public: RetType funcName( para_list ) { ... }; }; // Defined outside the class. RetType ClassName::funcName( para_list ) { ... };","title":"Syntax"},{"location":"Classes/#const-methods-const-member-functions","text":"const Methods ( const Member Functions)","title":"const Methods (const Member Functions)"},{"location":"Classes/#constexpr-methods-constexprt-member-functions","text":"constexpr Functions ( constexpr Return Values)","title":"constexpr Methods (constexprt Member Functions)"},{"location":"Classes/#static-methods-static-member-functions","text":"static Methods ( static Member Functions)","title":"static Methods (static Member Functions)"},{"location":"Classes/#virtual-methods-virtual-functions-virtual-memeber-functions","text":"virtual Methods ( virtual Functions) ( virtual Memeber Functions)","title":"virtual Methods (virtual Functions) (virtual Memeber Functions)"},{"location":"Classes/#pure-virtual-functions-and-abstract-class","text":"Pure virtual Functions and Abstract Class","title":"Pure virtual Functions and Abstract Class"},{"location":"Classes/#override-methods","text":"","title":"override Methods"},{"location":"Classes/#explanation_8","text":"override is a keyword used to explicitly indicate that a method in a derived class is meant to override a virtual method in the base class . It ensures that the method signature in the derived class matches a virtual method in the base class. If the method signature does not match , the compiler will generate an error , which helps prevent subtle bugs caused by accidental method hiding.","title":"Explanation"},{"location":"Classes/#syntax_7","text":"class Base { public: virtual RetType funcName( para_list ){ // `virtual` method in base class }; }; class Derived: public Base { public: RetType funcName( para_list ) override{ // Override the base class method }; };","title":"Syntax"},{"location":"Classes/#notes","text":"You should always use the override keyword when overriding functions in a derived class, as it helps prevent errors.","title":"Notes"},{"location":"Classes/#constructors","text":"","title":"Constructors"},{"location":"Classes/#explanation_9","text":"Constructors are special member functions of a class that are automatically called when an object of that class is created . They are used to initialize the object's properties and set up any necessary resources.","title":"Explanation"},{"location":"Classes/#syntax_8","text":"class ClassName { public: ClassName( para_list ){ }; };","title":"Syntax"},{"location":"Classes/#defalut-constructors-and-default-constructors","text":"","title":"Defalut Constructors and default Constructors"},{"location":"Classes/#explanation_10","text":"A default constructor is a constructor with no parameters or with all parameters having default values . It is called when an object is instantiated without any arguments . It initializes data members to their default values ( primitive types remain uninitialized ). If no other constructors are defined, the compiler provides a default constructor. The non-customized default constructor will initialize all non-user-defined type members to their zero values . The = default syntax explicitly requests the compiler to generate the default constructor .","title":"Explanation"},{"location":"Classes/#syntax_9","text":"class ClassName { public: // If no other constructors are defined, // this default constructor is provided by the compiler. ClassName(){}; }; class ClassName { public: // Default constructor. ClassName(){ ... }; }; class ClassName { public: // Default constructor. ClassName() = default; // Default constructor. // Parameterized constructor. ClassName( parameters with default values ){ }; };","title":"Syntax"},{"location":"Classes/#parameterized-constructors","text":"","title":"Parameterized Constructors"},{"location":"Classes/#explanation_11","text":"A parameterized constructor is a type of constructor in a class that allows you to initialize an object with specific values upon creation. Unlike a default constructor (which takes no arguments), a parameterized constructor accepts one or more arguments that enable you to set the initial state of an object with specific values. It is called when an object is instantiated with specific arguments .","title":"Explanation"},{"location":"Classes/#syntax_10","text":"class ClassName { public: // Parameterized constructor. ClassName( para_list ){ }; };","title":"Syntax"},{"location":"Classes/#constructor-initializer-lists","text":"","title":"Constructor Initializer Lists"},{"location":"Classes/#explanation_12","text":"Constructor initializer lists are used to initialize member variables of a class in the constructor's initialization phase before the body of the constructor executes. Member variables are initialized in the order they are declared in the class, not the order they appear in the initializer list . Using initializer lists can be more efficient , as it allows direct initialization of the member variables, avoiding unnecessary default construction followed by assignment. An initializer list is required to initialize const and reference members , as they cannot be assigned after construction. If members are initialized in the constructor's body , those members are first default-initialized before being assigned, which can lead to additional overhead compared to direct initialization in the initializer list.","title":"Explanation"},{"location":"Classes/#syntax_11","text":"class ClassName { public: ClassName( Type1 para1, Type2 para2, ... ): _mem1( para1 ), _mem2( para2 ), ...{}; private: Type1 _mem1; Type2 _mem2; ...; };","title":"Syntax"},{"location":"Classes/#notes_1","text":"In the constructor initializer list, you'd better initialize the members in the order in which they are defined in the class. If a class has a class or struct member , we should use the constructor initializer to initialize the class or struct member; otherwise , the initialization will call the object's constructors twice : first the default constructor, and then the other constructor.","title":"Notes"},{"location":"Classes/#copy-constructors","text":"","title":"Copy Constructors"},{"location":"Classes/#explanation_13","text":"A copy constructor is a special constructor that initializes a new object as a copy of an existing object . This is essential for managing resource ownership and ensuring that objects behave properly when passed, returned, or assigned. The parameter of a copy constructor and copy assignment operator should not be passed by value , as this can lead to issues. When passing the argument by value, the copy constructor will be called to create a temporary object for the parameter. This temporary object creation requires another call to the copy constructor, which leads to a recursive cycle. The cycle continues until the call stack overflows, causing a stack overflow error. In other words, passing by value in the copy constructor or copy assignment operator triggers an infinite loop , as each invocation requires another copy of the argument, which again invokes the copy constructor.","title":"Explanation"},{"location":"Classes/#default-copy-default-avoid-double-destructions","text":"","title":"Default Copy (default) (Avoid) (Double Destructions)"},{"location":"Classes/#explanation_14","text":"A default copy constructor is automatically generated by the compiler if no user-defined copy constructor is present. It performs a shallow copy of the object's members. For primitive types, this is a straightforward copy, but for pointer members , both the original and copied objects will reference the same memory . This can lead to issues such as: Double destructions : When both objects are destroyed , they attempt to free the same memory location , resulting in undefined behavior . Dangling pointers : When one object is deleted , the other retains a pointer to the deallocated memory , leading to program crashes if accessed . The copy is performed quickly since it merely copies the pointer (for pointer types) rather than the pointed-to values. The default copy constructor is typically marked as noexcept , improving performance by ensuring compatibility with standard containers, such as std::vector . The = default syntax explicitly requests the compiler to generate the default copy constructor .","title":"Explanation"},{"location":"Classes/#syntax_12","text":"class ClassName { public: // Compiler-generated default copy constructor. }; class ClassName { public: // Default copy constructor. ClassName( const ClassName& ) = default; };","title":"Syntax"},{"location":"Classes/#shallow-copy-eg-memcpy-avoid-double-destructions","text":"","title":"Shallow Copy (e.g. memcpy) (Avoid) (Double Destructions)"},{"location":"Classes/#explanation_15","text":"A shallow copy occurs when the copy constructor simply copies the pointer values instead of the data they point to. This can lead to multiple instances trying to manage the same resource . This can lead to issues such as: Double destructions : When both objects are destroyed , they attempt to free the same memory location , resulting in undefined behavior . Dangling pointers : When one object is deleted , the other retains a pointer to the deallocated memory , leading to program crashes if accessed . The copy is performed quickly since it merely copies the pointer (for pointer types) rather than the pointed-to values.","title":"Explanation"},{"location":"Classes/#syntax_13","text":"class ClassName { public: Type* _mem_ptr; // Shallow copy constructor. ClassName( const ClassName& other ) { _mem_ptr = other._mem_ptr; ...; }; // Destructor. ~ClassName() { // Free allocated memory: Error, double destruction. delete _mem_ptr; ...; }; };","title":"Syntax"},{"location":"Classes/#deep-copy-recommend","text":"","title":"Deep Copy (Recommend)"},{"location":"Classes/#explanation_16","text":"A deep copy ensures that the copy constructor creates a new instance of any dynamically allocated memory, so that two objects do not reference the same location . This prevents double deletion and dangling pointer issues, as each object manages its own memory independently. Although slower than shallow copying due to memory allocation, deep copying is generally much safer , particularly for complex data structures. When implementing a copy constructor, it is also recommended to implement a corresponding copy assignment operator to maintain consistent behavior and proper resource management.","title":"Explanation"},{"location":"Classes/#syntax_14","text":"class ClassName { public: Type* _mem_ptr; // Deep copy constructor. ClassName( const ClassName& other ) { _mem_ptr = new Type( *other._mem_ptr ); ...; }; // Destructor ~ClassName() { // Free allocated memory. delete _mem_ptr; ...; };","title":"Syntax"},{"location":"Classes/#move-constructors","text":"","title":"Move Constructors"},{"location":"Classes/#explanation_17","text":"A move constructor is a constructor that transfers resources from one object to another , rather than performing a deep copy. This enables efficient handling of temporary objects and avoids unnecessary data copying . It is ideal for rvalue references , which represent temporary objects that do not need to retain their original state. Move constructors should be marked noexcept to ensure compatibility with standard containers and to optimize performance .","title":"Explanation"},{"location":"Classes/#default-move-constructors","text":"","title":"Default Move Constructors"},{"location":"Classes/#explanation_18","text":"The compiler generates a default move constructor only if: The class does not explicitly define a copy constructor, copy assignment operator, move constructor, or move assignment operator . All data members and base classes are movable (i.e., they also support move semantics). The default move constructor performs a shallow move , transferring (not copying) each member from the source object to the destination. However, it treats all members as if they were primitive types, performing a shallow transfer without resetting any pointer members of the original object to nullptr . This can cause issues such as double deletions and dangling pointers . While terms like \"shallow move\" and \"deep move\" are not part of standard C++ terminology , \"unsafe copy\" and \"safe copy\" better convey the risks and benefits of different copying strategies. The default move constructor is typically marked as noexcept , improving performance by ensuring compatibility with standard containers, such as std::vector . The = default syntax explicitly requests the compiler to generate the default move constructor .","title":"Explanation"},{"location":"Classes/#syntax_15","text":"class ClassName { public: // Compiler-generated default move constructor. }; class ClassName { public: // Default move constructor. ClassName( ClassName&& ) = default; };","title":"Syntax"},{"location":"Classes/#custom-move-constructor","text":"","title":"Custom Move Constructor"},{"location":"Classes/#explanation_19","text":"A custom move constructor is defined under the following circumstances: When a class manages resources that necessitate specialized management , such as dynamic memory allocation or file handles. When there is a need to reset the original object to a valid state (e.g., to nullptr ) following the transfer of ownership. Move constructors should be marked noexcept to ensure compatibility with standard containers and to optimize performance . containers like std::vector .","title":"Explanation"},{"location":"Classes/#syntax_16","text":"class ClassName { public: Type* _mem_ptr; // Custom move constructor. ClassName( ClassName&& other ) noexcept: _mem_ptr( std::move( other._mem_ptr ) { // Deep move. Safe move. other._mem_ptr = nullptr; ...; }; // Destructor. ~ClassName() { // Free allocated memory. delete _mem_ptr; // Leave 'other' in a valid state ...; }; };","title":"Syntax"},{"location":"Classes/#conversion-constructors","text":"","title":"Conversion Constructors"},{"location":"Classes/#explanation_20","text":"A conversion constructor allows implicit (should avoid it with the explicit keyword) or explicit conversion from a given type to the class type. It takes a single parameter of a different type and initializes an object of the class with it. These constructors facilitate the integration of custom classes with existing code by allowing automatic type conversion where appropriate. When the target class holds additional information, conversion constructors ensure that initialization aligns with the class's intended use.","title":"Explanation"},{"location":"Classes/#syntax_17","text":"class ClassName { public: // Conversion constructor. ClassName( Type para_name ); };","title":"Syntax"},{"location":"Classes/#virtual-constructors","text":"The concept of a \" virtual constructor\" does not exist.","title":"virtual Constructors"},{"location":"Classes/#explicit-constructors","text":"explicit","title":"explicit Constructors"},{"location":"Classes/#destructors","text":"","title":"Destructors"},{"location":"Classes/#explanation_21","text":"A destructor is a special member function that is automatically called when an object goes out of scope or is explicitly deleted . Its primary purpose is to release resources (such as dynamically allocated memory or file handles) associated with the object. If a class has base classes or member objects, their destructors are called in reverse order of construction .","title":"Explanation"},{"location":"Classes/#syntax_18","text":"class ClassName { public: ~ClassName() { }; // Destructor. };","title":"Syntax"},{"location":"Classes/#default-destructors","text":"","title":"Default Destructors"},{"location":"Classes/#explanation_22","text":"A default destructor is automatically generated by the compiler if the class does not explicitly define one . It handles destruction according to the rules of the language, ensuring that all member variables and base classes are properly destroyed. If the class directly manages resources (e.g., raw pointers), a custom destructor is necessary to avoid resource leaks . The default destructor is typically marked as noexcept , improving performance by ensuring compatibility with standard containers, such as std::vector . The = default syntax explicitly requests the compiler to generate the default destructor .","title":"Explanation"},{"location":"Classes/#syntax_19","text":"class ClassName { public: // Default destructor. ~ClassName() = default; };","title":"Syntax"},{"location":"Classes/#virtual-destructors","text":"virtual Destructors","title":"virtual Destructors"},{"location":"Classes/#operator-overloading","text":"Operator Overloading","title":"Operator Overloading"},{"location":"Classes/#copy-assignment-operator","text":"Copy-assignment Operator","title":"Copy-assignment Operator"},{"location":"Classes/#move-assignment-operator","text":"Move-assignment Operator","title":"Move-assignment Operator"},{"location":"Classes/#conversion-operator","text":"Conversion Operator","title":"Conversion Operator"},{"location":"Classes/#explicit-conversion-operator","text":"explicit Conversion Operator","title":"explicit Conversion Operator"},{"location":"Classes/#how-to-determine-which-constructor-or-assignment-operator-is-invoked","text":"If an object is being defined , the appropriate constructor will be called: No argument : default constructor. Single argument of a different type: conversion constructor. Single argument of the same type ( lvalue reference ): copy constructor. Single argument of the same type ( rvalue reference ): move constructor. Multiple arguments: parameterized constructor. If an object already exists and is assigned a new object, the assignment operator will be called: Same type ( lvalue reference ): copy -assignment operator. Same type ( rvalue reference ): move -assignment operator.","title":"How to Determine Which Constructor or Assignment Operator Is Invoked"},{"location":"Classes/#inheritance","text":"","title":"Inheritance"},{"location":"Classes/#explanation_23","text":"Inheritance allows a class to acquire the properties and behaviors of another class. It promotes code reuse and establishes a hierarchical relationship between a base class and one or more derived classes. C++ supports multiple inheritance and virtual inheritance to address complexities arising from overlapping base classes. Inheritance also facilitates polymorphism , enabling derived classes to override virtual functions .","title":"Explanation"},{"location":"Classes/#definition-syntax_1","text":"","title":"Definition Syntax"},{"location":"Classes/#code","text":"class public Base{ // Members of base class. }; class Derived: public Base { // Members of derived class. }; template< class T, ... > class public Base{ // Members of base class. }; template< class T, ... > class Derived: public Base< class T, ... > { // Members of derived class. };","title":"Code"},{"location":"Classes/#categories","text":"public inheritance: The visibility of base class members remains unchanged in the derived class. protected inheritance: Public members of the base class become protected in the derived class. private inheritance: All base class members (public and protected) become private in the derived class.","title":"Categories"},{"location":"Classes/#initialization-syntax_1","text":"","title":"Initialization Syntax"},{"location":"Classes/#code_1","text":"class Derived: public Base { public: Derived( para_list1 ): Base( para_list2 ), ... {}; private: ...; };","title":"Code"},{"location":"Classes/#explanation_24","text":"When creating a derived class object, constructor delegation allows initializing the base class part of the object. The initialization of the base class members must be done via an initializer list in the derived class constructor.","title":"Explanation"},{"location":"Classes/#construction-order","text":"Base class constructor: Called first, initializing the base portion of the object. Derived class constructor: Called after the base class constructor. Member initializations: Member variables of the derived class are initialized after the base class part.","title":"Construction Order"},{"location":"Classes/#destruction-order","text":"Derived class destructor: Called first to release resources specific to the derived class. Base class destructor: Called last to release resources inherited from the base class.","title":"Destruction Order"},{"location":"Classes/#virtual-inheritance","text":"virtual Inheritance","title":"virtual Inheritance"},{"location":"Classes/#virtual","text":"","title":"virtual"},{"location":"Classes/#explanation_25","text":"The virtual keyword in C++ is integral to enabling dynamic polymorphism and ensuring the correct behavior of objects in inheritance hierarchies.","title":"Explanation"},{"location":"Classes/#virtual-methods-virtual-functions-virtual-memeber-functions_1","text":"","title":"virtual Methods (virtual Functions) (virtual Memeber Functions)"},{"location":"Classes/#explanation_26","text":"A virtual method is a member function declared with the virtual keyword in a base class , allowing derived classes to provide their own implementation . When invoked through a base class pointer or reference , the function from the most derived class is called, enabling runtime polymorphism . virtual methods ensure dynamic dispatch by resolving function calls at runtime based on the object's actual type. They can be overridden in derived classes using the same function signature. The override keyword is optional but recommended , as it ensures that the derived class correctly overrides a virtual function. If a derived class does not override the virtual function, the base class's implementation will be invoked.","title":"Explanation"},{"location":"Classes/#syntax_20","text":"class Base { public: virtual RetType funcName() const { // Base class implementation. }; }; class Derived: public Base { public: // Override keyword for clarity. RetType funcName() const override{ // Derived class implementation. }; };","title":"Syntax"},{"location":"Classes/#static-binding-and-dynamic-binding","text":"","title":"Static Binding and Dynamic Binding"},{"location":"Classes/#polymorphism-and-problems","text":"Polymorphism : virtual functions enable polymorphic behavior, allowing a program to treat objects of different derived classes through a base class pointer or reference. This allows different objects to be operated on using the same interface , meaning the same operation can be applied to different objects , exhibiting different behaviors . This makes it easier to write flexible and reusable code. Performance overhead : virtual functions introduce a performance penalty due to the dynamic dispatch mechanism. The program must go through the V table to look up the correct function to call at runtime, which can be slower than static binding. Memory overhead : Each class that uses virtual functions typically includes a virtual table (vtable) , which adds some memory overhead. Each object of such classes contains a pointer to the vtable, increasing the size of the object. Debugging Challenges : Debugging issues related to virtual functions can be more challenging, especially when it comes to understanding the flow of execution and object lifetimes in the presence of polymorphism. Potential for Resource Leaks : If a base class has virtual functions , its destructor should also be virtual to ensure proper cleanup of derived class resources. Failing to declare a virtual destructor can lead to resource leaks. Bindings","title":"Polymorphism and Problems"},{"location":"Classes/#notes_2","text":"In cases where performance is very important, you should avoid using virtual functions as much as possible.","title":"Notes"},{"location":"Classes/#pure-virtual-functions-and-abstract-class_1","text":"","title":"Pure virtual Functions and Abstract Class"},{"location":"Classes/#explanation_27","text":"A pure virtual function is declared by assigning = 0 to a virtual function , indicating that it does not provide any implementation in the base class. Pure virtual functions enforce a contract that derived classes must fulfill, promoting design consistency . A class containing at least one pure virtual function is termed an abstract class and cannot be instantiated . The abstract class is not restricted to only contain virtual functions . If a class only contains pure virtual functions , it serves as an interface or a base type for deriving more specific implementations. All derived classes must override the pure virtual functions ; otherwise , they also become abstract . Abstract classes may contain non-virtual member functions in addition to pure virtual ones.","title":"Explanation"},{"location":"Classes/#syntax_21","text":"class ClassName { public: // Pure `virtual` function. virtual RetType funcName const = 0; };","title":"Syntax"},{"location":"Classes/#virtual-destructors_1","text":"","title":"virtual Destructors"},{"location":"Classes/#explanation_28","text":"A virtual destructor ensures that when an object is deleted via a base class pointer , the destructor of the derived class is invoked , followed by the base class\u2019s destructor . This guarantees that all resources allocated by the derived class are correctly released , thereby preventing memory leaks and ensuring complete destruction of the object. Destructors should be declared virtual in any base class intended for inheritance to avoid undefined behavior during object destruction. Without a virtual destructor, only the base class destructor would execute , leaving resources specific to the derived class unreleased . Although virtual destructors add a slight performance overhead , they are critical for safe and correct resource management .","title":"Explanation"},{"location":"Classes/#syntax_22","text":"class Base { public: virtual ~Base() { // Cleanup logic for the base class. }; }; class Derived: public Base { public: ~Derived() { // Cleanup logic for the derived class. }; };","title":"Syntax"},{"location":"Classes/#notes_3","text":"It's used to delete a subclass object pointed to by a parent class pointer in a polymorphic context . A virtual destructor differs from other virtual functions. The subclass's virtual destructor does not override its parent class's virtual destructor; both will be called. If we allow our class to be derived into a subclass, we should declare its destructor as virtual to avoid issues like memory leaks.","title":"Notes"},{"location":"Classes/#virtual-inheritance_1","text":"","title":"virtual Inheritance"},{"location":"Classes/#explanation_29","text":"virtual inheritance prevents ambiguity when a class indirectly inherits from the same base class multiple times . It ensures that only one instance of the base class exists in the final derived class. It resolves the diamond inheritance problem , where two base classes share a common ancestor. The base class constructor must be invoked from the most-derived class .","title":"Explanation"},{"location":"Classes/#definition-syntax_2","text":"class Base { ...; }; class A: virtual public Base {}; class B: virtual public Base {}; class Derived: public A, public B {};","title":"Definition Syntax"},{"location":"Classes/#initialization-syntax_2","text":"class Derived: public A, public B { public: Derived( para_list1 ): Base( para_list2 ), A( para_list3 ), B( para_list4 ){}; };","title":"Initialization Syntax"},{"location":"Classes/#construction-order_1","text":"virtual base class constructor: Called first, even if it's inherited indirectly. Other base class constructors: Called next. Derived class constructor: Called last.","title":"Construction Order"},{"location":"Classes/#destruction-order_1","text":"Derived class destructor: Invoked first. Non-virtual base class destructors: Called next. virtual base class destructor: Called last.","title":"Destruction Order"},{"location":"Classes/#friend","text":"","title":"friend"},{"location":"Classes/#explanation_30","text":"The friend keyword grants non-member functions or other classes access to the private and protected members of a class. The friend keyword is commonly used when specific functions or classes require access to a class's internal details but are not part of its public interface Friendship in C++ is not inherited \u2014a derived class does not inherit the friendship relationships of its base class. Additionally, friendship is unidirectional : the class or function granted access does not automatically reciprocate that privilege .","title":"Explanation"},{"location":"Classes/#friend-functions","text":"","title":"friend Functions"},{"location":"Classes/#explanation_31","text":"A friend function is a non-member function that is allowed access to the private and protected members of a class. If the friend function needs access to non-static non-public members , the class instance should be passed to the friend function . If the friend function only accesses static members or performs operations unrelated to a specific object , the class instance does not need to be passed .","title":"Explanation"},{"location":"Classes/#syntax_23","text":"class ClassName { public: // Friend function declaration. friend RetType funcName( const ClassName& obj ); }; class ClassName { public: // Friend function declaration. friend RetType funcName(); };","title":"Syntax"},{"location":"Classes/#friend-classes","text":"","title":"friend Classes"},{"location":"Classes/#explanation_32","text":"A friend class is a non-member class that is granted access to the private and protected members of another class. If the member functions of the friend class need to access non-static non-static members , the class instance should be passed to those functions . If the member functions of the friend class access static members or perform operations unrelated to a specific object , the class instance does not need to be passed .","title":"Explanation"},{"location":"Classes/#syntax_24","text":"class ClassA { public: friend class ClassB; // Declaring ClassB as a friend }; class ClassB { public: RetType funcName( const ClassA& obj ) { ... }; }; class ClassA { public: friend class ClassB; // Declaring ClassB as a friend }; class ClassB { public: RetType funcName() { ... }; };","title":"Syntax"},{"location":"Classes/#final","text":"","title":"final"},{"location":"Classes/#explanation_33","text":"The final keyword in C++ is used to prevent further inheritance or overriding of classes and virtual functions. It plays a crucial role in controlling the behavior of classes in the inheritance hierarchy.","title":"Explanation"},{"location":"Classes/#final-functions","text":"","title":"final Functions"},{"location":"Classes/#explanation_34","text":"A final function is a virtual function that cannot be overridden by any derived class. The final specifier ensures that the function's implementation remains fixed in the class that declares it as final. This feature can improve performance by devirtualizing calls to the final function, as the compiler can safely inline such calls , knowing that no further overrides exist and not add this function to vtable .","title":"Explanation"},{"location":"Classes/#syntax_25","text":"class Base { public: virtual RetType funcName() final; // Declaration of a final function. };","title":"Syntax"},{"location":"Classes/#final-classes","text":"","title":"final Classes"},{"location":"Classes/#explanation_35","text":"A final class is a class that cannot be inherited from. Declaring a class as final ensures that no further subclassing is allowed, which can prevent misuse of inheritance and unintended extensions of the class\u2019s functionality. Marking a class as final can improve runtime performance , as the compiler can optimize calls and remove virtual dispatch overhead . Final classes are often used for singleton patterns , utility classes , or performance-critical components to prevent inheritance overhead .","title":"Explanation"},{"location":"Classes/#syntax_26","text":"class FinalClass final {}; // class Derived: public FinalClass {}; // Error: Cannot inherit from a final class","title":"Syntax"},{"location":"Classes/#explicit","text":"explicit","title":"explicit"},{"location":"Classes/#using","text":"using","title":"using"},{"location":"Classes/#hiding-overloading-overriding-and-overwriting","text":"Hiding, Overloading, Overriding, and Overwriting","title":"Hiding, Overloading, Overriding, and Overwriting"},{"location":"Classes/#notes_4","text":"All destructors of base classes (parent classes) should be declared as virtual functions. All functions of base classes (parent classes) that you intend to override in derived classes need to be declared as virtual. The parameter of a copy constructor and copy assignment operator should not be passed by value, as this can lead to a issue, an infinite loop.","title":"Notes"},{"location":"ConstConstexprAndStatic/","text":"const , constexpr and static const Explanation Usage const Variables Explanation Syntax const Pointers Explanation Syntax const Member Variables Explanation Syntax const Methods ( const Member Functions) Explanation Syntax const Function Parameters Explanation Syntax const Return Values Explanation Syntax const Return Pointers Explanation Syntax const Return References Explanation Syntax const Instances of Classes Explanation Syntax constexpr Explanation Allowed Elements (Valid Elements) Disallowed Elements Usage constexpr Variables Explanation Syntax constexpr Pointers Explanation Syntax constexpr Member Variables Explanation Syntax constexpr Functions ( constexpr Return Values) Explanation Syntax constexpr Constructors (C++11 and later) Explanation Syntax constexpr Instances of Classes Explanation Syntax User-defined Literals Explanation Syntax static Explanation Usage static Local Variables Explanation Syntax static Global Variables Explanation Syntax static Member Variables Explanation Syntax static Methods ( static Member Functions) Explanation Syntax static Global Functions Explanation Syntax static Instances of Classes Explanation Syntax const , constexpr and static const Explanation The const keyword is used to declare constants or read-only variables . When a variable is declared as const , its value cannot be modified after it is initialized. This concept is beneficial for protecting data from unintended changes and for enhancing code readability and maintainability . However, it is just a promise that programmers should keep something constant and can be broken . Usage const Variables Explanation A const variable is a variable whose value cannot be changed after it has been initialized. The keyword const stands for \"constant\" and is used to define variables that should remain unchanged throughout their lifespan. A const variable must be initialized when it is declared . A const variable can be evaluated at compile time if it is initialized with a constant expression . Syntax const Type var_name = value; const Pointers Explanation const Type* pointer_name; means the value pointed to cannot be altered through this pointer. Type* const pointer_name; means the pointer address itself cannot be changed after it is initialized. Syntax Pointer to constant value: const Type* ptr_name; Constant pointer: Type* const ptr_name; const Member Variables Explanation A const data member must be initialized when the object is constructed because its value cannot be changed after initialization. There are only two way to initialize a const member: In-class initialization : In-class initialization works well for constants of integral types (like int, char, etc.) or other literal types . For non-integral types , initializer lists must be used. It can be overridden by the constructor. Constructor initializer lists . Syntax class ClassName { private: // In-class initialization. const Type _mem = initializer; }; const Methods ( const Member Functions) Explanation A const member method is a member function of a class that does not modify the object on which it is called. This means the const member function can't modify any non-mutable member variables of the class or object. In addition, a const function can be overloaded with other non-const functions, even if their names and parameter lists are the same. This is possible because their signatures differ, as the const keyword modifies the function signatures . However, if a member is of pointer type, the value or object the pointer points to does not belong to the class . Only the address stored in the pointer belongs to the class . Therefore, a const function can still modify the pointed-to value or object . Syntax RetType funcName( para_list ) const; const Function Parameters Explanation A const parameter is a parameter that receives an argument and ensures that the function does not change the argument . Syntax void funcName( const Type para1, ... ); const Return Values Explanation Returning a const value from a function indicates that the returned value cannot be modified by the caller. However, if a const return value is assigned to a non-const variable, it becomes modifiable once the assignment operation is complete. Syntax const RetType funcName( para_list ) { // Function body. }; const Return Pointers Explanation A function can return a pointer to a constant value , ensuring that the value being pointed to cannot be modified through the pointer. To assign a const return pointer to a variable , the variable must likewise be a pointer to const . Syntax const returnType* funcName() { // Function body }; const Return References Explanation A function can return a reference to a constant object , allowing efficient access to the object while ensuring it cannot be modified . To assign a const return reference to a variable , the variable must likewise be a const reference . Syntax const returnType& funcName() { // Function body }; const Instances of Classes Explanation A const instance ensures that none of its non-mutable members can be modified after initialization. However, if a member is of pointer type, the value or object the pointer points to does not belong to the class . Only the address stored in the pointer belongs to the class . Therefore, a const instance cannot ensure that this value or object remains unmodified . Only const-qualified member functions can be called on a const instance. These are functions that do not modify the object\u2019s state. A const instance can still modify mutable members . Syntax const ClassName obj_ptr; constexpr Explanation The constexpr keyword is used to declare variables and functions that can be evaluated at compile-time . This feature allows the compiler to perform calculations and allocate memory for certain constructs even before the program runs. When a variable or function is declared as constexpr , all elements related to it should be evaluated at compile time . For example, the function cannot contain any runtime I/O operations, as they cannot be evaluated at compile time. It enforces that certain values and calculations can be performed at compile-time , leading to significant performance improvements. Any variable or object declared with the constexpr keyword is constant and cannot be modified after it is initialized . It enhances the code readabilit . Allowed Elements (Valid Elements) Constant expressions (e.g., literals, constexpr variables). Simple arithmetic operations. Control flow statements (like if, switch, and loops) that do not depend on runtime values. Disallowed Elements Runtime I/O operations (e.g., std::cout). Dynamic memory allocation. Non-constexpr function calls (unless those functions are also constexpr ). Usage constexpr Variables Explanation A constexpr variable is a variable that must be initialized with an initializer that can be fully resolved at compile-time . The initializer must be evaluated at compile time . Syntax constexpr Type var_name = initializer; constexpr Pointers Explanation constexpr applies to the pointer itself , meaning the address stored in the pointer must be a constant expression . The address stored in a constexpr pointer must be known at compile-time . Syntax constexpr Type* var_name = initializer; constexpr Member Variables Explanation A constexpr member variable is a variable defined within a class that can be initialized with constant expressions . This allows them to be evaluated at compile time , which can lead to performance improvements and enable more complex compile-time computations. Syntax class ClassName { public: constexpr Type _mem = initializer; }; constexpr Functions ( constexpr Return Values) Explanation A constexpr function is a function that will be evaluated at compile-time if given compile-time constant arguments . If the result of a constexpr function is assigned to a variable, the best choice is to keep the variable as a constexpr variable . This ensures that the variable is initialized at compile time , which means the result of the function is also evaluated at compile time . Additionally, its parameters should be const values or constant expressions to ensure that the function is executed at compile time. RetType must be a literal type , which includes integral types, floating-point types, pointers, and certain user-defined types. Syntax constexpr RetType funcName( para_list ) { // Function body }; constexpr RetType var_name = funcName( para_list ); constexpr Constructors (C++11 and later) Explanation A constexpr constructor is a construcotr that can be used to create instances of the class with constant expressions . When a constexpr constructor is used to construct an object, the best choice is to keep the object as a constexpr type , and its initializer should be evaluated at compile time . Only when all related elements can be evaluated at compile time can the constructor also be evaluated at compile time. Syntax class ClassName { public: // Initialize member variables at compile-time. constexpr ClassName( para_list ): ... {}; private: ...; }; constexpr ClassName obj_name( para_list ); constexpr Instances of Classes Explanation A constexpr instance is an object that is evaluated at compile-time , if all its dependencies (constructors, functions, and data) are also constexpr . A constexpr instance must remain immutable , meaning its state cannot change after initialization. All data members must be initialized by the constexpr constructor since further modifications are not allowed. The class must have a constexpr constructor . All member functions invoked on a constexpr object must also be constexpr . Data members used in constexpr evaluation must be integral constants or themselves constexpr . A constexpr instance is always const implicitly, but the reverse is not true\u2014 const instances are not guaranteed to be evaluated at compile time. Syntax constexpr ClassName obj_ptr; User-defined Literals Explanation User-defined literals allow you to create custom literal suffixes that extend the functionality of built-in literals . This feature lets you define special behaviors for literals of various types , including integers, floating-point numbers, and strings. It's especially useful for creating more readable code , adding context or units to values , and improving type safety . User-defined literals are created by defining functions with specific naming and parameter rules . They begin with an underscore and are appended to a literal to convert it into a specific type or to invoke custom logic . Syntax constexpr RetType operator\"\" _name( Type para, ... ) { // Do something that can be evaluated at compile time. return ...; } static Explanation The static keyword in C++ is used to change the storage duration and visibility of variables and functions. It alters how variables are initialized and where they can be accessed. All static elements are initialized only once and persist until the program terminates . Local variables/objects: It changes their lifetime but does not change their scope. Global variables/objects/function: It does not change their lifetime, but it changes their scope by limiting them to the file where they are defined or declared. Class members variables : It changes their scope and lifetime . static data members are initialized outside the class definition. Class member function : It does not allow them to access non-static members , except for static members. Usage static Local Variables Explanation A static local variable is a static variable declared within a function that maintains its state between function calls . It has local scope , meaning it is only accessible within the function where it is declared . The variable is automatically initialized to zero if not explicitly initialized . Syntax RetType funcName() { // Initialized only once and retains value between calls. static Type count = val; ...; }; static Global Variables Explanation A static global variable is declared outside of all functions and is only accessible within the file in which it is declared, preventing name conflicts in other files . The variable is automatically initialized to zero if not explicitly initialized . Syntax static Type var_name; static Member Variables Explanation static members of a class belong to the class itself rather than any object instance and can be accessed without an instance . static members are shared among all instances of that class . They are accessed using the class name instead of the object name. static keyword only changes their lifetime ; it does not affect their visibility . We should define or initialize it outside the class . In fact, static members are static variables defined within a namespace . Syntax class ClassName { public: // Declaration of a static public class member. static Type1 _staticMember1; private: // Declaration of a static private class member. static Type2 _staticMember2;}; // Providing definition and initialization for the static member. Type1 ClassName::_staticMember1 = 0; Type2 ClassName::_staticMember2 = 0; static Methods ( static Member Functions) Explanation A static member function is a function defined within a class that can be called without creating an instance of the class. It cannot access instance variables or instance methods directly, since it does not have a this pointer. This means it can only access static data members or other static member functions within the class. It can be called using the class name . Syntax class ClassName { public: static RetType funcName( para_list ) { // Function body. }; }; RetType var_name = ClassName::funcName( para_list ); static Global Functions Explanation A static global function is a function limited in visibility to the file where it is defined, which helps to avoid name conflicts across different files . Syntax static RetType funcName() { // Function body. }; static Instances of Classes Explanation A static instance of a class refers to an object of the class that has static storage duration. It persists for the entire duration of the program (until the program terminates). It is initialized only once , the first time its definition or block is executed . It can be scoped to a function, class, or namespace, depending on where it is declared. In fact, it's a static variable , a static local variable or a static global variable. Syntax static ClassName obj_ptr;","title":"const, constexpr and static"},{"location":"ConstConstexprAndStatic/#const-constexpr-and-static","text":"","title":"const, constexpr and static"},{"location":"ConstConstexprAndStatic/#const","text":"","title":"const"},{"location":"ConstConstexprAndStatic/#explanation","text":"The const keyword is used to declare constants or read-only variables . When a variable is declared as const , its value cannot be modified after it is initialized. This concept is beneficial for protecting data from unintended changes and for enhancing code readability and maintainability . However, it is just a promise that programmers should keep something constant and can be broken .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#usage","text":"","title":"Usage"},{"location":"ConstConstexprAndStatic/#const-variables","text":"","title":"const Variables"},{"location":"ConstConstexprAndStatic/#explanation_1","text":"A const variable is a variable whose value cannot be changed after it has been initialized. The keyword const stands for \"constant\" and is used to define variables that should remain unchanged throughout their lifespan. A const variable must be initialized when it is declared . A const variable can be evaluated at compile time if it is initialized with a constant expression .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax","text":"const Type var_name = value;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-pointers","text":"","title":"const Pointers"},{"location":"ConstConstexprAndStatic/#explanation_2","text":"const Type* pointer_name; means the value pointed to cannot be altered through this pointer. Type* const pointer_name; means the pointer address itself cannot be changed after it is initialized.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_1","text":"Pointer to constant value: const Type* ptr_name; Constant pointer: Type* const ptr_name;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-member-variables","text":"","title":"const Member Variables"},{"location":"ConstConstexprAndStatic/#explanation_3","text":"A const data member must be initialized when the object is constructed because its value cannot be changed after initialization. There are only two way to initialize a const member: In-class initialization : In-class initialization works well for constants of integral types (like int, char, etc.) or other literal types . For non-integral types , initializer lists must be used. It can be overridden by the constructor. Constructor initializer lists .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_2","text":"class ClassName { private: // In-class initialization. const Type _mem = initializer; };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-methods-const-member-functions","text":"","title":"const Methods (const Member Functions)"},{"location":"ConstConstexprAndStatic/#explanation_4","text":"A const member method is a member function of a class that does not modify the object on which it is called. This means the const member function can't modify any non-mutable member variables of the class or object. In addition, a const function can be overloaded with other non-const functions, even if their names and parameter lists are the same. This is possible because their signatures differ, as the const keyword modifies the function signatures . However, if a member is of pointer type, the value or object the pointer points to does not belong to the class . Only the address stored in the pointer belongs to the class . Therefore, a const function can still modify the pointed-to value or object .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_3","text":"RetType funcName( para_list ) const;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-function-parameters","text":"","title":"const Function Parameters"},{"location":"ConstConstexprAndStatic/#explanation_5","text":"A const parameter is a parameter that receives an argument and ensures that the function does not change the argument .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_4","text":"void funcName( const Type para1, ... );","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-return-values","text":"","title":"const Return Values"},{"location":"ConstConstexprAndStatic/#explanation_6","text":"Returning a const value from a function indicates that the returned value cannot be modified by the caller. However, if a const return value is assigned to a non-const variable, it becomes modifiable once the assignment operation is complete.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_5","text":"const RetType funcName( para_list ) { // Function body. };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-return-pointers","text":"","title":"const Return Pointers"},{"location":"ConstConstexprAndStatic/#explanation_7","text":"A function can return a pointer to a constant value , ensuring that the value being pointed to cannot be modified through the pointer. To assign a const return pointer to a variable , the variable must likewise be a pointer to const .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_6","text":"const returnType* funcName() { // Function body };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-return-references","text":"","title":"const Return References"},{"location":"ConstConstexprAndStatic/#explanation_8","text":"A function can return a reference to a constant object , allowing efficient access to the object while ensuring it cannot be modified . To assign a const return reference to a variable , the variable must likewise be a const reference .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_7","text":"const returnType& funcName() { // Function body };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#const-instances-of-classes","text":"","title":"const Instances of Classes"},{"location":"ConstConstexprAndStatic/#explanation_9","text":"A const instance ensures that none of its non-mutable members can be modified after initialization. However, if a member is of pointer type, the value or object the pointer points to does not belong to the class . Only the address stored in the pointer belongs to the class . Therefore, a const instance cannot ensure that this value or object remains unmodified . Only const-qualified member functions can be called on a const instance. These are functions that do not modify the object\u2019s state. A const instance can still modify mutable members .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_8","text":"const ClassName obj_ptr;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#constexpr","text":"","title":"constexpr"},{"location":"ConstConstexprAndStatic/#explanation_10","text":"The constexpr keyword is used to declare variables and functions that can be evaluated at compile-time . This feature allows the compiler to perform calculations and allocate memory for certain constructs even before the program runs. When a variable or function is declared as constexpr , all elements related to it should be evaluated at compile time . For example, the function cannot contain any runtime I/O operations, as they cannot be evaluated at compile time. It enforces that certain values and calculations can be performed at compile-time , leading to significant performance improvements. Any variable or object declared with the constexpr keyword is constant and cannot be modified after it is initialized . It enhances the code readabilit .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#allowed-elements-valid-elements","text":"Constant expressions (e.g., literals, constexpr variables). Simple arithmetic operations. Control flow statements (like if, switch, and loops) that do not depend on runtime values.","title":"Allowed Elements (Valid Elements)"},{"location":"ConstConstexprAndStatic/#disallowed-elements","text":"Runtime I/O operations (e.g., std::cout). Dynamic memory allocation. Non-constexpr function calls (unless those functions are also constexpr ).","title":"Disallowed Elements"},{"location":"ConstConstexprAndStatic/#usage_1","text":"","title":"Usage"},{"location":"ConstConstexprAndStatic/#constexpr-variables","text":"","title":"constexpr Variables"},{"location":"ConstConstexprAndStatic/#explanation_11","text":"A constexpr variable is a variable that must be initialized with an initializer that can be fully resolved at compile-time . The initializer must be evaluated at compile time .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_9","text":"constexpr Type var_name = initializer;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#constexpr-pointers","text":"","title":"constexpr Pointers"},{"location":"ConstConstexprAndStatic/#explanation_12","text":"constexpr applies to the pointer itself , meaning the address stored in the pointer must be a constant expression . The address stored in a constexpr pointer must be known at compile-time .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_10","text":"constexpr Type* var_name = initializer;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#constexpr-member-variables","text":"","title":"constexpr Member Variables"},{"location":"ConstConstexprAndStatic/#explanation_13","text":"A constexpr member variable is a variable defined within a class that can be initialized with constant expressions . This allows them to be evaluated at compile time , which can lead to performance improvements and enable more complex compile-time computations.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_11","text":"class ClassName { public: constexpr Type _mem = initializer; };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#constexpr-functions-constexpr-return-values","text":"","title":"constexpr Functions (constexpr Return Values)"},{"location":"ConstConstexprAndStatic/#explanation_14","text":"A constexpr function is a function that will be evaluated at compile-time if given compile-time constant arguments . If the result of a constexpr function is assigned to a variable, the best choice is to keep the variable as a constexpr variable . This ensures that the variable is initialized at compile time , which means the result of the function is also evaluated at compile time . Additionally, its parameters should be const values or constant expressions to ensure that the function is executed at compile time. RetType must be a literal type , which includes integral types, floating-point types, pointers, and certain user-defined types.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_12","text":"constexpr RetType funcName( para_list ) { // Function body }; constexpr RetType var_name = funcName( para_list );","title":"Syntax"},{"location":"ConstConstexprAndStatic/#constexpr-constructors-c11-and-later","text":"","title":"constexpr Constructors (C++11 and later)"},{"location":"ConstConstexprAndStatic/#explanation_15","text":"A constexpr constructor is a construcotr that can be used to create instances of the class with constant expressions . When a constexpr constructor is used to construct an object, the best choice is to keep the object as a constexpr type , and its initializer should be evaluated at compile time . Only when all related elements can be evaluated at compile time can the constructor also be evaluated at compile time.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_13","text":"class ClassName { public: // Initialize member variables at compile-time. constexpr ClassName( para_list ): ... {}; private: ...; }; constexpr ClassName obj_name( para_list );","title":"Syntax"},{"location":"ConstConstexprAndStatic/#constexpr-instances-of-classes","text":"","title":"constexpr Instances of Classes"},{"location":"ConstConstexprAndStatic/#explanation_16","text":"A constexpr instance is an object that is evaluated at compile-time , if all its dependencies (constructors, functions, and data) are also constexpr . A constexpr instance must remain immutable , meaning its state cannot change after initialization. All data members must be initialized by the constexpr constructor since further modifications are not allowed. The class must have a constexpr constructor . All member functions invoked on a constexpr object must also be constexpr . Data members used in constexpr evaluation must be integral constants or themselves constexpr . A constexpr instance is always const implicitly, but the reverse is not true\u2014 const instances are not guaranteed to be evaluated at compile time.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_14","text":"constexpr ClassName obj_ptr;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#user-defined-literals","text":"","title":"User-defined Literals"},{"location":"ConstConstexprAndStatic/#explanation_17","text":"User-defined literals allow you to create custom literal suffixes that extend the functionality of built-in literals . This feature lets you define special behaviors for literals of various types , including integers, floating-point numbers, and strings. It's especially useful for creating more readable code , adding context or units to values , and improving type safety . User-defined literals are created by defining functions with specific naming and parameter rules . They begin with an underscore and are appended to a literal to convert it into a specific type or to invoke custom logic .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_15","text":"constexpr RetType operator\"\" _name( Type para, ... ) { // Do something that can be evaluated at compile time. return ...; }","title":"Syntax"},{"location":"ConstConstexprAndStatic/#static","text":"","title":"static"},{"location":"ConstConstexprAndStatic/#explanation_18","text":"The static keyword in C++ is used to change the storage duration and visibility of variables and functions. It alters how variables are initialized and where they can be accessed. All static elements are initialized only once and persist until the program terminates . Local variables/objects: It changes their lifetime but does not change their scope. Global variables/objects/function: It does not change their lifetime, but it changes their scope by limiting them to the file where they are defined or declared. Class members variables : It changes their scope and lifetime . static data members are initialized outside the class definition. Class member function : It does not allow them to access non-static members , except for static members.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#usage_2","text":"","title":"Usage"},{"location":"ConstConstexprAndStatic/#static-local-variables","text":"","title":"static Local Variables"},{"location":"ConstConstexprAndStatic/#explanation_19","text":"A static local variable is a static variable declared within a function that maintains its state between function calls . It has local scope , meaning it is only accessible within the function where it is declared . The variable is automatically initialized to zero if not explicitly initialized .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_16","text":"RetType funcName() { // Initialized only once and retains value between calls. static Type count = val; ...; };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#static-global-variables","text":"","title":"static Global Variables"},{"location":"ConstConstexprAndStatic/#explanation_20","text":"A static global variable is declared outside of all functions and is only accessible within the file in which it is declared, preventing name conflicts in other files . The variable is automatically initialized to zero if not explicitly initialized .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_17","text":"static Type var_name;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#static-member-variables","text":"","title":"static Member Variables"},{"location":"ConstConstexprAndStatic/#explanation_21","text":"static members of a class belong to the class itself rather than any object instance and can be accessed without an instance . static members are shared among all instances of that class . They are accessed using the class name instead of the object name. static keyword only changes their lifetime ; it does not affect their visibility . We should define or initialize it outside the class . In fact, static members are static variables defined within a namespace .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_18","text":"class ClassName { public: // Declaration of a static public class member. static Type1 _staticMember1; private: // Declaration of a static private class member. static Type2 _staticMember2;}; // Providing definition and initialization for the static member. Type1 ClassName::_staticMember1 = 0; Type2 ClassName::_staticMember2 = 0;","title":"Syntax"},{"location":"ConstConstexprAndStatic/#static-methods-static-member-functions","text":"","title":"static Methods (static Member Functions)"},{"location":"ConstConstexprAndStatic/#explanation_22","text":"A static member function is a function defined within a class that can be called without creating an instance of the class. It cannot access instance variables or instance methods directly, since it does not have a this pointer. This means it can only access static data members or other static member functions within the class. It can be called using the class name .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_19","text":"class ClassName { public: static RetType funcName( para_list ) { // Function body. }; }; RetType var_name = ClassName::funcName( para_list );","title":"Syntax"},{"location":"ConstConstexprAndStatic/#static-global-functions","text":"","title":"static Global Functions"},{"location":"ConstConstexprAndStatic/#explanation_23","text":"A static global function is a function limited in visibility to the file where it is defined, which helps to avoid name conflicts across different files .","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_20","text":"static RetType funcName() { // Function body. };","title":"Syntax"},{"location":"ConstConstexprAndStatic/#static-instances-of-classes","text":"","title":"static Instances of Classes"},{"location":"ConstConstexprAndStatic/#explanation_24","text":"A static instance of a class refers to an object of the class that has static storage duration. It persists for the entire duration of the program (until the program terminates). It is initialized only once , the first time its definition or block is executed . It can be scoped to a function, class, or namespace, depending on where it is declared. In fact, it's a static variable , a static local variable or a static global variable.","title":"Explanation"},{"location":"ConstConstexprAndStatic/#syntax_21","text":"static ClassName obj_ptr;","title":"Syntax"},{"location":"ConversionAndCasting/","text":"Conversion and Casting Explanation Implicit Conversion Explanation Examples Explicit Conversion (Type Casting) Explanation C-style Casting (Recommend for Performance) Explanation Syntax C++-style Casting (Recommend for Safety) Explanation static_cast (Recommend for Safety and Performance) Explanation Syntax Usage Limitations Requirements for Using static_cast dynamic_cast (Recommend for Safety but Not Recommend for Performance) Explanation Syntax Usage Limitations Requirements for Using dynamic_cast const_cast (Recommend for Safety but Not Recommend for Performance) Explanation Syntax Usage reinterpret_cast (Recommend for Performance but Not Recommend for Safety) Explanation Syntax Usage Requirements for Using reinterpret_cast Notes explicit Explanation Syntax std::bit_cast (Recommended for Safety, Performance and Type Integrity) Explanation Syntax Usage Requirements for Using std::bit_cast Differences between std::bit_cast and reinterpret_cast Safety and Type Checking std::bit_cast : reinterpret_cast : Intent and Purpose std::bit_cast : reinterpret_cast : Performance std::bit_cast : reinterpret_cast : Requirements for Usage std::bit_cast : reinterpret_cast : Upcasting and Downcasting Explanation Upcasting Downcasting Notes Conversion and Casting Explanation In C++, conversion and casting refer to the mechanisms used to convert a value from one data type to another . Conversion can occur implicitly or explicitly . Implicit conversion , also known as type coercion , happens automatically when the compiler converts one data type to another without requiring explicit instructions from the programmer. In contrast, explicit conversion requires the programmer to define the conversion process , which can be accomplished through various casting methods. Conversion and casting can impact performance , especially in performance-critical applications. When a conversion occurs between two types, the impact on performance depends on how difficult it is to operate on those types . For example, converting between int and float can impact performance because operations on float are generally slower. However, converting between int and unsigned int does not typically have a significant performance impact, as both are integer types. Implicit Conversion Explanation Implicit conversion occurs when the compiler automatically converts a value from one type to another , usually in situations involving mixed-type expressions. It is only allowed to happen once and happens automatically . The compiler ensures that the conversion is valid and safe . However, implicit conversions can sometimes lead to unexpected behavior , especially if there\u2019s data loss (e.g., converting a double to an int might lose the fractional part). When an object is copied using the assignment operator , if the source object is of a different type , implicit conversion may occur, invoking the assignment operator overload and potentially a constructor . Examples class B { public: explicit B( Type mem ): _mem( mem ){}; Type _mem; }; class A { public: A(): _mem( initializer1 ) {}; // Constructor for implicit conversion. A( const B& b ): _mem( b._mem ) {}; // Assignment operator overload. A& operator=( const B& b ) { _mem = b._mem; return *this; }; // Assignment operator overload. A& operator=( const A& other ) = default; Type _mem; }; int main() { A a; // Default A. B b( initializer2 ); // B initialized with an initializer2. // Only A's assignment operator are invoked. In fact, it's also a implicit conversion. a = b; }; class B { public: explicit B( Type mem ): _mem( mem ){}; Type _mem; }; class A { public: A(): _mem( initializer1 ) {}; // Constructor for implicit conversion. A( const B& b ): _mem( b._mem ) {}; // Assignment operator overload. A& operator=( const A& other ) = default; Type _mem; }; int main() { A a; // Default A. B b( initializer2 ); // B initialized with an initializer2. // First, implicit conversion: A's conversion constructor is invoked. // Second, assignment: A's default assignement operator is invoked. a = b; }; Explicit Conversion (Type Casting) Explanation Explicit conversion , or type casting , allows programmers to define how a value should be converted from one type to another . This is crucial in scenarios where implicit conversion may lead to data loss or unintended behavior. However, there\u2019s no guarantee that the conversion is safe , and programmers must ensure the correctness . C-style Casting (Recommend for Performance) Explanation C-style casting uses the syntax (Type)initializer to convert a variable or a value to the desired type. While this method is straightforward , it can be ambiguous and may lead to unexpected results since it can invoke multiple conversion methods , including static_cast , dynamic_cast , const_cast , and reinterpret_cast , depending on the context. In addition, the compiler may not optimize C-style casts as effectively since they lack explicit intent , making it harder for the compiler to understand what type conversions are valid. Syntax ( TargetType )initializer; C++-style Casting (Recommend for Safety) Explanation C++ introduced several specific casting operators to provide more clarity and safety in type conversion. These are static_cast , dynamic_cast , const_cast , and reinterpret_cast . These four casts do not introduce any new functionality to C++. All of them can be implemented using C-style casting . They merely clarify the intent behind the cast. static_cast (Recommend for Safety and Performance) Explanation static_cast is used for safe, compile-time type conversion . It can be used for well-defined conversions between related types , such as upcasting and downcasting in inheritance hierarchies , without runtime checks . It is safer than C-style casting but still requires caution , especially during downcasting . This cast involves compile-time checks and is generally efficient , as it can be optimized by the compiler. Syntax static_cast< TargetType >( initializer ); Usage Primitive type conversion. Pointer type conversion within inheritance. Converting void pointer to another pointer type. All implicit conversions. Limitations Cannot cast between incompatible types : It only works with related types. For example, you cannot use static_cast to convert an unrelated class to another. No runtime type safety : If static_cast is used to downcast in an inheritance hierarchy , it won't check the actual type at runtime . This can lead to undefined behavior if the object isn't of the expected type. Not for casting between pointers and non-pointers : You cannot cast between objects and pointers (e.g., from an integer to a pointer) with static_cast . For such conversions, reinterpret_cast is required. No removal of const or volatile qualifiers: static_cast cannot add or remove const or volatile qualifiers . Use const_cast for this purpose. Requirements for Using static_cast Types must be compatible : The conversion must make sense in the context of the C++ type system (e.g., converting between base and derived classes, or between numeric types). Inheritance hierarchy : You can only cast pointers or references within the same class hierarchy (i.e., between base and derived classes). Known at compile time : The conversion must be determined at compile time, as static_cast does not involve any runtime checks. dynamic_cast (Recommend for Safety but Not Recommend for Performance) Explanation dynamic_cast is designed for safe, runtime-checked downcasting in polymorphic hierarchies . It ensures that the cast is valid at runtime , making it the safest option for casting within class hierarchies. If the cast is unsuccessful , it returns nullptr (for pointers) or throws an exception (for references, std::bad_cast ) , thus enhancing type safety. However, this added safety can result in slower performance compared to static_cast . The runtime check in dynamic_cast is implemented using the Run-Time Type Information (RTTI) mechanism in C++, which includes type information and the virtual table (vtable) . Its downcasting workflow involves RTTI lookup , hierarchy traversal , and pointer adjustment . dynamic_cast requires at least one virtual function . Because it slows down performance, we can use a macro to determine whether to use it in debug mode or release mode . Last, we should check if RTTI is enabled in our compiler. (GCC/G++ enables it by default, while MSVC does not.) Syntax dynamic_cast< TargetType >( initializer ); Usage Safe downcasting with pointers: CPP class Base { public: virtual Type funcName(){ ... }; virtual ~Base()= default; }; class Derived: public Base { ... }; int main() { Base* base_ptr = new Derived(); Derived* der_ptr = dynamic_cast< Derived* >( base_ptr ); if( !der_ptr ) { std::cout << \"Failed to cast to Derived.\" << std::endl; return 0; }; }; Downcasting with references: CPP class Base { public: virtual Type funcName(){ ... }; virtual ~Base() = default; }; class Derived: public Base { ... }; int main() { Base base; // Not a Derived instance. try { // This will throw `std::bad_cast` because base is not of type Derived. Derived& der_ref = dynamic_cast< Derived& >( base ); } catch( const std::bad_cast& e ) { std::cout << \"Caught exception: \" << e.what() << '\\n'; }; }; Limitations Polymorphic base class required: dynamic_cast only works if the base class has at least one virtual function (typically a virtual destructor). Slight performance overhead : Since dynamic_cast performs runtime type checking, it is slower than static_cast , especially in complex class hierarchies. Works only on pointers and references : You cannot use dynamic_cast on regular objects. It only works on pointers or references. Downcast safety depends on runtime type: If the object isn't of the expected type, the cast will either return nullptr (for pointers) or throw a std::bad_cast exception (for references) . Requires RTTI (Run-Time Type Information) : RTTI must be enabled in the compiler (it\u2019s usually enabled by default). If RTTI is disabled, dynamic_cast will not work. Requirements for Using dynamic_cast Polymorphic base class: The base class involved in the cast must contain at least one virtual function , typically a virtual destructor. Pointer or reference types: dynamic_cast can only be used to cast pointers or references \u2014it won't work for normal values. Valid object type at runtime : For downcasting, the object at runtime must match the derived type you're casting to; otherwise, the cast fails. const_cast (Recommend for Safety but Not Recommend for Performance) Explanation const_cast is used for adding or removing const or volatile qualifiers from a pointer or reference . It should be used sparingly and only when necessary , as misuse can easily lead to undefined behavior . This cast involves compile-time checks and typically incurs minimal performance overhead since it only modifies type qualifiers without altering the underlying object. const_cast only adds or removes the const or volatile qualifiers ; it doesn\u2019t convert between unrelated types . Syntax const_cast< TargetType >( initializer ); Usage Removing const to modify a non-const object. Adding or removing volatile . reinterpret_cast (Recommend for Performance but Not Recommend for Safety) Explanation reinterpret_cast is intended for low-level reinterpretation of an object\u2019s bit pattern, which allows conversion between incompatible types . It is the most powerful and dangerous cast , used in situations where other casts are insufficient. This cast does not check type compatibility and can lead to undefined behavior if misused , so it should be used with caution. While it can achieve results similar to type punning , it comes with significant caveats regarding safety and portability . Its performance is generally comparable to C-style casting , as it does not perform any type checks and simply reinterprets the bits. Bit patterns refer to interpreting data as binary values and considering how many bytes it occupies. Syntax reinterpret_cast< TargetType >( initializer ); Usage Pointer type conversions: It is commonly used to convert one pointer type to another, even between unrelated types. Reference type conversions: Similar to pointers, reinterpret_cast can convert one reference type to another. This allows for casting references of different types, but care must be taken to ensure the underlying object types are compatible. Casting between pointer and integer types : It can be used to cast pointers to integral types (e.g., uintptr_t ) and vice versa. The integral types must be either a 32-bit unsigned or a 64-bit unsigned type , depending on the system architecture. Interfacing with hardware or system-level code : Useful in systems programming or when dealing with low-level constructs, such as when interfacing with hardware or legacy C libraries. Requirements for Using reinterpret_cast Pointer or reference Types: The expression being cast must be a pointer or reference type. Correctness of the cast: Ensure that the object being accessed through the cast pointer is compatible with the target type. Avoid using reinterpret_cast on pointers of unrelated types unless you are sure of what you are doing. Notes We recommend adopting C++-style casting for new projects , smaller codebases , or if you are new to C++ , as it offers a safer alternative. It is essential to understand whether a particular cast involves runtime or compile-time checks . The distinct naming of these casts enhances code readability and facilitates easy identification during code searches . (Search for their names to identify where explicit conversions occur.) When converting a void pointer type to a specific pointer type (or vice versa) , static_cast is the preferred choice . It is best used for casting between void pointer type and other pointer types, provided there\u2019s no need for low-level reinterpretation. explicit Explanation The explicit keyword in C++ is used to prevent implicit conversions when defining constructors or conversion operators . By marking a constructor as explicit , you ensure that it can only be called with a direct initialization, thus avoiding unintended conversions that might lead to errors. This feature enhances type safety and code readability by making the programmer's intentions clear. Syntax explicit ConstructorName( para_list ); // Conversion operator. // `const` function. explicit operator TargetType() const { // Custom conversion logic here. }; std::bit_cast (Recommended for Safety, Performance and Type Integrity) Explanation std::bit_cast is designed for safe reinterpretation of an object\u2019s bit pattern , allowing conversion between types of the same size . It provides a type-safe mechanism for casting, ensuring that the sizes of the source and target types are equal at compile time . This function is less risky than reinterpret_cast , as it prevents undefined behavior that can arise from size mismatches or type incompatibility. std::bit_cast is ideal for type punning while maintaining safety and portability, making it a preferable choice for most use cases. The performance is comparable to reinterpret_cast , as it also does not incur overhead from type checking, but it provides stronger guarantees about correctness. Bit patterns refer to interpreting data as binary values and considering how many bytes it occupies , with std::bit_cast ensuring the integrity of those bits. Syntax // Declaration syntax. template< typename To, typename From > constexpr To std::bit_cast( const From& src ); // Usage syntax. std::bit_cast< TargetType >( initializer ); Usage Reinterpreting fundamental types : Commonly used to reinterpret bit patterns between types like integers and floating-point numbers . Casting structs or classes : Can be used to cast complex types like structs or classes to and from byte arrays or other types , ensuring the bit representation is preserved. Safe type punning : Useful in scenarios where you need to access the underlying bit representation of an object without risking undefined behavior. Requirements for Using std::bit_cast Sametsize types: The source and target types must be of the same size ; otherwise , a compile-time error will occur . Type compatibility: While std::bit_cast does not require types to be related , it is crucial to ensure the types make sense for the intended interpretation of the data. Constexpr support : It can be used in constant expressions , making it suitable for scenarios that require compile-time evaluations . Differences between std::bit_cast and reinterpret_cast Safety and Type Checking std::bit_cast : Type safety: std::bit_cast ensures that the source and destination types are the same size at compile time . If they are not , it will result in a compilation error . Undefined behavior: It avoids undefined behavior by enforcing size constraints and ensuring that both types can be safely represented with the same number of bits. reinterpret_cast : Type safety: reinterpret_cast does not perform any compile-time checks on size or type compatibility. It allows for casting between unrelated types , which can lead to undefined behavior if misused . Undefined behavior: If you attempt to access the bits of the reinterpreted type and the sizes are not compatible , it can result in undefined behavior . Intent and Purpose std::bit_cast : Intent: The primary intent of std::bit_cast is to safely reinterpret the bit representation of an object without modifying its underlying data . It is used when you want to change the type of the object while preserving its bit pattern. Use cases: It is suitable for scenarios like converting between integer types and floating-point types or safely casting structs to byte arrays . reinterpret_cast : Intent: reinterpret_cast is used for low-level, potentially unsafe type conversions . It conveys a need for flexibility in converting between pointer types, reference types, or even between pointers and integers . Use cases: Commonly used in systems programming , interfacing with hardware , or when interacting with legacy C libraries where type safety is not a priority. Performance std::bit_cast : Performance: It has performance characteristics similar to reinterpret_cast , as it does not incur the overhead of type checks at runtime. However, it provides stronger guarantees regarding type safety. reinterpret_cast : Performance: Its performance is generally comparable to C-style casting , as it performs no safety checks and directly reinterprets the bits. Requirements for Usage std::bit_cast : Same size : The source and target types must be of the same size. constexpr support: Can be used in constant expressions . reinterpret_cast : Pointer or reference types: The expression being cast must be a pointer or reference type . Correctness of the cast : Users must ensure that the object being accessed through the cast pointer is compatible with the target type. Upcasting and Downcasting Explanation Upcasting and downcasting are terms used to describe type conversions within an inheritance hierarchy (i.e., between a base class and its derived classes). These casts typically involve pointer or reference conversions . Upcasting Upcasting refers to casting a derived class object to a base class type . This conversion is safe and performed implicitly or explicitly using static_cast . Since the derived class contains all the members of the base class, the cast will always succeed. Base class members will be accessible , but derived class-specific members will be hidden unless the base class method is marked as virtual (allowing for polymorphism). Downcasting Downcasting refers to casting a base class object to a derived class type . This is potentially unsafe , as the base class might not actually be an instance of the derived class. Therefore, dynamic_cast should be used when performing downcasting to ensure runtime type safety. dynamic_cast should be used for downcasting when you are unsure if the base pointer refers to an instance of the derived class. Notes Learning this topic through practice rather than theory.","title":"Conversion And Casting"},{"location":"ConversionAndCasting/#conversion-and-casting","text":"","title":"Conversion and Casting"},{"location":"ConversionAndCasting/#explanation","text":"In C++, conversion and casting refer to the mechanisms used to convert a value from one data type to another . Conversion can occur implicitly or explicitly . Implicit conversion , also known as type coercion , happens automatically when the compiler converts one data type to another without requiring explicit instructions from the programmer. In contrast, explicit conversion requires the programmer to define the conversion process , which can be accomplished through various casting methods. Conversion and casting can impact performance , especially in performance-critical applications. When a conversion occurs between two types, the impact on performance depends on how difficult it is to operate on those types . For example, converting between int and float can impact performance because operations on float are generally slower. However, converting between int and unsigned int does not typically have a significant performance impact, as both are integer types.","title":"Explanation"},{"location":"ConversionAndCasting/#implicit-conversion","text":"","title":"Implicit Conversion"},{"location":"ConversionAndCasting/#explanation_1","text":"Implicit conversion occurs when the compiler automatically converts a value from one type to another , usually in situations involving mixed-type expressions. It is only allowed to happen once and happens automatically . The compiler ensures that the conversion is valid and safe . However, implicit conversions can sometimes lead to unexpected behavior , especially if there\u2019s data loss (e.g., converting a double to an int might lose the fractional part). When an object is copied using the assignment operator , if the source object is of a different type , implicit conversion may occur, invoking the assignment operator overload and potentially a constructor .","title":"Explanation"},{"location":"ConversionAndCasting/#examples","text":"class B { public: explicit B( Type mem ): _mem( mem ){}; Type _mem; }; class A { public: A(): _mem( initializer1 ) {}; // Constructor for implicit conversion. A( const B& b ): _mem( b._mem ) {}; // Assignment operator overload. A& operator=( const B& b ) { _mem = b._mem; return *this; }; // Assignment operator overload. A& operator=( const A& other ) = default; Type _mem; }; int main() { A a; // Default A. B b( initializer2 ); // B initialized with an initializer2. // Only A's assignment operator are invoked. In fact, it's also a implicit conversion. a = b; }; class B { public: explicit B( Type mem ): _mem( mem ){}; Type _mem; }; class A { public: A(): _mem( initializer1 ) {}; // Constructor for implicit conversion. A( const B& b ): _mem( b._mem ) {}; // Assignment operator overload. A& operator=( const A& other ) = default; Type _mem; }; int main() { A a; // Default A. B b( initializer2 ); // B initialized with an initializer2. // First, implicit conversion: A's conversion constructor is invoked. // Second, assignment: A's default assignement operator is invoked. a = b; };","title":"Examples"},{"location":"ConversionAndCasting/#explicit-conversion-type-casting","text":"","title":"Explicit Conversion (Type Casting)"},{"location":"ConversionAndCasting/#explanation_2","text":"Explicit conversion , or type casting , allows programmers to define how a value should be converted from one type to another . This is crucial in scenarios where implicit conversion may lead to data loss or unintended behavior. However, there\u2019s no guarantee that the conversion is safe , and programmers must ensure the correctness .","title":"Explanation"},{"location":"ConversionAndCasting/#c-style-casting-recommend-for-performance","text":"","title":"C-style Casting (Recommend for Performance)"},{"location":"ConversionAndCasting/#explanation_3","text":"C-style casting uses the syntax (Type)initializer to convert a variable or a value to the desired type. While this method is straightforward , it can be ambiguous and may lead to unexpected results since it can invoke multiple conversion methods , including static_cast , dynamic_cast , const_cast , and reinterpret_cast , depending on the context. In addition, the compiler may not optimize C-style casts as effectively since they lack explicit intent , making it harder for the compiler to understand what type conversions are valid.","title":"Explanation"},{"location":"ConversionAndCasting/#syntax","text":"( TargetType )initializer;","title":"Syntax"},{"location":"ConversionAndCasting/#c-style-casting-recommend-for-safety","text":"","title":"C++-style Casting (Recommend for Safety)"},{"location":"ConversionAndCasting/#explanation_4","text":"C++ introduced several specific casting operators to provide more clarity and safety in type conversion. These are static_cast , dynamic_cast , const_cast , and reinterpret_cast . These four casts do not introduce any new functionality to C++. All of them can be implemented using C-style casting . They merely clarify the intent behind the cast.","title":"Explanation"},{"location":"ConversionAndCasting/#static_cast-recommend-for-safety-and-performance","text":"","title":"static_cast (Recommend for Safety and Performance)"},{"location":"ConversionAndCasting/#explanation_5","text":"static_cast is used for safe, compile-time type conversion . It can be used for well-defined conversions between related types , such as upcasting and downcasting in inheritance hierarchies , without runtime checks . It is safer than C-style casting but still requires caution , especially during downcasting . This cast involves compile-time checks and is generally efficient , as it can be optimized by the compiler.","title":"Explanation"},{"location":"ConversionAndCasting/#syntax_1","text":"static_cast< TargetType >( initializer );","title":"Syntax"},{"location":"ConversionAndCasting/#usage","text":"Primitive type conversion. Pointer type conversion within inheritance. Converting void pointer to another pointer type. All implicit conversions.","title":"Usage"},{"location":"ConversionAndCasting/#limitations","text":"Cannot cast between incompatible types : It only works with related types. For example, you cannot use static_cast to convert an unrelated class to another. No runtime type safety : If static_cast is used to downcast in an inheritance hierarchy , it won't check the actual type at runtime . This can lead to undefined behavior if the object isn't of the expected type. Not for casting between pointers and non-pointers : You cannot cast between objects and pointers (e.g., from an integer to a pointer) with static_cast . For such conversions, reinterpret_cast is required. No removal of const or volatile qualifiers: static_cast cannot add or remove const or volatile qualifiers . Use const_cast for this purpose.","title":"Limitations"},{"location":"ConversionAndCasting/#requirements-for-using-static_cast","text":"Types must be compatible : The conversion must make sense in the context of the C++ type system (e.g., converting between base and derived classes, or between numeric types). Inheritance hierarchy : You can only cast pointers or references within the same class hierarchy (i.e., between base and derived classes). Known at compile time : The conversion must be determined at compile time, as static_cast does not involve any runtime checks.","title":"Requirements for Using static_cast"},{"location":"ConversionAndCasting/#dynamic_cast-recommend-for-safety-but-not-recommend-for-performance","text":"","title":"dynamic_cast (Recommend for Safety but Not Recommend for Performance)"},{"location":"ConversionAndCasting/#explanation_6","text":"dynamic_cast is designed for safe, runtime-checked downcasting in polymorphic hierarchies . It ensures that the cast is valid at runtime , making it the safest option for casting within class hierarchies. If the cast is unsuccessful , it returns nullptr (for pointers) or throws an exception (for references, std::bad_cast ) , thus enhancing type safety. However, this added safety can result in slower performance compared to static_cast . The runtime check in dynamic_cast is implemented using the Run-Time Type Information (RTTI) mechanism in C++, which includes type information and the virtual table (vtable) . Its downcasting workflow involves RTTI lookup , hierarchy traversal , and pointer adjustment . dynamic_cast requires at least one virtual function . Because it slows down performance, we can use a macro to determine whether to use it in debug mode or release mode . Last, we should check if RTTI is enabled in our compiler. (GCC/G++ enables it by default, while MSVC does not.)","title":"Explanation"},{"location":"ConversionAndCasting/#syntax_2","text":"dynamic_cast< TargetType >( initializer );","title":"Syntax"},{"location":"ConversionAndCasting/#usage_1","text":"Safe downcasting with pointers: CPP class Base { public: virtual Type funcName(){ ... }; virtual ~Base()= default; }; class Derived: public Base { ... }; int main() { Base* base_ptr = new Derived(); Derived* der_ptr = dynamic_cast< Derived* >( base_ptr ); if( !der_ptr ) { std::cout << \"Failed to cast to Derived.\" << std::endl; return 0; }; }; Downcasting with references: CPP class Base { public: virtual Type funcName(){ ... }; virtual ~Base() = default; }; class Derived: public Base { ... }; int main() { Base base; // Not a Derived instance. try { // This will throw `std::bad_cast` because base is not of type Derived. Derived& der_ref = dynamic_cast< Derived& >( base ); } catch( const std::bad_cast& e ) { std::cout << \"Caught exception: \" << e.what() << '\\n'; }; };","title":"Usage"},{"location":"ConversionAndCasting/#limitations_1","text":"Polymorphic base class required: dynamic_cast only works if the base class has at least one virtual function (typically a virtual destructor). Slight performance overhead : Since dynamic_cast performs runtime type checking, it is slower than static_cast , especially in complex class hierarchies. Works only on pointers and references : You cannot use dynamic_cast on regular objects. It only works on pointers or references. Downcast safety depends on runtime type: If the object isn't of the expected type, the cast will either return nullptr (for pointers) or throw a std::bad_cast exception (for references) . Requires RTTI (Run-Time Type Information) : RTTI must be enabled in the compiler (it\u2019s usually enabled by default). If RTTI is disabled, dynamic_cast will not work.","title":"Limitations"},{"location":"ConversionAndCasting/#requirements-for-using-dynamic_cast","text":"Polymorphic base class: The base class involved in the cast must contain at least one virtual function , typically a virtual destructor. Pointer or reference types: dynamic_cast can only be used to cast pointers or references \u2014it won't work for normal values. Valid object type at runtime : For downcasting, the object at runtime must match the derived type you're casting to; otherwise, the cast fails.","title":"Requirements for Using dynamic_cast"},{"location":"ConversionAndCasting/#const_cast-recommend-for-safety-but-not-recommend-for-performance","text":"","title":"const_cast (Recommend for Safety but Not Recommend for Performance)"},{"location":"ConversionAndCasting/#explanation_7","text":"const_cast is used for adding or removing const or volatile qualifiers from a pointer or reference . It should be used sparingly and only when necessary , as misuse can easily lead to undefined behavior . This cast involves compile-time checks and typically incurs minimal performance overhead since it only modifies type qualifiers without altering the underlying object. const_cast only adds or removes the const or volatile qualifiers ; it doesn\u2019t convert between unrelated types .","title":"Explanation"},{"location":"ConversionAndCasting/#syntax_3","text":"const_cast< TargetType >( initializer );","title":"Syntax"},{"location":"ConversionAndCasting/#usage_2","text":"Removing const to modify a non-const object. Adding or removing volatile .","title":"Usage"},{"location":"ConversionAndCasting/#reinterpret_cast-recommend-for-performance-but-not-recommend-for-safety","text":"","title":"reinterpret_cast (Recommend for Performance but Not Recommend for Safety)"},{"location":"ConversionAndCasting/#explanation_8","text":"reinterpret_cast is intended for low-level reinterpretation of an object\u2019s bit pattern, which allows conversion between incompatible types . It is the most powerful and dangerous cast , used in situations where other casts are insufficient. This cast does not check type compatibility and can lead to undefined behavior if misused , so it should be used with caution. While it can achieve results similar to type punning , it comes with significant caveats regarding safety and portability . Its performance is generally comparable to C-style casting , as it does not perform any type checks and simply reinterprets the bits. Bit patterns refer to interpreting data as binary values and considering how many bytes it occupies.","title":"Explanation"},{"location":"ConversionAndCasting/#syntax_4","text":"reinterpret_cast< TargetType >( initializer );","title":"Syntax"},{"location":"ConversionAndCasting/#usage_3","text":"Pointer type conversions: It is commonly used to convert one pointer type to another, even between unrelated types. Reference type conversions: Similar to pointers, reinterpret_cast can convert one reference type to another. This allows for casting references of different types, but care must be taken to ensure the underlying object types are compatible. Casting between pointer and integer types : It can be used to cast pointers to integral types (e.g., uintptr_t ) and vice versa. The integral types must be either a 32-bit unsigned or a 64-bit unsigned type , depending on the system architecture. Interfacing with hardware or system-level code : Useful in systems programming or when dealing with low-level constructs, such as when interfacing with hardware or legacy C libraries.","title":"Usage"},{"location":"ConversionAndCasting/#requirements-for-using-reinterpret_cast","text":"Pointer or reference Types: The expression being cast must be a pointer or reference type. Correctness of the cast: Ensure that the object being accessed through the cast pointer is compatible with the target type. Avoid using reinterpret_cast on pointers of unrelated types unless you are sure of what you are doing.","title":"Requirements for Using reinterpret_cast"},{"location":"ConversionAndCasting/#notes","text":"We recommend adopting C++-style casting for new projects , smaller codebases , or if you are new to C++ , as it offers a safer alternative. It is essential to understand whether a particular cast involves runtime or compile-time checks . The distinct naming of these casts enhances code readability and facilitates easy identification during code searches . (Search for their names to identify where explicit conversions occur.) When converting a void pointer type to a specific pointer type (or vice versa) , static_cast is the preferred choice . It is best used for casting between void pointer type and other pointer types, provided there\u2019s no need for low-level reinterpretation.","title":"Notes"},{"location":"ConversionAndCasting/#explicit","text":"","title":"explicit"},{"location":"ConversionAndCasting/#explanation_9","text":"The explicit keyword in C++ is used to prevent implicit conversions when defining constructors or conversion operators . By marking a constructor as explicit , you ensure that it can only be called with a direct initialization, thus avoiding unintended conversions that might lead to errors. This feature enhances type safety and code readability by making the programmer's intentions clear.","title":"Explanation"},{"location":"ConversionAndCasting/#syntax_5","text":"explicit ConstructorName( para_list ); // Conversion operator. // `const` function. explicit operator TargetType() const { // Custom conversion logic here. };","title":"Syntax"},{"location":"ConversionAndCasting/#stdbit_cast-recommended-for-safety-performance-and-type-integrity","text":"","title":"std::bit_cast (Recommended for Safety, Performance and Type Integrity)"},{"location":"ConversionAndCasting/#explanation_10","text":"std::bit_cast is designed for safe reinterpretation of an object\u2019s bit pattern , allowing conversion between types of the same size . It provides a type-safe mechanism for casting, ensuring that the sizes of the source and target types are equal at compile time . This function is less risky than reinterpret_cast , as it prevents undefined behavior that can arise from size mismatches or type incompatibility. std::bit_cast is ideal for type punning while maintaining safety and portability, making it a preferable choice for most use cases. The performance is comparable to reinterpret_cast , as it also does not incur overhead from type checking, but it provides stronger guarantees about correctness. Bit patterns refer to interpreting data as binary values and considering how many bytes it occupies , with std::bit_cast ensuring the integrity of those bits.","title":"Explanation"},{"location":"ConversionAndCasting/#syntax_6","text":"// Declaration syntax. template< typename To, typename From > constexpr To std::bit_cast( const From& src ); // Usage syntax. std::bit_cast< TargetType >( initializer );","title":"Syntax"},{"location":"ConversionAndCasting/#usage_4","text":"Reinterpreting fundamental types : Commonly used to reinterpret bit patterns between types like integers and floating-point numbers . Casting structs or classes : Can be used to cast complex types like structs or classes to and from byte arrays or other types , ensuring the bit representation is preserved. Safe type punning : Useful in scenarios where you need to access the underlying bit representation of an object without risking undefined behavior.","title":"Usage"},{"location":"ConversionAndCasting/#requirements-for-using-stdbit_cast","text":"Sametsize types: The source and target types must be of the same size ; otherwise , a compile-time error will occur . Type compatibility: While std::bit_cast does not require types to be related , it is crucial to ensure the types make sense for the intended interpretation of the data. Constexpr support : It can be used in constant expressions , making it suitable for scenarios that require compile-time evaluations .","title":"Requirements for Using std::bit_cast"},{"location":"ConversionAndCasting/#differences-between-stdbit_cast-and-reinterpret_cast","text":"","title":"Differences between std::bit_cast and reinterpret_cast"},{"location":"ConversionAndCasting/#safety-and-type-checking","text":"","title":"Safety and Type Checking"},{"location":"ConversionAndCasting/#stdbit_cast","text":"Type safety: std::bit_cast ensures that the source and destination types are the same size at compile time . If they are not , it will result in a compilation error . Undefined behavior: It avoids undefined behavior by enforcing size constraints and ensuring that both types can be safely represented with the same number of bits.","title":"std::bit_cast:"},{"location":"ConversionAndCasting/#reinterpret_cast","text":"Type safety: reinterpret_cast does not perform any compile-time checks on size or type compatibility. It allows for casting between unrelated types , which can lead to undefined behavior if misused . Undefined behavior: If you attempt to access the bits of the reinterpreted type and the sizes are not compatible , it can result in undefined behavior .","title":"reinterpret_cast:"},{"location":"ConversionAndCasting/#intent-and-purpose","text":"","title":"Intent and Purpose"},{"location":"ConversionAndCasting/#stdbit_cast_1","text":"Intent: The primary intent of std::bit_cast is to safely reinterpret the bit representation of an object without modifying its underlying data . It is used when you want to change the type of the object while preserving its bit pattern. Use cases: It is suitable for scenarios like converting between integer types and floating-point types or safely casting structs to byte arrays .","title":"std::bit_cast:"},{"location":"ConversionAndCasting/#reinterpret_cast_1","text":"Intent: reinterpret_cast is used for low-level, potentially unsafe type conversions . It conveys a need for flexibility in converting between pointer types, reference types, or even between pointers and integers . Use cases: Commonly used in systems programming , interfacing with hardware , or when interacting with legacy C libraries where type safety is not a priority.","title":"reinterpret_cast:"},{"location":"ConversionAndCasting/#performance","text":"","title":"Performance"},{"location":"ConversionAndCasting/#stdbit_cast_2","text":"Performance: It has performance characteristics similar to reinterpret_cast , as it does not incur the overhead of type checks at runtime. However, it provides stronger guarantees regarding type safety.","title":"std::bit_cast:"},{"location":"ConversionAndCasting/#reinterpret_cast_2","text":"Performance: Its performance is generally comparable to C-style casting , as it performs no safety checks and directly reinterprets the bits.","title":"reinterpret_cast:"},{"location":"ConversionAndCasting/#requirements-for-usage","text":"","title":"Requirements for Usage"},{"location":"ConversionAndCasting/#stdbit_cast_3","text":"Same size : The source and target types must be of the same size. constexpr support: Can be used in constant expressions .","title":"std::bit_cast:"},{"location":"ConversionAndCasting/#reinterpret_cast_3","text":"Pointer or reference types: The expression being cast must be a pointer or reference type . Correctness of the cast : Users must ensure that the object being accessed through the cast pointer is compatible with the target type.","title":"reinterpret_cast:"},{"location":"ConversionAndCasting/#upcasting-and-downcasting","text":"","title":"Upcasting and Downcasting"},{"location":"ConversionAndCasting/#explanation_11","text":"Upcasting and downcasting are terms used to describe type conversions within an inheritance hierarchy (i.e., between a base class and its derived classes). These casts typically involve pointer or reference conversions .","title":"Explanation"},{"location":"ConversionAndCasting/#upcasting","text":"Upcasting refers to casting a derived class object to a base class type . This conversion is safe and performed implicitly or explicitly using static_cast . Since the derived class contains all the members of the base class, the cast will always succeed. Base class members will be accessible , but derived class-specific members will be hidden unless the base class method is marked as virtual (allowing for polymorphism).","title":"Upcasting"},{"location":"ConversionAndCasting/#downcasting","text":"Downcasting refers to casting a base class object to a derived class type . This is potentially unsafe , as the base class might not actually be an instance of the derived class. Therefore, dynamic_cast should be used when performing downcasting to ensure runtime type safety. dynamic_cast should be used for downcasting when you are unsure if the base pointer refers to an instance of the derived class.","title":"Downcasting"},{"location":"ConversionAndCasting/#notes_1","text":"Learning this topic through practice rather than theory.","title":"Notes"},{"location":"DynamicArraysOrStdVector/","text":"Dynamic Arrays ( std::vector ) Explanation Characteristics One-dimensional std::vector Declaration Syntax Initialization Syntax Syntax for Deleting One-dimensional std::vector Pointers Multidimensional std::vector ( Not Recommend ) Declaration Syntax Initialization Syntax Members and Related Stuffs Links Template Parameters Specializations Member Types Member Functions Non-member Functions Notes Dynamic Arrays ( std::vector ) Explanation Dynamic arrays are arrays that can change size during runtime std::vector is a dynamic array that can grow or shrink as needed. It automatically handles memory allocation and deallocation , making it easier to work with than raw pointers. Characteristics Dynamic arrays are typically slower than static arrays. They automatically manage memory , so programmers do not need to manually allocate or deallocate it. One-dimensional std::vector Declaration Syntax // No initialization, contain garbage values and behave unpredictably. std::vector< Type > arr_name; std::vector< Type >* arr_ptr = new std::vector< Type >; std::vector< Type > arr_name; std::vector< Type >* arr_ptr = &arr_name; Initialization Syntax // Initializer list constructor. std::vector< Type > arr_name = { ... }; // Initializer list constructor. std::vector< Type > arr_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::vector< Type > arr_name( size ); // Initialization with the specific value. std::vector< Type > arr_name( size, value ); // Initializer list constructor. std::vector< Type > arr_name1 = { ... }; // Copy constructor. std::vector< Type > arr_name2( arr_name1 ); // Initializer list constructor. std::vector< Type > arr_name1 = { ... }; // Copy constructor. std::vector< Type > arr_name2 = arr_name1; // Initializer list constructor. std::vector< Type > arr_name1( { ... } ); // Move constructor. std::vector< Type > arr_name2 = std::move( arr_name1 ); // Constructs the container with the contents of the range `[first, last)`. std::vector< Type > arr_name1( { ... } ); std::vector< Type > arr_name2( arr_name1.begin(), arr_name1.end() ); std::vector< Type >* arr_ptr = new std::vector< Type >( size ); std::vector< Type >* arr_ptr = new std::vector< Type >( size, value ); // Initializer list constructor. std::vector< Type > arr_name = { ... }; std::vector< Type >* arr_ptr = new std::vector< Type >( arr_name ); std::vector< Type >* arr_ptr = new std::vector< Type >{ ... }; Syntax for Deleting One-dimensional std::vector Pointers delete arr_ptr; Multidimensional std::vector ( Not Recommend ) Declaration Syntax // No initialization, contain garbage values and behave unpredictably. std::vector< std::vector< Type > > arr_name; // No initialization, contain garbage values and behave unpredictably. std::vector< std::vector< std::vector< Type > > > arr_name; Initialization Syntax // Initializer list constructor. std::vector< std::vector< Type > > arr_name = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; // Default Initialization. std::vector< std::vector< Type > > arr_name = {}; // Uniform Initialization (C++11 and later). std::vector< std::vector< Type > > arr_name{ { { ... /* size_y */}, { ... }, ... /* size_x */ } }; // Copy Initialization. std::vector< std::vector< Type > > arr_name1 = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; std::vector< std::vector< Type > > arr_name2 = arr_name1; // Initializer list constructor. std::vector< std::vector< std::vector< Type > > > arr_name = { { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ } }; // Default Initialization. std::vector< std::vector< std::vector< Type > > > arr_name = {}; // Uniform Initialization (C++11 and later). std::vector< std::vector< std::vector< Type > > > arr_name{ { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ } }; std::vector< std::vector< std::vector< Type > > > arr_name1 = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ }; // Copy Initialization. std::vector< std::vector< std::vector< Type > > > arr_name2 = arr_name1; Members and Related Stuffs Links std::vector in cplusplus . std::vector in cppreference . Template Parameters T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Specializations The standard library provides a specialization of std::vector for the type bool, which may be optimized for space efficiency. vector< bool > : Space-efficient dynamic bitset (class template specialization). Member Types value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20). const_iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20). reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Functions (constructor): Constructs the vector (public member function). (destructor): Destructs the vector (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access specified element (public member function). front : Access the first element (public member function). back : Access the last element (public member function). data : Direct access to the underlying contiguous storage (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). reserve : Reserves storage (public member function). capacity : Returns the number of elements that can be held in currently allocated storage (public member function). shrink_to_fit ( DR* ): Reduces memory usage by freeing unused memory (public member function). clear : Clears the contents (public member function). insert : Inserts elements (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs element in-place (public member function). erase : Erases elements and returns a valid iterator (public member function). push_back : Adds an element to the end (public member function). emplace_back : Constructs an element in-place at the end (public member function). append_range (C++23): Adds a range of elements to the end(public member function). pop_back : Removes the last element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two vectors (function template). std::swap( std::vector ) : Specializes the std::swap algorithm (function template). erase( std::vector ) (C++20), erase_if( std::vector ) (C++20): Erases all elements satisfying specific criteria (function template). Notes Avoid std::vector automatic resizing : We can use the reserve function to hold memory without creating any objects. The reserve function differs from the resize function: while resize creates objects to occupy memory, reserve only holds memory without creating objects. This function changes the capacity of the vector but does not affect its size . Avoid calling copy constructors : We can use the emplace_back function instead of push_back to prevent unnecessary copying of objects. Conclusion: To optimize our code, it is essential to understand the system environment and how the code works, including functions, objects, operators, etc. std::vector::push_back : Copy or move all data to a new location, if need; Otherwise, just move new data into the current location. std::vector:emplace_back : Copy or move old data to a new location and then construct new data in the new location, if need; Otherwise, just construct new data into the current location.","title":"Dynamic Arrays (std::vector"},{"location":"DynamicArraysOrStdVector/#dynamic-arrays-stdvector","text":"","title":"Dynamic Arrays (std::vector)"},{"location":"DynamicArraysOrStdVector/#explanation","text":"Dynamic arrays are arrays that can change size during runtime std::vector is a dynamic array that can grow or shrink as needed. It automatically handles memory allocation and deallocation , making it easier to work with than raw pointers.","title":"Explanation"},{"location":"DynamicArraysOrStdVector/#characteristics","text":"Dynamic arrays are typically slower than static arrays. They automatically manage memory , so programmers do not need to manually allocate or deallocate it.","title":"Characteristics"},{"location":"DynamicArraysOrStdVector/#one-dimensional-stdvector","text":"","title":"One-dimensional std::vector"},{"location":"DynamicArraysOrStdVector/#declaration-syntax","text":"// No initialization, contain garbage values and behave unpredictably. std::vector< Type > arr_name; std::vector< Type >* arr_ptr = new std::vector< Type >; std::vector< Type > arr_name; std::vector< Type >* arr_ptr = &arr_name;","title":"Declaration Syntax"},{"location":"DynamicArraysOrStdVector/#initialization-syntax","text":"// Initializer list constructor. std::vector< Type > arr_name = { ... }; // Initializer list constructor. std::vector< Type > arr_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::vector< Type > arr_name( size ); // Initialization with the specific value. std::vector< Type > arr_name( size, value ); // Initializer list constructor. std::vector< Type > arr_name1 = { ... }; // Copy constructor. std::vector< Type > arr_name2( arr_name1 ); // Initializer list constructor. std::vector< Type > arr_name1 = { ... }; // Copy constructor. std::vector< Type > arr_name2 = arr_name1; // Initializer list constructor. std::vector< Type > arr_name1( { ... } ); // Move constructor. std::vector< Type > arr_name2 = std::move( arr_name1 ); // Constructs the container with the contents of the range `[first, last)`. std::vector< Type > arr_name1( { ... } ); std::vector< Type > arr_name2( arr_name1.begin(), arr_name1.end() ); std::vector< Type >* arr_ptr = new std::vector< Type >( size ); std::vector< Type >* arr_ptr = new std::vector< Type >( size, value ); // Initializer list constructor. std::vector< Type > arr_name = { ... }; std::vector< Type >* arr_ptr = new std::vector< Type >( arr_name ); std::vector< Type >* arr_ptr = new std::vector< Type >{ ... };","title":"Initialization Syntax"},{"location":"DynamicArraysOrStdVector/#syntax-for-deleting-one-dimensional-stdvector-pointers","text":"delete arr_ptr;","title":"Syntax for Deleting One-dimensional std::vector Pointers"},{"location":"DynamicArraysOrStdVector/#multidimensional-stdvector-not-recommend","text":"","title":"Multidimensional std::vector (Not Recommend)"},{"location":"DynamicArraysOrStdVector/#declaration-syntax_1","text":"// No initialization, contain garbage values and behave unpredictably. std::vector< std::vector< Type > > arr_name; // No initialization, contain garbage values and behave unpredictably. std::vector< std::vector< std::vector< Type > > > arr_name;","title":"Declaration Syntax"},{"location":"DynamicArraysOrStdVector/#initialization-syntax_1","text":"// Initializer list constructor. std::vector< std::vector< Type > > arr_name = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; // Default Initialization. std::vector< std::vector< Type > > arr_name = {}; // Uniform Initialization (C++11 and later). std::vector< std::vector< Type > > arr_name{ { { ... /* size_y */}, { ... }, ... /* size_x */ } }; // Copy Initialization. std::vector< std::vector< Type > > arr_name1 = { { { ... /* size_y */ }, { ... }, ... /* size_x */ } }; std::vector< std::vector< Type > > arr_name2 = arr_name1; // Initializer list constructor. std::vector< std::vector< std::vector< Type > > > arr_name = { { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ } }; // Default Initialization. std::vector< std::vector< std::vector< Type > > > arr_name = {}; // Uniform Initialization (C++11 and later). std::vector< std::vector< std::vector< Type > > > arr_name{ { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ...}, ... /* size_x */ } }; std::vector< std::vector< std::vector< Type > > > arr_name1 = { { { ... /* size_z */ }, { ... }, ... /* size_y */ }, { { ... }, { ... }, ... }, ... /* size_x */ }; // Copy Initialization. std::vector< std::vector< std::vector< Type > > > arr_name2 = arr_name1;","title":"Initialization Syntax"},{"location":"DynamicArraysOrStdVector/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"DynamicArraysOrStdVector/#links","text":"std::vector in cplusplus . std::vector in cppreference .","title":"Links"},{"location":"DynamicArraysOrStdVector/#template-parameters","text":"T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"DynamicArraysOrStdVector/#specializations","text":"The standard library provides a specialization of std::vector for the type bool, which may be optimized for space efficiency. vector< bool > : Space-efficient dynamic bitset (class template specialization).","title":"Specializations"},{"location":"DynamicArraysOrStdVector/#member-types","text":"value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20). const_iterator : LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++20), LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20). reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"DynamicArraysOrStdVector/#member-functions","text":"(constructor): Constructs the vector (public member function). (destructor): Destructs the vector (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access specified element (public member function). front : Access the first element (public member function). back : Access the last element (public member function). data : Direct access to the underlying contiguous storage (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). reserve : Reserves storage (public member function). capacity : Returns the number of elements that can be held in currently allocated storage (public member function). shrink_to_fit ( DR* ): Reduces memory usage by freeing unused memory (public member function). clear : Clears the contents (public member function). insert : Inserts elements (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs element in-place (public member function). erase : Erases elements and returns a valid iterator (public member function). push_back : Adds an element to the end (public member function). emplace_back : Constructs an element in-place at the end (public member function). append_range (C++23): Adds a range of elements to the end(public member function). pop_back : Removes the last element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function).","title":"Member Functions"},{"location":"DynamicArraysOrStdVector/#non-member-functions","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two vectors (function template). std::swap( std::vector ) : Specializes the std::swap algorithm (function template). erase( std::vector ) (C++20), erase_if( std::vector ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"DynamicArraysOrStdVector/#notes","text":"Avoid std::vector automatic resizing : We can use the reserve function to hold memory without creating any objects. The reserve function differs from the resize function: while resize creates objects to occupy memory, reserve only holds memory without creating objects. This function changes the capacity of the vector but does not affect its size . Avoid calling copy constructors : We can use the emplace_back function instead of push_back to prevent unnecessary copying of objects. Conclusion: To optimize our code, it is essential to understand the system environment and how the code works, including functions, objects, operators, etc. std::vector::push_back : Copy or move all data to a new location, if need; Otherwise, just move new data into the current location. std::vector:emplace_back : Copy or move old data to a new location and then construct new data in the new location, if need; Otherwise, just construct new data into the current location.","title":"Notes"},{"location":"Enums/","text":"Enums ( enum ) Explanation Usage Unscoped Enumeration Syntax Scoped Enumeration Syntax Differences Between enum (Unscoped Enumeration) and enum class (Scoped Enumeration) 1) Syntax 2) Namespace Scoping 3) Type Safety 4) Underlying Type 5) Forward Declaration 6) Bitwise Operations Enums ( enum ) Explanation An enum (short for \"enumeration\") is a user-defined type that consists of a set of named integral constants , providing a way to define a collection of related constants with meaningful names. Enumerations improve code readability by replacing numeric values with descriptive names. Usage Represent some states with integers by using an enum to group and represent them. Unscoped Enumeration Syntax enum EnumName { Mem1, // 0 Mem2, // 1 ...; Memn = n, // n Memn1 // n + 1 }; EnumName enum_name = Mem2; Scoped Enumeration Syntax enum EnumName: Type { Mem1, // 0 Mem2, // 1 ...; Memn = n, // n Memn1 // n + 1 }; EnumName enum_name = EnumName::Mem2; Differences Between enum (Unscoped Enumeration) and enum class (Scoped Enumeration) 1) Syntax 2) Namespace Scoping enum : Enum values injected into enclosing scope. enum class : Enum values scoped within the enum type. 3) Type Safety enum : Implicitly converts to int. enum class : No implicit conversions. 4) Underlying Type enum : Cannot specify underlying type explicitly. enum class : Can specify underlying type (e.g., enum class Color : unsigned int ). 5) Forward Declaration enum : Not allowed. enum class : Allowed. 6) Bitwise Operations enum : Allowed without extra effort. enum class : Not allowed without operator overloading.","title":"enum"},{"location":"Enums/#enums-enum","text":"","title":"Enums (enum)"},{"location":"Enums/#explanation","text":"An enum (short for \"enumeration\") is a user-defined type that consists of a set of named integral constants , providing a way to define a collection of related constants with meaningful names. Enumerations improve code readability by replacing numeric values with descriptive names.","title":"Explanation"},{"location":"Enums/#usage","text":"Represent some states with integers by using an enum to group and represent them.","title":"Usage"},{"location":"Enums/#unscoped-enumeration-syntax","text":"enum EnumName { Mem1, // 0 Mem2, // 1 ...; Memn = n, // n Memn1 // n + 1 }; EnumName enum_name = Mem2;","title":"Unscoped Enumeration Syntax"},{"location":"Enums/#scoped-enumeration-syntax","text":"enum EnumName: Type { Mem1, // 0 Mem2, // 1 ...; Memn = n, // n Memn1 // n + 1 }; EnumName enum_name = EnumName::Mem2;","title":"Scoped Enumeration Syntax"},{"location":"Enums/#differences-between-enum-unscoped-enumeration-and-enum-class-scoped-enumeration","text":"","title":"Differences Between enum (Unscoped Enumeration) and enum class (Scoped Enumeration)"},{"location":"Enums/#1-syntax","text":"","title":"1) Syntax"},{"location":"Enums/#2-namespace-scoping","text":"enum : Enum values injected into enclosing scope. enum class : Enum values scoped within the enum type.","title":"2) Namespace Scoping"},{"location":"Enums/#3-type-safety","text":"enum : Implicitly converts to int. enum class : No implicit conversions.","title":"3) Type Safety"},{"location":"Enums/#4-underlying-type","text":"enum : Cannot specify underlying type explicitly. enum class : Can specify underlying type (e.g., enum class Color : unsigned int ).","title":"4) Underlying Type"},{"location":"Enums/#5-forward-declaration","text":"enum : Not allowed. enum class : Allowed.","title":"5) Forward Declaration"},{"location":"Enums/#6-bitwise-operations","text":"enum : Allowed without extra effort. enum class : Not allowed without operator overloading.","title":"6) Bitwise Operations"},{"location":"Extern/","text":"Extern Linkage Explanation extern extern \"C\" { ... }; Default Extern Linkage Extern Linkage Explanation Extern linkage allows functions and variables to be accessed across different translation units . It enables the sharing of definitions between multiple files in a program. extern The extern keyword is used to declare variables or functions that are defined in another translation unit . It informs the compiler that the variable or function exists, but its definition will be found elsewhere. extern can be used to declare global variables or functions in a header file, making them accessible across multiple source files. extern \"C\" { ... }; The extern \"C\" construct specifies that the enclosed declarations should use C linkage rather than C++ linkage. This is essential for linking C++ code with C libraries or when calling C functions from C++ . extern \"C\" should be used to prevent name mangling for functions or variables declared within it. This ensures compatibility with C code. Default Extern Linkage When a function is declared, it has external linkage unless specified otherwise (for example, if declared static ). This means the function can be called from other translation units without needing the extern keyword .","title":"Extern"},{"location":"Extern/#extern-linkage","text":"","title":"Extern Linkage"},{"location":"Extern/#explanation","text":"Extern linkage allows functions and variables to be accessed across different translation units . It enables the sharing of definitions between multiple files in a program.","title":"Explanation"},{"location":"Extern/#extern","text":"The extern keyword is used to declare variables or functions that are defined in another translation unit . It informs the compiler that the variable or function exists, but its definition will be found elsewhere. extern can be used to declare global variables or functions in a header file, making them accessible across multiple source files.","title":"extern"},{"location":"Extern/#extern-c","text":"The extern \"C\" construct specifies that the enclosed declarations should use C linkage rather than C++ linkage. This is essential for linking C++ code with C libraries or when calling C functions from C++ . extern \"C\" should be used to prevent name mangling for functions or variables declared within it. This ensures compatibility with C code.","title":"extern \"C\" { ... };"},{"location":"Extern/#default-extern-linkage","text":"When a function is declared, it has external linkage unless specified otherwise (for example, if declared static ). This means the function can be called from other translation units without needing the extern keyword .","title":"Default Extern Linkage"},{"location":"FileIOs/","text":"<iostream> Explanation std::cin and std::wcin std::cin std::wcin Syntax Links std::cout and std::wcout std::cout std::wcout Syntax Links std::cerr and std::wcerr std::cerr std::wcerr Syntax Links std::clog and std::wclog std::clog std::wclog Syntax Links <ostream> std::endl , std::ends and std::flush std::endl std::ends std::flush Syntax <fstream> Explanation std::ifstream , std::ofstream and std::fstream std::ifstream std::ofstream std::fstream Declaration Syntax Initialization Syntax Usage Syntax Members and Related Stuffs Links Member Types Member Functions Member Functions Inherited from std::basic_istream (for std::ifstream and std::fstream ) Member Classes Inherited from std::basic_istream (for std::ifstream and std::fstream ) Member Functions Inherited from std::basic_istream (for std::ofstream and std::fstream ) Member Classes Inherited from std::basic_istream (for std::ofstream and std::fstream ) All Stuffs Inherited from std::std::basic_ios All Stuffs Inherited from std::ios_base Non-member Functions <iostream> Explanation The iostream library provides functionalities for handling input and output operations in C++. It includes both wide and narrow character streams for interacting with data, allowing for flexibility in handling different encodings , such as single-byte characters (ASCII) and multi-byte characters (UTF-16, UTF-32). std::cin and std::wcin std::cin std::cin is the standard input stream used to read data from the standard input (usually the keyboard) for narrow character types ( char ). Typically, it's used for reading user input in the form of various data types (e.g., integers, strings). It waits for user input before processing it and may buffer the input to optimize performance. std::wcin std::wcin is the wide-character equivalent of std::cin , used for reading wide characters ( wchar_t ) from standard input. This is useful for reading internationalized or Unicode data. It's used to read wide-character data, often necessary for handling non-ASCII characters or multi-byte encodings. Similar to std::cin , its input is buffered and processed after the user types it. Syntax // Declaration syntax. extern std::istream cin; extern std::wistream wcin; // Usage syntax. Type var_name; std::cin >> var_name; // Narrow character input WType wvar_name; std::wcin >> wvar_name; // Wide character input Links std::cin in cplusplus . std::wcin in cplusplus . std::cin and std::wcin in cppreference . std::cout and std::wcout std::cout std::cout is the standard output stream used for writing data to the console, typically using narrow characters ( char ). It's used to display output to the user, such as text, numbers, or formatted data. Data written to std::cout is stored in memory and written to the console when the buffer is full or flushed. std::wcout std::wcout is the wide-character output stream for writing wide characters ( wchar_t ) to the console. It's used for outputting wide-character data, necessary when working with non-ASCII or multi-byte character sets, such as internationalized text. Like std::cout , data is buffered before being output to the console. Syntax // Declaration syntax. extern std::ostream cout; extern std::wostream wcout; // Usage syntax. std::cout << \"Message\"; // Narrow character output std::wcout << L\"Message\"; // Wide character output Links std::cout in cplusplus . std::wcout in cplusplus . std::cout and std::wcout in cppreference . std::cerr and std::wcerr std::cerr std::cerr is used for outputting error messages to the standard error stream ( stderr ), typically without buffering. It's commonly used for reporting errors, warnings, or diagnostics. It ensures that error messages are immediately displayed, regardless of buffering. std::wcerr std::wcerr is the wide-character version of std::cerr , used for outputting error messages in wide-character format ( wchar_t ). It's used when you need to output wide-character error messages. Just like std::cerr , it outputs error messages immediately. Syntax extern std::ostream cerr; extern std::wostream wcerr; // Usage syntax. std::cerr << \"Error occurred\"; // Narrow character error output std::wcerr << L\"Error occurred\"; // Wide character error output Links std::cerr in cplusplus . std::wcerr in cplusplus . std::cerr and std::wcerr in cppreference . std::clog and std::wclog std::clog std::clog is used for logging information to the standard error stream ( stderr ), typically buffered. It's commonly used for logging messages, warnings, or diagnostic data. It stores the log messages in memory before outputting them. std::wclog std::wclog is the wide-character version of std::clog , used for logging wide-character data. It's used when the log messages contain wide-character data. Like std::clog , it buffers log messages before outputting them. Syntax // Declaration syntax. extern std::ostream clog; extern std::wostream wclog; // Usage syntax. std::clog << \"Log message\"; // Narrow character log output std::wclog << L\"Log message\"; // Wide character log output Links std::clog in cplusplus . std::wclog in cplusplus . std::clog and std::wclog in cppreference . <ostream> std::endl , std::ends and std::flush std::endl std::endl inserts a newline character ( \\n ) into the output stream and flushes the stream, ensuring immediate output. It often used when you need to print a newline and flush the output immediately (e.g., after displaying a message). It causes a flush of the output stream, in addition to inserting a newline character. std::ends std::ends inserts a null character ( '\\0' ) into the output stream. It is commonly used when working with C-style strings, where a null terminator is needed to mark the end of the string. It's useful when building strings that need to be null-terminated, particularly for compatibility with C-style string functions or libraries that expect a null terminator. It can be used in conjunction with std::ostringstream or other streams when constructing such strings. It does not force a flush of the output buffer. It simply appends the null character to the stream's content without affecting the buffer state. std::flush std::flush forces the output stream to flush, ensuring any buffered data is immediately written out, without inserting a newline. It's used when you want to ensure that all output is immediately written, but without adding a newline. It forces a flush of the output stream, but does not insert any characters into the stream. Syntax IOObject << \"Message\" << std::endl; // Newline and flush IOObject << \"Message\" << std::flush; // Flush without newline std::ostringstream oss; oss << \"Hello, World\" << std::ends; // Adds a null character after the text std::cout << oss.str().c_str(); // Displays the content as a C-style string <fstream> Explanation The <fstream> header in C++ provides classes to perform file-based input and output operations. It defines std::ifstream , std::ofstream , and std::fstream , each suited to specific file handling tasks. These classes support text and binary I/O and are built on top of the basic iostream functionality. std::ifstream , std::ofstream and std::fstream std::ifstream std::ifstream is a file input stream class used to read data from files. It provides input operations similar to std::cin but specifically for file reading. It's primarily used to open a file in read mode. Once opened, the file data can be read line by line or as individual characters. It uses a buffer to read chunks of data, allowing efficient input operations by reducing file access time. It is a non-copyable class. std::wifstream is the wide-character equivalent of std::ifstream , used to read data from files. std::ofstream std::ofstream is a file output stream class used to write data to files. It behaves similarly to std::cout but writes output to a file instead of the console. It's commonly used to open a file in write mode. Text and data can be written to the file, either as individual characters or lines. It buffers output data for efficient file writing by reducing the number of write operations. It is a non-copyable class. std::wofstream is the wide-character equivalent of std::ofstream , used to write data to files. std::fstream std::fstream is a file stream class that supports both input and output operations. It allows reading from and writing to the same file. Typically, it's used when a file requires both reading and writing. It can be opened in various modes (read-only, write-only, or both). It uses a buffer to handle I/O operations efficiently, reducing direct file access calls. It is a non-copyable class. std::wfstream is the wide-character equivalent of std::fstream , providing both input and output operations. Declaration Syntax std::ifstream file; std::ofstream file; std::fstream file; Initialization Syntax std::ifstream file( \"filename.txt\" ); // Opens in read mode std::ifstream file1( \"filename.txt\" ); // Opens in read mode // Move constructor. std::ifstream file2( std::move( file1 ) ); // Opens in read mode std::ofstream file( \"filename.txt\" ); // Opens in write mode std::ofstream file1( \"filename.txt\" ); // Opens in write mode // Move construcotr. std::ofstream file2( std::move( file1 ) ); // Opens in write mode std::fstream file( \"filename.txt\", std::ios::in | std::ios::out ); // Opens in read-write mode std::fstream file1( \"filename.txt\", std::ios::in | std::ios::out ); // Opens in read-write mode // Move constructor. std::fstream file2( std::move( file1 ) ); // Opens in read-write mode Usage Syntax std::ifstream file( \"filename.txt\" ); if( file.is_open() ) { std::string line; while( std::getline( file, line ) ) { std::cout << line << std::endl; }; file.close(); }; std::ofstream file( \"filename.txt\" ); if( file.is_open() ) { file << \"Hello, World!\" << std::endl; file.close(); }; std::fstream file( \"filename.txt\", std::ios::in | std::ios::out ); if( file.is_open() ) { // Reading std::string line; while( std::getline( file, line ) ) { std::cout << line << std::endl; }; // Writing file.clear(); // Clear flags before writing after reading file.seekp( 0, std::ios::end ); // Move write pointer to end file << \"Appending text\" << std::endl; file.close(); }; Members and Related Stuffs Links std::ifstream in cplusplus . std::wifstream in cplusplus . std::ifstream and std::wifstream in cppreference . std::ofstream in cplusplus . std::wofstream in cplusplus . std::ofstream and std::wofstream in cppreference . std::fstream in cplusplus . std::wfstream in cplusplus . std::fstream and std::wfstream in cppreference . Member Types char_type : CharT traits_type : Traits ; the program is ill-formed if Traits::char_type is not CharT . int_type : Traits::int_type . pos_type : Traits::pos_type . off_type : Traits::off_type . native_handle_type (C++26): Implementation-defined type that is TriviallyCopyable and semiregular . Member Functions (constructor): Constructs the file stream (public member function). (destructor) [ virtual ] (implicitly declared): Destructs the ifstream/ofstream/fstream and the associated buffer, closes the file (virtual public member function). operator= : Moves the file stream (public member function). swap : Swaps two file streams (public member function). rdbuf : Returns the underlying raw file device object (public member function). native_handle (C++26): Returns the underlying implementation-defined handle (public member function). is_open : Checks if the stream has an associated file (public member function). open : Opens a file and associates it with the stream (public member function). close : Closes the associated file (public member function). Member Functions Inherited from std::basic_istream (for std::ifstream and std::fstream ) operator>> : Extracts formatted data (public member function of std::basic_istream< CharT, Traits > ). get : Extracts characters (public member function of std::basic_istream< CharT, Traits > ). peek : Reads the next character without extracting it (public member function of std::basic_istream< CharT, Traits > ). unget : Unextracts a character (public member function of std::basic_istream< CharT, Traits > ). putback : Puts a character into the input stream (public member function of std::basic_istream< CharT, Traits > ). getline : Extracts characters until the given character is found (public member function of std::basic_istream< CharT, Traits > ). ignore : Extracts and discards characters until the given character is found (public member function of std::basic_istream< CharT, Traits > ). read : Extracts blocks of characters (public member function of std::basic_istream< CharT, Traits > ). readsome : Extracts already available blocks of characters (public member function of std::basic_istream< CharT, Traits > ). gcount : Returns the number of characters extracted by the last unformatted input operation (public member function of std::basic_istream< CharT, Traits > ). tellg : Returns the input position indicator (public member function of std::basic_istream< CharT, Traits > ). seekg : Sets the input position indicator (public member function of std::basic_istream< CharT, Traits > ). sync : Synchronizes with the underlying storage device (public member function of std::basic_istream< CharT, Traits > ). Member Classes Inherited from std::basic_istream (for std::ifstream and std::fstream ) sentry : Implements basic logic for preparation of the stream for input operations (public member class of std::basic_istream< CharT,Traits > ). Member Functions Inherited from std::basic_istream (for std::ofstream and std::fstream ) operator<< : Inserts formatted data (public member function of std::basic_ostream< CharT, Traits > ). put : Inserts a character (public member function of std::basic_ostream< CharT, Traits > ). write : Inserts blocks of characters (public member function of std::basic_ostream< CharT, Traits > ). tellp : Returns the output position indicator (public member function of std::basic_ostream< CharT, Traits > ). seekp : Sets the output position indicator (public member function of std::basic_ostream< CharT, Traits > ). flush : Synchronizes with the underlying storage device (public member function of std::basic_ostream< CharT, Traits > ). Member Classes Inherited from std::basic_istream (for std::ofstream and std::fstream ) sentry : Implements basic logic for preparation of the stream for output operations (public member class of std::basic_ostream< CharT,Traits > ). All Stuffs Inherited from std::std::basic_ios std::fstream in cplusplus . std::wfstream in cplusplus . std::fstream and std::wfstream in cppreference . All Stuffs Inherited from std::ios_base std::fstream in cplusplus . std::wfstream in cplusplus . std::fstream and std::wfstream in cppreference . Non-member Functions std::swap( std::ifstream ) : specializes the std::swap algorithm (function template).","title":"FileIOs"},{"location":"FileIOs/#iostream","text":"","title":"&lt;iostream&gt;"},{"location":"FileIOs/#explanation","text":"The iostream library provides functionalities for handling input and output operations in C++. It includes both wide and narrow character streams for interacting with data, allowing for flexibility in handling different encodings , such as single-byte characters (ASCII) and multi-byte characters (UTF-16, UTF-32).","title":"Explanation"},{"location":"FileIOs/#stdcin-and-stdwcin","text":"","title":"std::cin and std::wcin"},{"location":"FileIOs/#stdcin","text":"std::cin is the standard input stream used to read data from the standard input (usually the keyboard) for narrow character types ( char ). Typically, it's used for reading user input in the form of various data types (e.g., integers, strings). It waits for user input before processing it and may buffer the input to optimize performance.","title":"std::cin"},{"location":"FileIOs/#stdwcin","text":"std::wcin is the wide-character equivalent of std::cin , used for reading wide characters ( wchar_t ) from standard input. This is useful for reading internationalized or Unicode data. It's used to read wide-character data, often necessary for handling non-ASCII characters or multi-byte encodings. Similar to std::cin , its input is buffered and processed after the user types it.","title":"std::wcin"},{"location":"FileIOs/#syntax","text":"// Declaration syntax. extern std::istream cin; extern std::wistream wcin; // Usage syntax. Type var_name; std::cin >> var_name; // Narrow character input WType wvar_name; std::wcin >> wvar_name; // Wide character input","title":"Syntax"},{"location":"FileIOs/#links","text":"std::cin in cplusplus . std::wcin in cplusplus . std::cin and std::wcin in cppreference .","title":"Links"},{"location":"FileIOs/#stdcout-and-stdwcout","text":"","title":"std::cout and std::wcout"},{"location":"FileIOs/#stdcout","text":"std::cout is the standard output stream used for writing data to the console, typically using narrow characters ( char ). It's used to display output to the user, such as text, numbers, or formatted data. Data written to std::cout is stored in memory and written to the console when the buffer is full or flushed.","title":"std::cout"},{"location":"FileIOs/#stdwcout","text":"std::wcout is the wide-character output stream for writing wide characters ( wchar_t ) to the console. It's used for outputting wide-character data, necessary when working with non-ASCII or multi-byte character sets, such as internationalized text. Like std::cout , data is buffered before being output to the console.","title":"std::wcout"},{"location":"FileIOs/#syntax_1","text":"// Declaration syntax. extern std::ostream cout; extern std::wostream wcout; // Usage syntax. std::cout << \"Message\"; // Narrow character output std::wcout << L\"Message\"; // Wide character output","title":"Syntax"},{"location":"FileIOs/#links_1","text":"std::cout in cplusplus . std::wcout in cplusplus . std::cout and std::wcout in cppreference .","title":"Links"},{"location":"FileIOs/#stdcerr-and-stdwcerr","text":"","title":"std::cerr and std::wcerr"},{"location":"FileIOs/#stdcerr","text":"std::cerr is used for outputting error messages to the standard error stream ( stderr ), typically without buffering. It's commonly used for reporting errors, warnings, or diagnostics. It ensures that error messages are immediately displayed, regardless of buffering.","title":"std::cerr"},{"location":"FileIOs/#stdwcerr","text":"std::wcerr is the wide-character version of std::cerr , used for outputting error messages in wide-character format ( wchar_t ). It's used when you need to output wide-character error messages. Just like std::cerr , it outputs error messages immediately.","title":"std::wcerr"},{"location":"FileIOs/#syntax_2","text":"extern std::ostream cerr; extern std::wostream wcerr; // Usage syntax. std::cerr << \"Error occurred\"; // Narrow character error output std::wcerr << L\"Error occurred\"; // Wide character error output","title":"Syntax"},{"location":"FileIOs/#links_2","text":"std::cerr in cplusplus . std::wcerr in cplusplus . std::cerr and std::wcerr in cppreference .","title":"Links"},{"location":"FileIOs/#stdclog-and-stdwclog","text":"","title":"std::clog and std::wclog"},{"location":"FileIOs/#stdclog","text":"std::clog is used for logging information to the standard error stream ( stderr ), typically buffered. It's commonly used for logging messages, warnings, or diagnostic data. It stores the log messages in memory before outputting them.","title":"std::clog"},{"location":"FileIOs/#stdwclog","text":"std::wclog is the wide-character version of std::clog , used for logging wide-character data. It's used when the log messages contain wide-character data. Like std::clog , it buffers log messages before outputting them.","title":"std::wclog"},{"location":"FileIOs/#syntax_3","text":"// Declaration syntax. extern std::ostream clog; extern std::wostream wclog; // Usage syntax. std::clog << \"Log message\"; // Narrow character log output std::wclog << L\"Log message\"; // Wide character log output","title":"Syntax"},{"location":"FileIOs/#links_3","text":"std::clog in cplusplus . std::wclog in cplusplus . std::clog and std::wclog in cppreference .","title":"Links"},{"location":"FileIOs/#ostream","text":"","title":"&lt;ostream&gt;"},{"location":"FileIOs/#stdendl-stdends-and-stdflush","text":"","title":"std::endl, std::ends and std::flush"},{"location":"FileIOs/#stdendl","text":"std::endl inserts a newline character ( \\n ) into the output stream and flushes the stream, ensuring immediate output. It often used when you need to print a newline and flush the output immediately (e.g., after displaying a message). It causes a flush of the output stream, in addition to inserting a newline character.","title":"std::endl"},{"location":"FileIOs/#stdends","text":"std::ends inserts a null character ( '\\0' ) into the output stream. It is commonly used when working with C-style strings, where a null terminator is needed to mark the end of the string. It's useful when building strings that need to be null-terminated, particularly for compatibility with C-style string functions or libraries that expect a null terminator. It can be used in conjunction with std::ostringstream or other streams when constructing such strings. It does not force a flush of the output buffer. It simply appends the null character to the stream's content without affecting the buffer state.","title":"std::ends"},{"location":"FileIOs/#stdflush","text":"std::flush forces the output stream to flush, ensuring any buffered data is immediately written out, without inserting a newline. It's used when you want to ensure that all output is immediately written, but without adding a newline. It forces a flush of the output stream, but does not insert any characters into the stream.","title":"std::flush"},{"location":"FileIOs/#syntax_4","text":"IOObject << \"Message\" << std::endl; // Newline and flush IOObject << \"Message\" << std::flush; // Flush without newline std::ostringstream oss; oss << \"Hello, World\" << std::ends; // Adds a null character after the text std::cout << oss.str().c_str(); // Displays the content as a C-style string","title":"Syntax"},{"location":"FileIOs/#fstream","text":"","title":"&lt;fstream&gt;"},{"location":"FileIOs/#explanation_1","text":"The <fstream> header in C++ provides classes to perform file-based input and output operations. It defines std::ifstream , std::ofstream , and std::fstream , each suited to specific file handling tasks. These classes support text and binary I/O and are built on top of the basic iostream functionality.","title":"Explanation"},{"location":"FileIOs/#stdifstream-stdofstream-and-stdfstream","text":"","title":"std::ifstream, std::ofstream and std::fstream"},{"location":"FileIOs/#stdifstream","text":"std::ifstream is a file input stream class used to read data from files. It provides input operations similar to std::cin but specifically for file reading. It's primarily used to open a file in read mode. Once opened, the file data can be read line by line or as individual characters. It uses a buffer to read chunks of data, allowing efficient input operations by reducing file access time. It is a non-copyable class. std::wifstream is the wide-character equivalent of std::ifstream , used to read data from files.","title":"std::ifstream"},{"location":"FileIOs/#stdofstream","text":"std::ofstream is a file output stream class used to write data to files. It behaves similarly to std::cout but writes output to a file instead of the console. It's commonly used to open a file in write mode. Text and data can be written to the file, either as individual characters or lines. It buffers output data for efficient file writing by reducing the number of write operations. It is a non-copyable class. std::wofstream is the wide-character equivalent of std::ofstream , used to write data to files.","title":"std::ofstream"},{"location":"FileIOs/#stdfstream","text":"std::fstream is a file stream class that supports both input and output operations. It allows reading from and writing to the same file. Typically, it's used when a file requires both reading and writing. It can be opened in various modes (read-only, write-only, or both). It uses a buffer to handle I/O operations efficiently, reducing direct file access calls. It is a non-copyable class. std::wfstream is the wide-character equivalent of std::fstream , providing both input and output operations.","title":"std::fstream"},{"location":"FileIOs/#declaration-syntax","text":"std::ifstream file; std::ofstream file; std::fstream file;","title":"Declaration Syntax"},{"location":"FileIOs/#initialization-syntax","text":"std::ifstream file( \"filename.txt\" ); // Opens in read mode std::ifstream file1( \"filename.txt\" ); // Opens in read mode // Move constructor. std::ifstream file2( std::move( file1 ) ); // Opens in read mode std::ofstream file( \"filename.txt\" ); // Opens in write mode std::ofstream file1( \"filename.txt\" ); // Opens in write mode // Move construcotr. std::ofstream file2( std::move( file1 ) ); // Opens in write mode std::fstream file( \"filename.txt\", std::ios::in | std::ios::out ); // Opens in read-write mode std::fstream file1( \"filename.txt\", std::ios::in | std::ios::out ); // Opens in read-write mode // Move constructor. std::fstream file2( std::move( file1 ) ); // Opens in read-write mode","title":"Initialization Syntax"},{"location":"FileIOs/#usage-syntax","text":"std::ifstream file( \"filename.txt\" ); if( file.is_open() ) { std::string line; while( std::getline( file, line ) ) { std::cout << line << std::endl; }; file.close(); }; std::ofstream file( \"filename.txt\" ); if( file.is_open() ) { file << \"Hello, World!\" << std::endl; file.close(); }; std::fstream file( \"filename.txt\", std::ios::in | std::ios::out ); if( file.is_open() ) { // Reading std::string line; while( std::getline( file, line ) ) { std::cout << line << std::endl; }; // Writing file.clear(); // Clear flags before writing after reading file.seekp( 0, std::ios::end ); // Move write pointer to end file << \"Appending text\" << std::endl; file.close(); };","title":"Usage Syntax"},{"location":"FileIOs/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"FileIOs/#links_4","text":"std::ifstream in cplusplus . std::wifstream in cplusplus . std::ifstream and std::wifstream in cppreference . std::ofstream in cplusplus . std::wofstream in cplusplus . std::ofstream and std::wofstream in cppreference . std::fstream in cplusplus . std::wfstream in cplusplus . std::fstream and std::wfstream in cppreference .","title":"Links"},{"location":"FileIOs/#member-types","text":"char_type : CharT traits_type : Traits ; the program is ill-formed if Traits::char_type is not CharT . int_type : Traits::int_type . pos_type : Traits::pos_type . off_type : Traits::off_type . native_handle_type (C++26): Implementation-defined type that is TriviallyCopyable and semiregular .","title":"Member Types"},{"location":"FileIOs/#member-functions","text":"(constructor): Constructs the file stream (public member function). (destructor) [ virtual ] (implicitly declared): Destructs the ifstream/ofstream/fstream and the associated buffer, closes the file (virtual public member function). operator= : Moves the file stream (public member function). swap : Swaps two file streams (public member function). rdbuf : Returns the underlying raw file device object (public member function). native_handle (C++26): Returns the underlying implementation-defined handle (public member function). is_open : Checks if the stream has an associated file (public member function). open : Opens a file and associates it with the stream (public member function). close : Closes the associated file (public member function).","title":"Member Functions"},{"location":"FileIOs/#member-functions-inherited-from-stdbasic_istream-for-stdifstream-and-stdfstream","text":"operator>> : Extracts formatted data (public member function of std::basic_istream< CharT, Traits > ). get : Extracts characters (public member function of std::basic_istream< CharT, Traits > ). peek : Reads the next character without extracting it (public member function of std::basic_istream< CharT, Traits > ). unget : Unextracts a character (public member function of std::basic_istream< CharT, Traits > ). putback : Puts a character into the input stream (public member function of std::basic_istream< CharT, Traits > ). getline : Extracts characters until the given character is found (public member function of std::basic_istream< CharT, Traits > ). ignore : Extracts and discards characters until the given character is found (public member function of std::basic_istream< CharT, Traits > ). read : Extracts blocks of characters (public member function of std::basic_istream< CharT, Traits > ). readsome : Extracts already available blocks of characters (public member function of std::basic_istream< CharT, Traits > ). gcount : Returns the number of characters extracted by the last unformatted input operation (public member function of std::basic_istream< CharT, Traits > ). tellg : Returns the input position indicator (public member function of std::basic_istream< CharT, Traits > ). seekg : Sets the input position indicator (public member function of std::basic_istream< CharT, Traits > ). sync : Synchronizes with the underlying storage device (public member function of std::basic_istream< CharT, Traits > ).","title":"Member Functions Inherited from std::basic_istream (for std::ifstream and std::fstream)"},{"location":"FileIOs/#member-classes-inherited-from-stdbasic_istream-for-stdifstream-and-stdfstream","text":"sentry : Implements basic logic for preparation of the stream for input operations (public member class of std::basic_istream< CharT,Traits > ).","title":"Member Classes Inherited from std::basic_istream (for std::ifstream and std::fstream)"},{"location":"FileIOs/#member-functions-inherited-from-stdbasic_istream-for-stdofstream-and-stdfstream","text":"operator<< : Inserts formatted data (public member function of std::basic_ostream< CharT, Traits > ). put : Inserts a character (public member function of std::basic_ostream< CharT, Traits > ). write : Inserts blocks of characters (public member function of std::basic_ostream< CharT, Traits > ). tellp : Returns the output position indicator (public member function of std::basic_ostream< CharT, Traits > ). seekp : Sets the output position indicator (public member function of std::basic_ostream< CharT, Traits > ). flush : Synchronizes with the underlying storage device (public member function of std::basic_ostream< CharT, Traits > ).","title":"Member Functions Inherited from std::basic_istream (for std::ofstream and std::fstream)"},{"location":"FileIOs/#member-classes-inherited-from-stdbasic_istream-for-stdofstream-and-stdfstream","text":"sentry : Implements basic logic for preparation of the stream for output operations (public member class of std::basic_ostream< CharT,Traits > ).","title":"Member Classes Inherited from std::basic_istream (for std::ofstream and std::fstream)"},{"location":"FileIOs/#all-stuffs-inherited-from-stdstdbasic_ios","text":"std::fstream in cplusplus . std::wfstream in cplusplus . std::fstream and std::wfstream in cppreference .","title":"All Stuffs Inherited from std::std::basic_ios"},{"location":"FileIOs/#all-stuffs-inherited-from-stdios_base","text":"std::fstream in cplusplus . std::wfstream in cplusplus . std::fstream and std::wfstream in cppreference .","title":"All Stuffs Inherited from std::ios_base"},{"location":"FileIOs/#non-member-functions","text":"std::swap( std::ifstream ) : specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"FromGccToCPP/","text":"FromGccToCPP Gcc make and Makefiles Git CPP Perface Memory Partitions auto and decltype using , typedef and Namespaces const , constexpr and static volatile Macros and Related Keywords (Including pragma ) Functions Classes Hiding, Overloading, Overriding, and Overwriting Structures Operators new and delete Templates static_assert Introduction to C++ STL Conversion And Casting Bindings std::bind and std::function Arrays Dynamic Arrays ( std::vector ) Lists and Forward Lists Sets Unordered Sets and Flat Sets Maps Unordered Maps and Flat Maps Stacks and Queues enum union , std:any std::variant and std::optional Chars and Strings Pairs and Tuples Smart Pointers Timers Threads Some C Functions and Operators Extern Some Programming Techniques Handles FileIOs","title":"Home"},{"location":"Functions/","text":"Functions Explanation Advantages and Disadvantages Advantages ( Why Use Functions ) Disadvantages Definition Syntax Declaration Syntax Reference Syntax Function Arguments Function Argument Pushing Order (Stack Order) How to Pass Arguments to a Function Limitations of Function Default Arguments Keywords Related to Functions inline Explanation Syntax Advantages Disadvantages Usage const constexpr static noexcept Explanation Synatx Usage Conditional noexcept Expressions Explanation Synatx asm or __asm Explanation Syntax Function Pointers Explanation Declaration and Definition Syntax Declaration and Assignment Syntax Syntax for Function Calls Using Function Pointers Syntax for Function Pinter Declaration Using using Syntax for Function Pinter Declaration Using typedef Lambda Functions Why Use Lambda Functions Explanation Syntax Code for Passing It as a Variable Code for Defining It as a Function Explanation Capture Clause Explanation Example 1: Capture Nothing Example 2: A Default Capture Mode [=] - Capture All Variables by Value Example 3: A Default Capture Mode [&] - Capture All Variables by Value Example 4: Specify Some Variables Captured by Value Example 5: Specify Some Variables Captured by Reference Example 6: Specify Some Variables Captured by Reference and Others by Value Example 7: Specify Some Variables Captured by Value and Others by Reference Example 8: Specify Some Variables Captured by Reference and Some by Value mutable Lambda Functions Explanation Syntax noexcept Lambda Functions Explanation Syntax Function Parameter Packs Explanation Common Syntax Links Callback Functions and Registeration Functions Hiding, Overloading, Overriding, and Overwriting std::function Functions Explanation Functions are self-contained blocks of code that perform specific tasks . They can accept input values, known as parameters, process them, and optionally return a result. Advantages and Disadvantages Advantages ( Why Use Functions ) Code reusability : Functions allow you to write a piece of code once and reuse it multiple times throughout your program. This reduces redundancy and makes the code more maintainable. Modularity : Functions enable you to break down complex problems into smaller, manageable pieces. Each function can focus on a specific task, which makes understanding and maintaining the code easier. Easier debugging : Since functions isolate specific tasks, it\u2019s easier to identify and fix bugs. You can test each function independently to ensure it works correctly. Improved readability : Well-named functions make the code more readable. They serve as documentation by indicating what the function does, which can help other developers (or your future self) understand the code more quickly. Abstraction: Functions help abstract away complex logic. Once a function is defined, you can use it without needing to understand its internal workings, allowing you to focus on higher-level programming. Disadvantages Overhead : Calling functions introduces a slight overhead due to the time taken for the call and return. This can impact performance in time-critical applications, particularly if functions are called excessively or are very small, except in the case of an inline function. Complexity: Overusing functions or creating too many small functions can lead to unnecessary complexity. If functions are too granular, it may become challenging to trace program flow and understand how different parts interact. Global state management: Functions can complicate the management of global variables or states. If functions modify global variables, it can lead to unpredictable behavior and make debugging difficult. Scope issues: The scope of variables defined within functions can lead to issues if not managed properly. Local variables may be inaccessible outside the function, which can limit their usefulness. Dependency management: Functions can create dependencies between different parts of a program. Changes in one function may require updates to others that depend on it, which can lead to maintenance challenges. Definition Syntax RetType funcName( para_list ) { // Function body. }; auto funcName( para_list ) -> RetType { // Function body. }; Declaration Syntax RetType funcName( para_list ); Reference Syntax funcName( arg_list ); RetType var_name = funcName( arg_list ); Function Arguments Function Argument Pushing Order (Stack Order) Right to left ( most common ): In most platforms and compilers (e.g., x86 and x64 using the C calling convention), arguments are pushed onto the stack from right to left. This means the rightmost parameter is pushed first. This allows the function to access arguments in the correct order when it retrieves them from the stack. Left to right (less common): Some calling conventions (e.g., used in some versions of the ARM architecture) may push arguments left to right (from leftmost to rightmost). This is less common in mainstream desktop systems but might be used in embedded or special-purpose systems. Registers: For performance reasons, many modern platforms (like x64) pass the first few arguments to a function in registers rather than pushing them onto the stack. Only arguments that don't fit into the available registers are pushed onto the stack. How to Pass Arguments to a Function Primitive -type arguments: Pass their values to the function. Class -type, struct -type, and other complex arguments : Pass their references or pointers to the function. Limitations of Function Default Arguments Order of Parameters : Once a default argument is specified for a parameter, all subsequent parameters must also have default arguments . It is not permissible to omit a parameter that has a default value if one intends to provide values for later parameters . Ambiguity in overloading : The use of default arguments can lead to ambiguity in function overloading. If multiple overloaded functions can match the same call due to the presence of default arguments, it may result in confusion for the compiler. Inheritance : When overriding a virtual function in a derived class , the default arguments of the base class method cannot be altered . The default arguments of the base class will remain applicable, which may lead to confusion. Function pointers : In the context of function pointers, default arguments are not considered . The function pointer type must match the function signature precisely. Keywords Related to Functions inline Explanation Functions defined with the inline keyword suggest to the compiler that it should attempt to expand the function's code at each point where the function is called , rather than performing a traditional call. Please note that this is just a suggestion . The compiler will decide whether or not to expand the inline function depending on the situation. If you want to force the compiler to unfold the function all the time, you should understand more about the compiler's behavior. Syntax inline RetType funcName( para_list ) { // Function body. }; int main() { RetType result = funcName( para_list ); // Function call may be replaced with the function body. }; Advantages Reduced function call overhead. Fast execution. Disadvantages Code bloat. Increased compilation time. Debugging difficult. Usage Inline functions. Inline methods. Inline template functions. const const Methods ( const Member Functions) const Function Parameters constexpr constexpr Functions ( constexpr Return Values) static static Methods ( static Member Functions) static Global Functions noexcept Explanation noexcept is a specifier in C++ that indicates whether a function is guaranteed not to throw exceptions . It helps optimize code by allowing the compiler to make certain assumptions about exception handling. If a noexcept function throws an exception , the compiler will issue a warning . Synatx RetType funcName( para_list ) noexcept { // Indicates no exceptions will be thrown. // Function implementation. }; // The compiler will issue a `warning`. RetType funcName( para_list ) noexcept { // Indicates no exceptions will be thrown. // Function implementation. throw std::runtime_error( \" ... \" ); }; Usage Function declarations and definitions. Lambda expressions. Constructors and destructors. Move constructors and move assignment operators. Conditional noexcept expressions. Function pointers and type aliases. Overloaded functions. Conditional noexcept Expressions Explanation Conditional noexcept in C++ allows you to specify that a function is noexcept only if certain conditions are met . The expression accompanying noexcept is evaluated as true or false at compile time . If the expression is true , the function is considered noexcept . If false , it may throw exceptions . Synatx RetType funcName( para_list ) noexcept( noexcept ( an expression or a function ) { // Indicates no exceptions will be thrown. // Function implementation. }; asm or __asm Explanation asm and __asm are keywords used to embed assembly language instructions within C++ code . They allow you to write low-level code for performance-critical sections, hardware control, or when specific machine instructions are required. Syntax asm(\"assembly_code\"); Function Pointers Explanation A function pointer is a variable that stores the address of a function in C or C++. It allows you to call a function indirectly through its pointer, enabling dynamic function calls and making it possible to implement callback mechanisms . Declaration and Definition Syntax // The implicit conversion occurs. auto func_ptr_name = funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion does not occur. auto func_ptr_name = &funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion occurs. RetType ( *func_ptr_name )( para_type_list ) = funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion does not occur. RetType ( *func_ptr_name )( para_type_list ) = &funcName; Declaration and Assignment Syntax RetType ( *func_ptr_name )( para_type_list ); // The implicit conversion occurs. func_ptr_name = funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion does not occur. RetType ( *func_ptr_name )( para_type_list ); func_ptr_name = &funcName; Syntax for Function Calls Using Function Pointers // A function whose return type isn't `void`. auto result = func_ptr_name( arg_list ); // This syntax is equivalent to the syntax mentioned above. RetType result = func_ptr_name( arg_list ); // A function whose return type is `void`. func_pt_name( arg_list ); Syntax for Function Pinter Declaration Using using Syntax for Function Pinter Declaration Using using CPP using FuncPtrName = RetType ( * )( parameter_types ); FuncPtrName func_ptr_name; Syntax for Function Pinter Declaration Using typedef Syntax for Function Pinter Declaration Using typedef CPP typedef RetType ( *FuncPtrName )( parameter_types ); FuncPtrName func_ptr_name; Lambda Functions Why Use Lambda Functions If functionA intends to invoke functionB at a specific juncture , a pointer to functionB can be passed into functionA . However, employing a conventional implementation of functionB may be excessive ; thus, utilizing a lambda expression is recommended. Certain C++ standard libraries necessitate the use of function pointers; in such cases, a lambda expression can be passed as a pointer. Explanation A lambda function is a way to define an anonymous inline function (i.e., a function without a name) directly in your code. It allows you to create small, simple function-like entities inline , making your code more concise and flexible . All elements captured by a lambda function must be declared before the lambda\u2019s definition . Syntax Code for Passing It as a Variable [capture]( para_list ) -> RetType { // Funtion body. }; Code for Defining It as a Function auto funcName = [capture]( para_list ) -> RetType { // Funtion body. }; Explanation capture : Specifies which variables from the surrounding scope are captured by the lambda. This can be done by value ( = ) or by reference ( & ). para_list : The para_list for the lambda function, similar to any regular function. RetType ( optional ): The return type of the lambda. If omitted , C++ will attempt to deduce it automatically. Function body : The function body where the logic of the lambda resides. Capture Clause Explanation Capture by value ( = ): Copies the variable and makes it accessible inside the lambda. Capture by reference ( & ): Allows the lambda to modify the variable in the outer scope. Default capture: Default capture in a lambda function allows you to specify how variables from the surrounding scope are captured without explicitly listing each one . You can set a default capture mode for all variables , which can be overridden for specific variables if needed. Example 1: Capture Nothing auto funcName = []( para_list ) -> RetType { body }; Example 2: A Default Capture Mode [=] - Capture All Variables by Value // A default capture mode[=]: captures all variables by value. auto funcName = [=]( para_list ) -> RetType { body }; Example 3: A Default Capture Mode [&] - Capture All Variables by Value // A default capture mode[&]: captures all variables by value. auto funcName = [&]( para_list ) -> RetType { body }; Example 4: Specify Some Variables Captured by Value auto funcName = [var1, var2, ...]( para_list ) -> RetType { body }; Example 5: Specify Some Variables Captured by Reference auto funcName = [&var1, &var2, ...]( para_list ) -> RetType { body }; Example 6: Specify Some Variables Captured by Reference and Others by Value // In the capture list, the default capture must appear first. auto funcName = [=, &var1, &var2, ...]( para_list ) -> RetType { body }; Example 7: Specify Some Variables Captured by Value and Others by Reference // In the capture list, the default capture must appear first. auto funcName = [&, =var1, =var2, ...]( para_list ) -> RetType { body }; Example 8: Specify Some Variables Captured by Reference and Some by Value auto funcName = [&var1, &var2, ..., varn1, varn2, ...]( para_list ) -> RetType { body }; mutable Lambda Functions Explanation For a lambda, the mutable keyword allows the lambda to change the value of a variable passed by value inside the lambda , but it does not change the variable's actual value outside the lambda . In 90% of cases, the mutable keyword will be used in a class with the const keyword. Syntax [capture]( para_list ) mutable -> RetType { body }; auto funcName = [capture]( para_list ) mutable -> RetType { body }; noexcept Lambda Functions Explanation The noexcept keyword indicates whether a lambda expression is guaranteed not to not throw exceptions . If a noexcept lambda function throws an exception , the compiler will issue a warning . Syntax [capture]( para_list ) noexcept -> RetType { body }; auto funcName = [capture]( para_list ) noexcept -> RetType { body }; Function Parameter Packs Explanation Function parameter packs are function parameters that accept zero or more function arguments . Common Syntax // Be mindful of the Ellipsis. template< typename... Ts > RetType funcName( Ts... args ) { // Method to print all arguments in order without adding any extra characters. ( std::cout << ... << args ) << std::endl; // Method to print all arguments'addresses in order without adding any extra characters. ( std::cout << ... << &args ) << std::endl; // Method to print all ++arguments in order without adding any extra characters. ( std::cout << ... << ++args ) << std::endl; std::tuple< Args... > _var; // Store arguments in a tuple. std::tuple< Args*... > _var_ptr; // Store arguments in a tuple. // Method to return an element by index. return std::get< Index >( _var ); } Links parameter packs in cplusplus . parameter packs in cppreference . Callback Functions and Registeration Functions Callback function: A callback function is a function that is passed as a parameter to another function . The function receiving the callback can then call it at the appropriate time, typically in response to an event or condition. In essence, it is calling a function indirectly through a pointer to it (i.e., function pointer). Registration function: A registration function is a function that is typically used to register a callback or handler . It takes a function pointer as an argument and stores or uses it later , allowing other functions to invoke it when needed. It\u2019s essentially a way of registering a function for future calls. Hiding, Overloading, Overriding, and Overwriting Hiding, Overloading, Overriding, and Overwriting std::function std::function","title":"Functions"},{"location":"Functions/#functions","text":"","title":"Functions"},{"location":"Functions/#explanation","text":"Functions are self-contained blocks of code that perform specific tasks . They can accept input values, known as parameters, process them, and optionally return a result.","title":"Explanation"},{"location":"Functions/#advantages-and-disadvantages","text":"","title":"Advantages and Disadvantages"},{"location":"Functions/#advantages-why-use-functions","text":"Code reusability : Functions allow you to write a piece of code once and reuse it multiple times throughout your program. This reduces redundancy and makes the code more maintainable. Modularity : Functions enable you to break down complex problems into smaller, manageable pieces. Each function can focus on a specific task, which makes understanding and maintaining the code easier. Easier debugging : Since functions isolate specific tasks, it\u2019s easier to identify and fix bugs. You can test each function independently to ensure it works correctly. Improved readability : Well-named functions make the code more readable. They serve as documentation by indicating what the function does, which can help other developers (or your future self) understand the code more quickly. Abstraction: Functions help abstract away complex logic. Once a function is defined, you can use it without needing to understand its internal workings, allowing you to focus on higher-level programming.","title":"Advantages ( Why Use Functions )"},{"location":"Functions/#disadvantages","text":"Overhead : Calling functions introduces a slight overhead due to the time taken for the call and return. This can impact performance in time-critical applications, particularly if functions are called excessively or are very small, except in the case of an inline function. Complexity: Overusing functions or creating too many small functions can lead to unnecessary complexity. If functions are too granular, it may become challenging to trace program flow and understand how different parts interact. Global state management: Functions can complicate the management of global variables or states. If functions modify global variables, it can lead to unpredictable behavior and make debugging difficult. Scope issues: The scope of variables defined within functions can lead to issues if not managed properly. Local variables may be inaccessible outside the function, which can limit their usefulness. Dependency management: Functions can create dependencies between different parts of a program. Changes in one function may require updates to others that depend on it, which can lead to maintenance challenges.","title":"Disadvantages"},{"location":"Functions/#definition-syntax","text":"RetType funcName( para_list ) { // Function body. }; auto funcName( para_list ) -> RetType { // Function body. };","title":"Definition Syntax"},{"location":"Functions/#declaration-syntax","text":"RetType funcName( para_list );","title":"Declaration Syntax"},{"location":"Functions/#reference-syntax","text":"funcName( arg_list ); RetType var_name = funcName( arg_list );","title":"Reference Syntax"},{"location":"Functions/#function-arguments","text":"","title":"Function Arguments"},{"location":"Functions/#function-argument-pushing-order-stack-order","text":"Right to left ( most common ): In most platforms and compilers (e.g., x86 and x64 using the C calling convention), arguments are pushed onto the stack from right to left. This means the rightmost parameter is pushed first. This allows the function to access arguments in the correct order when it retrieves them from the stack. Left to right (less common): Some calling conventions (e.g., used in some versions of the ARM architecture) may push arguments left to right (from leftmost to rightmost). This is less common in mainstream desktop systems but might be used in embedded or special-purpose systems. Registers: For performance reasons, many modern platforms (like x64) pass the first few arguments to a function in registers rather than pushing them onto the stack. Only arguments that don't fit into the available registers are pushed onto the stack.","title":"Function Argument Pushing Order (Stack Order)"},{"location":"Functions/#how-to-pass-arguments-to-a-function","text":"Primitive -type arguments: Pass their values to the function. Class -type, struct -type, and other complex arguments : Pass their references or pointers to the function.","title":"How to Pass Arguments to a Function"},{"location":"Functions/#limitations-of-function-default-arguments","text":"Order of Parameters : Once a default argument is specified for a parameter, all subsequent parameters must also have default arguments . It is not permissible to omit a parameter that has a default value if one intends to provide values for later parameters . Ambiguity in overloading : The use of default arguments can lead to ambiguity in function overloading. If multiple overloaded functions can match the same call due to the presence of default arguments, it may result in confusion for the compiler. Inheritance : When overriding a virtual function in a derived class , the default arguments of the base class method cannot be altered . The default arguments of the base class will remain applicable, which may lead to confusion. Function pointers : In the context of function pointers, default arguments are not considered . The function pointer type must match the function signature precisely.","title":"Limitations of Function Default Arguments"},{"location":"Functions/#keywords-related-to-functions","text":"","title":"Keywords Related to Functions"},{"location":"Functions/#inline","text":"","title":"inline"},{"location":"Functions/#explanation_1","text":"Functions defined with the inline keyword suggest to the compiler that it should attempt to expand the function's code at each point where the function is called , rather than performing a traditional call. Please note that this is just a suggestion . The compiler will decide whether or not to expand the inline function depending on the situation. If you want to force the compiler to unfold the function all the time, you should understand more about the compiler's behavior.","title":"Explanation"},{"location":"Functions/#syntax","text":"inline RetType funcName( para_list ) { // Function body. }; int main() { RetType result = funcName( para_list ); // Function call may be replaced with the function body. };","title":"Syntax"},{"location":"Functions/#advantages","text":"Reduced function call overhead. Fast execution.","title":"Advantages"},{"location":"Functions/#disadvantages_1","text":"Code bloat. Increased compilation time. Debugging difficult.","title":"Disadvantages"},{"location":"Functions/#usage","text":"Inline functions. Inline methods. Inline template functions.","title":"Usage"},{"location":"Functions/#const","text":"const Methods ( const Member Functions) const Function Parameters","title":"const"},{"location":"Functions/#constexpr","text":"constexpr Functions ( constexpr Return Values)","title":"constexpr"},{"location":"Functions/#static","text":"static Methods ( static Member Functions) static Global Functions","title":"static"},{"location":"Functions/#noexcept","text":"","title":"noexcept"},{"location":"Functions/#explanation_2","text":"noexcept is a specifier in C++ that indicates whether a function is guaranteed not to throw exceptions . It helps optimize code by allowing the compiler to make certain assumptions about exception handling. If a noexcept function throws an exception , the compiler will issue a warning .","title":"Explanation"},{"location":"Functions/#synatx","text":"RetType funcName( para_list ) noexcept { // Indicates no exceptions will be thrown. // Function implementation. }; // The compiler will issue a `warning`. RetType funcName( para_list ) noexcept { // Indicates no exceptions will be thrown. // Function implementation. throw std::runtime_error( \" ... \" ); };","title":"Synatx"},{"location":"Functions/#usage_1","text":"Function declarations and definitions. Lambda expressions. Constructors and destructors. Move constructors and move assignment operators. Conditional noexcept expressions. Function pointers and type aliases. Overloaded functions.","title":"Usage"},{"location":"Functions/#conditional-noexcept-expressions","text":"","title":"Conditional noexcept Expressions"},{"location":"Functions/#explanation_3","text":"Conditional noexcept in C++ allows you to specify that a function is noexcept only if certain conditions are met . The expression accompanying noexcept is evaluated as true or false at compile time . If the expression is true , the function is considered noexcept . If false , it may throw exceptions .","title":"Explanation"},{"location":"Functions/#synatx_1","text":"RetType funcName( para_list ) noexcept( noexcept ( an expression or a function ) { // Indicates no exceptions will be thrown. // Function implementation. };","title":"Synatx"},{"location":"Functions/#asm-or-__asm","text":"","title":"asm or __asm"},{"location":"Functions/#explanation_4","text":"asm and __asm are keywords used to embed assembly language instructions within C++ code . They allow you to write low-level code for performance-critical sections, hardware control, or when specific machine instructions are required.","title":"Explanation"},{"location":"Functions/#syntax_1","text":"asm(\"assembly_code\");","title":"Syntax"},{"location":"Functions/#function-pointers","text":"","title":"Function Pointers"},{"location":"Functions/#explanation_5","text":"A function pointer is a variable that stores the address of a function in C or C++. It allows you to call a function indirectly through its pointer, enabling dynamic function calls and making it possible to implement callback mechanisms .","title":"Explanation"},{"location":"Functions/#declaration-and-definition-syntax","text":"// The implicit conversion occurs. auto func_ptr_name = funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion does not occur. auto func_ptr_name = &funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion occurs. RetType ( *func_ptr_name )( para_type_list ) = funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion does not occur. RetType ( *func_ptr_name )( para_type_list ) = &funcName;","title":"Declaration and Definition Syntax"},{"location":"Functions/#declaration-and-assignment-syntax","text":"RetType ( *func_ptr_name )( para_type_list ); // The implicit conversion occurs. func_ptr_name = funcName; // This syntax is equivalent to the syntax mentioned above. // The implicit conversion does not occur. RetType ( *func_ptr_name )( para_type_list ); func_ptr_name = &funcName;","title":"Declaration and Assignment Syntax"},{"location":"Functions/#syntax-for-function-calls-using-function-pointers","text":"// A function whose return type isn't `void`. auto result = func_ptr_name( arg_list ); // This syntax is equivalent to the syntax mentioned above. RetType result = func_ptr_name( arg_list ); // A function whose return type is `void`. func_pt_name( arg_list );","title":"Syntax for Function Calls Using Function Pointers"},{"location":"Functions/#syntax-for-function-pinter-declaration-using-using","text":"Syntax for Function Pinter Declaration Using using CPP using FuncPtrName = RetType ( * )( parameter_types ); FuncPtrName func_ptr_name;","title":"Syntax for Function Pinter Declaration Using using"},{"location":"Functions/#syntax-for-function-pinter-declaration-using-typedef","text":"Syntax for Function Pinter Declaration Using typedef CPP typedef RetType ( *FuncPtrName )( parameter_types ); FuncPtrName func_ptr_name;","title":"Syntax for Function Pinter Declaration Using typedef"},{"location":"Functions/#lambda-functions","text":"","title":"Lambda Functions"},{"location":"Functions/#why-use-lambda-functions","text":"If functionA intends to invoke functionB at a specific juncture , a pointer to functionB can be passed into functionA . However, employing a conventional implementation of functionB may be excessive ; thus, utilizing a lambda expression is recommended. Certain C++ standard libraries necessitate the use of function pointers; in such cases, a lambda expression can be passed as a pointer.","title":"Why Use Lambda Functions"},{"location":"Functions/#explanation_6","text":"A lambda function is a way to define an anonymous inline function (i.e., a function without a name) directly in your code. It allows you to create small, simple function-like entities inline , making your code more concise and flexible . All elements captured by a lambda function must be declared before the lambda\u2019s definition .","title":"Explanation"},{"location":"Functions/#syntax_2","text":"","title":"Syntax"},{"location":"Functions/#code-for-passing-it-as-a-variable","text":"[capture]( para_list ) -> RetType { // Funtion body. };","title":"Code for Passing It as a Variable"},{"location":"Functions/#code-for-defining-it-as-a-function","text":"auto funcName = [capture]( para_list ) -> RetType { // Funtion body. };","title":"Code for Defining It as a Function"},{"location":"Functions/#explanation_7","text":"capture : Specifies which variables from the surrounding scope are captured by the lambda. This can be done by value ( = ) or by reference ( & ). para_list : The para_list for the lambda function, similar to any regular function. RetType ( optional ): The return type of the lambda. If omitted , C++ will attempt to deduce it automatically. Function body : The function body where the logic of the lambda resides.","title":"Explanation"},{"location":"Functions/#capture-clause","text":"","title":"Capture Clause"},{"location":"Functions/#explanation_8","text":"Capture by value ( = ): Copies the variable and makes it accessible inside the lambda. Capture by reference ( & ): Allows the lambda to modify the variable in the outer scope. Default capture: Default capture in a lambda function allows you to specify how variables from the surrounding scope are captured without explicitly listing each one . You can set a default capture mode for all variables , which can be overridden for specific variables if needed.","title":"Explanation"},{"location":"Functions/#example-1-capture-nothing","text":"auto funcName = []( para_list ) -> RetType { body };","title":"Example 1: Capture Nothing"},{"location":"Functions/#example-2-a-default-capture-mode-capture-all-variables-by-value","text":"// A default capture mode[=]: captures all variables by value. auto funcName = [=]( para_list ) -> RetType { body };","title":"Example 2: A Default Capture Mode [=] - Capture All Variables by Value"},{"location":"Functions/#example-3-a-default-capture-mode-capture-all-variables-by-value","text":"// A default capture mode[&]: captures all variables by value. auto funcName = [&]( para_list ) -> RetType { body };","title":"Example 3: A Default Capture Mode [&amp;] - Capture All Variables by Value"},{"location":"Functions/#example-4-specify-some-variables-captured-by-value","text":"auto funcName = [var1, var2, ...]( para_list ) -> RetType { body };","title":"Example 4: Specify Some Variables Captured by Value"},{"location":"Functions/#example-5-specify-some-variables-captured-by-reference","text":"auto funcName = [&var1, &var2, ...]( para_list ) -> RetType { body };","title":"Example 5: Specify Some Variables Captured by Reference"},{"location":"Functions/#example-6-specify-some-variables-captured-by-reference-and-others-by-value","text":"// In the capture list, the default capture must appear first. auto funcName = [=, &var1, &var2, ...]( para_list ) -> RetType { body };","title":"Example 6: Specify Some Variables Captured by Reference and Others by Value"},{"location":"Functions/#example-7-specify-some-variables-captured-by-value-and-others-by-reference","text":"// In the capture list, the default capture must appear first. auto funcName = [&, =var1, =var2, ...]( para_list ) -> RetType { body };","title":"Example 7: Specify Some Variables Captured by Value and Others by Reference"},{"location":"Functions/#example-8-specify-some-variables-captured-by-reference-and-some-by-value","text":"auto funcName = [&var1, &var2, ..., varn1, varn2, ...]( para_list ) -> RetType { body };","title":"Example 8: Specify Some Variables Captured by Reference and Some by Value"},{"location":"Functions/#mutable-lambda-functions","text":"","title":"mutable Lambda Functions"},{"location":"Functions/#explanation_9","text":"For a lambda, the mutable keyword allows the lambda to change the value of a variable passed by value inside the lambda , but it does not change the variable's actual value outside the lambda . In 90% of cases, the mutable keyword will be used in a class with the const keyword.","title":"Explanation"},{"location":"Functions/#syntax_3","text":"[capture]( para_list ) mutable -> RetType { body }; auto funcName = [capture]( para_list ) mutable -> RetType { body };","title":"Syntax"},{"location":"Functions/#noexcept-lambda-functions","text":"","title":"noexcept Lambda Functions"},{"location":"Functions/#explanation_10","text":"The noexcept keyword indicates whether a lambda expression is guaranteed not to not throw exceptions . If a noexcept lambda function throws an exception , the compiler will issue a warning .","title":"Explanation"},{"location":"Functions/#syntax_4","text":"[capture]( para_list ) noexcept -> RetType { body }; auto funcName = [capture]( para_list ) noexcept -> RetType { body };","title":"Syntax"},{"location":"Functions/#function-parameter-packs","text":"","title":"Function Parameter Packs"},{"location":"Functions/#explanation_11","text":"Function parameter packs are function parameters that accept zero or more function arguments .","title":"Explanation"},{"location":"Functions/#common-syntax","text":"// Be mindful of the Ellipsis. template< typename... Ts > RetType funcName( Ts... args ) { // Method to print all arguments in order without adding any extra characters. ( std::cout << ... << args ) << std::endl; // Method to print all arguments'addresses in order without adding any extra characters. ( std::cout << ... << &args ) << std::endl; // Method to print all ++arguments in order without adding any extra characters. ( std::cout << ... << ++args ) << std::endl; std::tuple< Args... > _var; // Store arguments in a tuple. std::tuple< Args*... > _var_ptr; // Store arguments in a tuple. // Method to return an element by index. return std::get< Index >( _var ); }","title":"Common Syntax"},{"location":"Functions/#links","text":"parameter packs in cplusplus . parameter packs in cppreference .","title":"Links"},{"location":"Functions/#callback-functions-and-registeration-functions","text":"Callback function: A callback function is a function that is passed as a parameter to another function . The function receiving the callback can then call it at the appropriate time, typically in response to an event or condition. In essence, it is calling a function indirectly through a pointer to it (i.e., function pointer). Registration function: A registration function is a function that is typically used to register a callback or handler . It takes a function pointer as an argument and stores or uses it later , allowing other functions to invoke it when needed. It\u2019s essentially a way of registering a function for future calls.","title":"Callback Functions and Registeration Functions"},{"location":"Functions/#hiding-overloading-overriding-and-overwriting","text":"Hiding, Overloading, Overriding, and Overwriting","title":"Hiding, Overloading, Overriding, and Overwriting"},{"location":"Functions/#stdfunction","text":"std::function","title":"std::function"},{"location":"Gcc/","text":"g++ Compiler and Linker Header File (Preprocess Statement) CPP File OBJ File (Machine Code File, .obj in Windows, .o in Linux) Linking (Static Linking and Dynamic Linking) Libraries Static Linking Explanation Characteristics How It Works Dynamic Linking (Implicit Linking and Explicit Linking) Explanation Characteristics Implicit Linking (Load-time Dynamic Linking) (Default Dynamic Linking) (Standard Dynamic Linking) Explanation Characteristics How It Works in Windows How It Works in Linux Explicit Linking (Run-time Dynamic Linking) Explanation Characteristics How It Works in Windows How It Works in Linux Differences Between gcc and g++ Language 1. gcc 2. g++ Linking 1. gcc 2. g++ Header File Handling 1. gcc 2. g++ How to Compile One CPP File Source files g++ Main.cpp 1. Usage 2. Output g++ Main.cpp -o Main.exe 1. Usage 2. Output g++ -E Main.cpp -o Main.i 1. Usage 2. Output g++ -S Main.i 1. Usage 2. Output g++ -S Main.cpp 1. Usage 2. Output g++ -c Main.s 1. Usage 2. Output g++ -c Main.cpp 1. Usage 2. Output g++ Main.o -o Main.exe 1. Usage 2. Output g++ -On Main.cpp -o Main.exe 1. Usage 2. Output g++ -DMACRO_NAME1 -DMACRO_NAME2 ... Main.cpp -o Main.exe 1. Usage 2. Output How to Compile Multiple CPP Files Source files Compile all files in one command 1. Code 2. Usage 3. Output 4. Alternative: If All Files Are in One Folder Compile All Files Separately and Then Link Them Together 1. Code 2. Usage 3. Output How to Compile and Link a Library Source files Setup Paths of Header Files 1. Code How to Link Multiple Static Libraries 1. Code How to Create a Static Library 1. Code 2. Usage 3. Output How to Link Multiple Dynamic Libraries 1. Code How to Create a Dynamic Library 1. Code 2. Usage 3. Output How to Create and Link a Static Library 1. Code 2. -Wl,-Bstatic 3. -Wl,-Bdynamic 4. Situation 5. Usage 6. Output How to Create and Link a Dynamic Library 1. Code 2. Situation 3. Usage 4. Output 5. Special Notes g++ Compiler and Linker Header File (Preprocess Statement) The compiler will copy and paste them into the object CPP file. CPP File The compiler translates the CPP files into assembly code and then into machine code without performing any linking operations. Typically, there is one OBJ file per CPP file , but sometimes multiple CPP files may result in a single OBJ file . During the compilation phase, the compiler also optimizes your code. OBJ File (Machine Code File, .obj in Windows, .o in Linux) All OBJ files will be combined into a single file by the linker. The C++ linker can perform certain optimizations , although its primary role is focused on linking object files and libraries rather than optimizing code. Linking (Static Linking and Dynamic Linking) Libraries Static ( .lib or .a ) vs dynamic libraries ( .dll or .so ): Linking with static libraries is faster than dynamic libraries because the C++ linker performs optimizations during static linking. Import libraries ( xxxdll.lib files): These files contain references to functions and symbols defined in the xxx.dll files, facilitating linking at compile time. This process ensures that the correct function signatures and addresses are utilized, allowing the linker to ascertain their locations at runtime. Import libraries are specific to Windows , while Linux integrates this functionality directly into dynamic libraries . Static Linking Explanation Static linking refers to the process of combining all necessary library code into the final executable at compile time . This results in a standalone binary that does not rely on external libraries at runtime . Characteristics Self-contained: The executable includes all the library code it needs. No runtime dependencies: Once compiled, it doesn't require the presence of shared libraries on the target system. Larger executable size: The resulting binary is typically larger due to the inclusion of library code. No versioning issues: The code is fixed at compile time, reducing concerns about library version compatibility. How It Works Compilation: The developer compiles the source code and links it against static library files (usually .lib in windows, .a files in linux). Linking: The linker combines the object files with the static library code, resolving all symbol references. Executable creation: The final output is a single executable file that includes all necessary code. Dynamic Linking (Implicit Linking and Explicit Linking) Explanation Dynamic linking allows a program to link to libraries at runtime rather than at compile time. This can improve modularity and reduce executable size . Characteristics Reduced executable size: Only references to shared libraries are included, keeping the executable smaller. Shared code: Multiple programs can share the same library code in memory, saving resources. Version flexibility: Libraries can be updated independently of the applications that use them, allowing for easier updates and bug fixes. Runtime dependencies: The executable requires the appropriate shared libraries to be present at runtime. Implicit Linking (Load-time Dynamic Linking) (Default Dynamic Linking) (Standard Dynamic Linking) Explanation Implicit linking, also referred to as load-time dynamic linking is a form of dynamic linking where required libraries are automatically loaded at application startup. It is a process whereby an executable is linked to shared libraries at compile time . This method allows the program to utilize functions and variables defined in those libraries without incorporating their code directly into the executable. Characteristics Automatic resolution: The operating system loads the shared libraries automatically when the application starts. Simplified development: Developers include the DLL's import library ( .lib file) in Windows or the shared library ( .so file) in Linux during compilation, simplifying the linking process. Single entry point: The operating system resolves function calls from the shared libraries automatically, allowing the application to use them seamlessly. Version dependency: If the required version of a shared library is missing or incompatible, the application may fail to start. How It Works in Windows Linking with import libraries : When compiling the application, the developer links against the DLL's import library, which provides necessary metadata for the linker. Creating the executable: The resulting executable contains references to the required DLLs but does not embed their code, reducing the executable's size. Loading the DLLs: Upon execution, the Windows loader reads the executable's headers to identify the required DLLs and loads them into memory. Resolving symbols: The loader resolves function calls to the appropriate addresses in the loaded DLLs, ensuring that the application can access the necessary functions and variables. Execution: Control is then passed to the application's entry point, allowing it to call functions from the linked DLLs, enabling shared access to the library's functionality. How It Works in Linux Linking with shared libraries : When compiling the application, the developer specifies shared libraries using flags (e.g., -l for linking) in the compilation command, allowing the linker to record these dependencies in the executable. Creating the executable: The resulting executable contains references to the shared libraries but does not include their code. This reduces the executable's size and enables shared access to the libraries. Loading the libraries: Upon execution, the dynamic linker/loader (typically ld.so or ld-linux.so) reads the executable's metadata to identify the required shared libraries and loads them into memory. Resolving symbols: The linker resolves the function calls and variable references to the appropriate addresses in the loaded shared libraries, allowing the executable to use their functionality. Execution: Control is passed to the application's entry point, enabling it to call functions and access data from the linked shared libraries. Explicit Linking (Run-time Dynamic Linking) Explanation Explicit linking, also known as run-time dynamic linking , is a dynamic linking form where the application manually loads libraries during execution. It gives the programmer more control, allowing applications to dynamically load shared libraries and access their functions during execution, rather than linking them at compile time. The programmers will use some specific functions to manage the dynamic linking explicitly . Characteristics Dynamic control: Developers can load libraries based on runtime conditions, providing flexibility. Lazy loading: Libraries can be loaded only when needed, which can improve startup performance. Error handling: Applications can handle scenarios where a library fails to load or is not found. How It Works in Windows Load the DLL: Use LoadLibrary( \"library.dll\" ) to load the desired DLL into the process's address space. Get function pointers: Use GetProcAddress( handle, \"function_name\" ) to obtain pointers to the functions within the loaded DLL. Use the functions: Call the functions using the retrieved pointers. Unload the DLL: Optionally, use FreeLibrary( handle ) to unload the DLL when it\u2019s no longer needed. How It Works in Linux Load the library: Use dlopen( \"library.so\", RTLD_LAZY ) to load the desired shared library into the process's address space. Get function pointers: Use dlsym( handle, \"function_name\" ) to obtain pointers to the functions within the loaded library. Use the functions: Call the functions using the retrieved pointers. Unload the library: Optionally, use dlclose( handle ) to unload the library when it\u2019s no longer needed. Differences Between gcc and g++ Language 1. gcc Primarily the GNU C Compiler, but it can also compile C++ files if passed the appropriate flags. It defaults to treating source files as C code unless you specify C++. 2. g++ A specialized driver for C++ compilation. It automatically links the C++ standard library and handles C++-specific extensions. Linking 1. gcc When compiling C++ files with gcc , you must manually link the C++ standard library (e.g., -lstdc++). 2. g++ Automatically links the C++ standard library without needing extra flags. Header File Handling 1. gcc When used with C, gcc processes headers as C-specific (using .h headers for the most part). 2. g++ Treats headers as C++ files and supports C++ header files (like <iostream> instead of <stdio.h> ). How to Compile One CPP File Source files Main.cpp g++ Main.cpp 1. Usage Preprocess, compile, and link Main.cpp to generate the executable file a.out. 2. Output a.out g++ Main.cpp -o Main.exe 1. Usage Preprocess, compile, and link Main.cpp to generate an executable file. The option -o specifies the name of the executable file. 2. Output Main.exe g++ -E Main.cpp -o Main.i 1. Usage Preprocess Main.cpp to generate a preprocessed file. The option -o specifies the name of the preprocessed file. 2. Output Main.i g++ -S Main.i 1. Usage Compile the preprocessed file to generate an assembly file. 2. Output Main.s g++ -S Main.cpp 1. Usage Preprocess and compile the source file to generate an assembly file. 2. Output Main.s g++ -c Main.s 1. Usage Translate the assembly file into an object file. 2. Output Main.o g++ -c Main.cpp 1. Usage Preprocess and compile the source file to generate an object file. 2. Output Main.o g++ Main.o -o Main.exe 1. Usage Link the object file to generate an executable file. 2. Output Main.exe g++ -On Main.cpp -o Main.exe 1. Usage Compile Main.cpp with optimization level n (where 0 \u2264 n \u2264 3 ). Higher values of n result in longer compile times and more aggressive optimizations. Compiler optimization levels adjust the types of optimizations applied during compilation to balance speed, size, and behavior. No optimization ( -O0 ) : Keeps debugging information intact, with no optimizations. Best for development and debugging. Basic optimization ( -O1 ) : Minor optimizations like dead code elimination improve speed slightly. Suitable for builds needing small improvements without large compile times. Moderate optimization ( -O2 ) : Balances speed and code size with optimizations like loop unrolling and better register usage. Ideal for production builds. Aggressive optimization ( -O3 ) : Adds further optimizations like vectorization, yielding higher speed but potentially increasing code size and instability. Best for performance-critical applications, though requires careful testing. Optimize for size ( -Os ) : Prioritizes a smaller binary, omitting some space-costly optimizations. Useful for memory-constrained environments. Fastest optimization ( -Ofast ) : Maximizes speed with non-standard optimizations, such as unsafe math operations, reducing standard compliance. Suitable for performance-critical applications that can relax stability or portability requirements. Generally, -O2 and -Os are widely used for balanced builds, while -O3 and -Ofast cater to performance-intensive needs where behavior can be less predictable. 2. Output Main.exe g++ -DMACRO_NAME1 -DMACRO_NAME2 ... Main.cpp -o Main.exe 1. Usage Define a series of MACRO for Main.cpp . Used to select which parts of the code should be compiled. 2. Output Main.exe How to Compile Multiple CPP Files Source files Main.cpp Fun.cpp Compile all files in one command 1. Code g++ Main.cpp Fun.cpp -o Main.exe 2. Usage Compile Main.cpp and Fun.cpp into Main.o and Fun.o separately. Link them to generate an executable file. 3. Output Main.o Fun.o Main.exe 4. Alternative: If All Files Are in One Folder g++ *.cpp -o Main.exe Compile All Files Separately and Then Link Them Together 1. Code g++ -c Main.cpp g++ -c Fun.cpp g++ -o Main.o Fun.o -o Main.exe 2. Usage Compile Main.cpp and Fun.cpp into Main.o and Fun.o with separate commands. Link them to generate an executable file. 3. Output Main.o Fun.o Main.exe How to Compile and Link a Library Source files Main.cpp Fun.cpp Setup Paths of Header Files 1. Code g++ Main.cpp Fun.cpp -o Main.exe -I/the/first/path/of/header/files \\ -I/the/second/path/of/header/files ...; How to Link Multiple Static Libraries 1. Code g++ Main.cpp -L/the/first/path/of/static/libraries \\ -L/the/second/path/of/static/libraries ... \\ -Wl,-Bstatic -lxxx -lyyy ... -Wl,-Bdynamic -o Main.exe How to Create a Static Library 1. Code g++ -c Fun.cpp ar rcs libFun.a Fun.o g++ Main.cpp -L. -lFun -o Main.exe 2. Usage Use g++ to compile Fun.cpp into an object file. Use ar to create a static library from the object file. Compile Main.cpp and link it with libFun.a to generate an executable file. 3. Output Fun.o libFun.a Main.exe How to Link Multiple Dynamic Libraries 1. Code g++ Main.cpp -L/the/first/path/of/dynamic/libraries -L/the/second/path/of/dynamic/libraries ... \\ -lxxx -lyyy ... -o Main.exe How to Create a Dynamic Library 1. Code g++ -c -fPIC Fun.cpp -o Fun.o g++ -shared -o libFun.so Fun.o g++ Main.cpp -L. -lFun -o Main.exe 2. Usage Use g++ -c -fPIC to compile Fun.cpp into an object file. Use g++ -shared to create a dynamic library from the object file. Compile Main.cpp and link it with libFun.so to generate an executable file. 3. Output Fun.o libFun.so Main.exe How to Create and Link a Static Library 1. Code g++ -c Fun.cpp ar rcs libFun.a Fun.o g++ -c -fPIC Fun.cpp -o Fun.o g++ -shared -o libFun.so Fun.o g++ Main.cpp -L. -Wl,-Bstatic -lFun -Wl,-Bdynamic -o Main.exe 2. -Wl,-Bstatic Instructs the linker ( ld ) to search for static libraries ( .a files). 3. -Wl,-Bdynamic Reverts the linker back to dynamic libraries, in case you are linking other dynamic libraries afterward. 4. Situation A static library has the same name as a dynamic library in the same folder. 5. Usage Create both a static library and a dynamic library. They have the same name. Link the static library explicitly. 6. Output Fun.o libFun.a libFun.so Main.exe How to Create and Link a Dynamic Library 1. Code g++ -c Fun.cpp ar rcs libFun.a Fun.o g++ -c -fPIC Fun.cpp -o Fun.o g++ -shared -o libFun.so Fun.o g++ Main.cpp -L. -lFun -o Main.exe 2. Situation A dynamic library has the same name as a static library in the same folder. 3. Usage Create both a static library and a dynamic library. They have the same name. Link the dynamic library explicitly. 4. Output Fun.o libFun.a libFun.so Main.exe 5. Special Notes g++ links a dynamic library by default.","title":"Gcc"},{"location":"Gcc/#g-compiler-and-linker","text":"","title":"g++ Compiler and Linker"},{"location":"Gcc/#header-file-preprocess-statement","text":"The compiler will copy and paste them into the object CPP file.","title":"Header File (Preprocess Statement)"},{"location":"Gcc/#cpp-file","text":"The compiler translates the CPP files into assembly code and then into machine code without performing any linking operations. Typically, there is one OBJ file per CPP file , but sometimes multiple CPP files may result in a single OBJ file . During the compilation phase, the compiler also optimizes your code.","title":"CPP File"},{"location":"Gcc/#obj-file-machine-code-file-obj-in-windows-o-in-linux","text":"All OBJ files will be combined into a single file by the linker. The C++ linker can perform certain optimizations , although its primary role is focused on linking object files and libraries rather than optimizing code.","title":"OBJ File (Machine Code File, .obj in Windows, .o in Linux)"},{"location":"Gcc/#linking-static-linking-and-dynamic-linking","text":"","title":"Linking (Static Linking and Dynamic Linking)"},{"location":"Gcc/#libraries","text":"Static ( .lib or .a ) vs dynamic libraries ( .dll or .so ): Linking with static libraries is faster than dynamic libraries because the C++ linker performs optimizations during static linking. Import libraries ( xxxdll.lib files): These files contain references to functions and symbols defined in the xxx.dll files, facilitating linking at compile time. This process ensures that the correct function signatures and addresses are utilized, allowing the linker to ascertain their locations at runtime. Import libraries are specific to Windows , while Linux integrates this functionality directly into dynamic libraries .","title":"Libraries"},{"location":"Gcc/#static-linking","text":"","title":"Static Linking"},{"location":"Gcc/#explanation","text":"Static linking refers to the process of combining all necessary library code into the final executable at compile time . This results in a standalone binary that does not rely on external libraries at runtime .","title":"Explanation"},{"location":"Gcc/#characteristics","text":"Self-contained: The executable includes all the library code it needs. No runtime dependencies: Once compiled, it doesn't require the presence of shared libraries on the target system. Larger executable size: The resulting binary is typically larger due to the inclusion of library code. No versioning issues: The code is fixed at compile time, reducing concerns about library version compatibility.","title":"Characteristics"},{"location":"Gcc/#how-it-works","text":"Compilation: The developer compiles the source code and links it against static library files (usually .lib in windows, .a files in linux). Linking: The linker combines the object files with the static library code, resolving all symbol references. Executable creation: The final output is a single executable file that includes all necessary code.","title":"How It Works"},{"location":"Gcc/#dynamic-linking-implicit-linking-and-explicit-linking","text":"","title":"Dynamic Linking (Implicit Linking and Explicit Linking)"},{"location":"Gcc/#explanation_1","text":"Dynamic linking allows a program to link to libraries at runtime rather than at compile time. This can improve modularity and reduce executable size .","title":"Explanation"},{"location":"Gcc/#characteristics_1","text":"Reduced executable size: Only references to shared libraries are included, keeping the executable smaller. Shared code: Multiple programs can share the same library code in memory, saving resources. Version flexibility: Libraries can be updated independently of the applications that use them, allowing for easier updates and bug fixes. Runtime dependencies: The executable requires the appropriate shared libraries to be present at runtime.","title":"Characteristics"},{"location":"Gcc/#implicit-linking-load-time-dynamic-linking-default-dynamic-linking-standard-dynamic-linking","text":"","title":"Implicit Linking (Load-time Dynamic Linking) (Default Dynamic Linking) (Standard Dynamic Linking)"},{"location":"Gcc/#explanation_2","text":"Implicit linking, also referred to as load-time dynamic linking is a form of dynamic linking where required libraries are automatically loaded at application startup. It is a process whereby an executable is linked to shared libraries at compile time . This method allows the program to utilize functions and variables defined in those libraries without incorporating their code directly into the executable.","title":"Explanation"},{"location":"Gcc/#characteristics_2","text":"Automatic resolution: The operating system loads the shared libraries automatically when the application starts. Simplified development: Developers include the DLL's import library ( .lib file) in Windows or the shared library ( .so file) in Linux during compilation, simplifying the linking process. Single entry point: The operating system resolves function calls from the shared libraries automatically, allowing the application to use them seamlessly. Version dependency: If the required version of a shared library is missing or incompatible, the application may fail to start.","title":"Characteristics"},{"location":"Gcc/#how-it-works-in-windows","text":"Linking with import libraries : When compiling the application, the developer links against the DLL's import library, which provides necessary metadata for the linker. Creating the executable: The resulting executable contains references to the required DLLs but does not embed their code, reducing the executable's size. Loading the DLLs: Upon execution, the Windows loader reads the executable's headers to identify the required DLLs and loads them into memory. Resolving symbols: The loader resolves function calls to the appropriate addresses in the loaded DLLs, ensuring that the application can access the necessary functions and variables. Execution: Control is then passed to the application's entry point, allowing it to call functions from the linked DLLs, enabling shared access to the library's functionality.","title":"How It Works in Windows"},{"location":"Gcc/#how-it-works-in-linux","text":"Linking with shared libraries : When compiling the application, the developer specifies shared libraries using flags (e.g., -l for linking) in the compilation command, allowing the linker to record these dependencies in the executable. Creating the executable: The resulting executable contains references to the shared libraries but does not include their code. This reduces the executable's size and enables shared access to the libraries. Loading the libraries: Upon execution, the dynamic linker/loader (typically ld.so or ld-linux.so) reads the executable's metadata to identify the required shared libraries and loads them into memory. Resolving symbols: The linker resolves the function calls and variable references to the appropriate addresses in the loaded shared libraries, allowing the executable to use their functionality. Execution: Control is passed to the application's entry point, enabling it to call functions and access data from the linked shared libraries.","title":"How It Works in Linux"},{"location":"Gcc/#explicit-linking-run-time-dynamic-linking","text":"","title":"Explicit Linking (Run-time Dynamic Linking)"},{"location":"Gcc/#explanation_3","text":"Explicit linking, also known as run-time dynamic linking , is a dynamic linking form where the application manually loads libraries during execution. It gives the programmer more control, allowing applications to dynamically load shared libraries and access their functions during execution, rather than linking them at compile time. The programmers will use some specific functions to manage the dynamic linking explicitly .","title":"Explanation"},{"location":"Gcc/#characteristics_3","text":"Dynamic control: Developers can load libraries based on runtime conditions, providing flexibility. Lazy loading: Libraries can be loaded only when needed, which can improve startup performance. Error handling: Applications can handle scenarios where a library fails to load or is not found.","title":"Characteristics"},{"location":"Gcc/#how-it-works-in-windows_1","text":"Load the DLL: Use LoadLibrary( \"library.dll\" ) to load the desired DLL into the process's address space. Get function pointers: Use GetProcAddress( handle, \"function_name\" ) to obtain pointers to the functions within the loaded DLL. Use the functions: Call the functions using the retrieved pointers. Unload the DLL: Optionally, use FreeLibrary( handle ) to unload the DLL when it\u2019s no longer needed.","title":"How It Works in Windows"},{"location":"Gcc/#how-it-works-in-linux_1","text":"Load the library: Use dlopen( \"library.so\", RTLD_LAZY ) to load the desired shared library into the process's address space. Get function pointers: Use dlsym( handle, \"function_name\" ) to obtain pointers to the functions within the loaded library. Use the functions: Call the functions using the retrieved pointers. Unload the library: Optionally, use dlclose( handle ) to unload the library when it\u2019s no longer needed.","title":"How It Works in Linux"},{"location":"Gcc/#differences-between-gcc-and-g","text":"","title":"Differences Between gcc and g++"},{"location":"Gcc/#language","text":"","title":"Language"},{"location":"Gcc/#1-gcc","text":"Primarily the GNU C Compiler, but it can also compile C++ files if passed the appropriate flags. It defaults to treating source files as C code unless you specify C++.","title":"1. gcc"},{"location":"Gcc/#2-g","text":"A specialized driver for C++ compilation. It automatically links the C++ standard library and handles C++-specific extensions.","title":"2. g++"},{"location":"Gcc/#linking","text":"","title":"Linking"},{"location":"Gcc/#1-gcc_1","text":"When compiling C++ files with gcc , you must manually link the C++ standard library (e.g., -lstdc++).","title":"1. gcc"},{"location":"Gcc/#2-g_1","text":"Automatically links the C++ standard library without needing extra flags.","title":"2. g++"},{"location":"Gcc/#header-file-handling","text":"","title":"Header File Handling"},{"location":"Gcc/#1-gcc_2","text":"When used with C, gcc processes headers as C-specific (using .h headers for the most part).","title":"1. gcc"},{"location":"Gcc/#2-g_2","text":"Treats headers as C++ files and supports C++ header files (like <iostream> instead of <stdio.h> ).","title":"2. g++"},{"location":"Gcc/#how-to-compile-one-cpp-file","text":"","title":"How to Compile One CPP File"},{"location":"Gcc/#source-files","text":"Main.cpp","title":"Source files"},{"location":"Gcc/#g-maincpp","text":"","title":"g++ Main.cpp"},{"location":"Gcc/#1-usage","text":"Preprocess, compile, and link Main.cpp to generate the executable file a.out.","title":"1. Usage"},{"location":"Gcc/#2-output","text":"a.out","title":"2. Output"},{"location":"Gcc/#g-maincpp-o-mainexe","text":"","title":"g++ Main.cpp -o Main.exe"},{"location":"Gcc/#1-usage_1","text":"Preprocess, compile, and link Main.cpp to generate an executable file. The option -o specifies the name of the executable file.","title":"1. Usage"},{"location":"Gcc/#2-output_1","text":"Main.exe","title":"2. Output"},{"location":"Gcc/#g-e-maincpp-o-maini","text":"","title":"g++ -E Main.cpp -o Main.i"},{"location":"Gcc/#1-usage_2","text":"Preprocess Main.cpp to generate a preprocessed file. The option -o specifies the name of the preprocessed file.","title":"1. Usage"},{"location":"Gcc/#2-output_2","text":"Main.i","title":"2. Output"},{"location":"Gcc/#g-s-maini","text":"","title":"g++ -S Main.i"},{"location":"Gcc/#1-usage_3","text":"Compile the preprocessed file to generate an assembly file.","title":"1. Usage"},{"location":"Gcc/#2-output_3","text":"Main.s","title":"2. Output"},{"location":"Gcc/#g-s-maincpp","text":"","title":"g++ -S Main.cpp"},{"location":"Gcc/#1-usage_4","text":"Preprocess and compile the source file to generate an assembly file.","title":"1. Usage"},{"location":"Gcc/#2-output_4","text":"Main.s","title":"2. Output"},{"location":"Gcc/#g-c-mains","text":"","title":"g++ -c Main.s"},{"location":"Gcc/#1-usage_5","text":"Translate the assembly file into an object file.","title":"1. Usage"},{"location":"Gcc/#2-output_5","text":"Main.o","title":"2. Output"},{"location":"Gcc/#g-c-maincpp","text":"","title":"g++ -c Main.cpp"},{"location":"Gcc/#1-usage_6","text":"Preprocess and compile the source file to generate an object file.","title":"1. Usage"},{"location":"Gcc/#2-output_6","text":"Main.o","title":"2. Output"},{"location":"Gcc/#g-maino-o-mainexe","text":"","title":"g++ Main.o -o Main.exe"},{"location":"Gcc/#1-usage_7","text":"Link the object file to generate an executable file.","title":"1. Usage"},{"location":"Gcc/#2-output_7","text":"Main.exe","title":"2. Output"},{"location":"Gcc/#g-on-maincpp-o-mainexe","text":"","title":"g++ -On Main.cpp -o Main.exe"},{"location":"Gcc/#1-usage_8","text":"Compile Main.cpp with optimization level n (where 0 \u2264 n \u2264 3 ). Higher values of n result in longer compile times and more aggressive optimizations. Compiler optimization levels adjust the types of optimizations applied during compilation to balance speed, size, and behavior. No optimization ( -O0 ) : Keeps debugging information intact, with no optimizations. Best for development and debugging. Basic optimization ( -O1 ) : Minor optimizations like dead code elimination improve speed slightly. Suitable for builds needing small improvements without large compile times. Moderate optimization ( -O2 ) : Balances speed and code size with optimizations like loop unrolling and better register usage. Ideal for production builds. Aggressive optimization ( -O3 ) : Adds further optimizations like vectorization, yielding higher speed but potentially increasing code size and instability. Best for performance-critical applications, though requires careful testing. Optimize for size ( -Os ) : Prioritizes a smaller binary, omitting some space-costly optimizations. Useful for memory-constrained environments. Fastest optimization ( -Ofast ) : Maximizes speed with non-standard optimizations, such as unsafe math operations, reducing standard compliance. Suitable for performance-critical applications that can relax stability or portability requirements. Generally, -O2 and -Os are widely used for balanced builds, while -O3 and -Ofast cater to performance-intensive needs where behavior can be less predictable.","title":"1. Usage"},{"location":"Gcc/#2-output_8","text":"Main.exe","title":"2. Output"},{"location":"Gcc/#g-dmacro_name1-dmacro_name2-maincpp-o-mainexe","text":"","title":"g++ -DMACRO_NAME1 -DMACRO_NAME2 ... Main.cpp -o Main.exe"},{"location":"Gcc/#1-usage_9","text":"Define a series of MACRO for Main.cpp . Used to select which parts of the code should be compiled.","title":"1. Usage"},{"location":"Gcc/#2-output_9","text":"Main.exe","title":"2. Output"},{"location":"Gcc/#how-to-compile-multiple-cpp-files","text":"","title":"How to Compile Multiple CPP Files"},{"location":"Gcc/#source-files_1","text":"Main.cpp Fun.cpp","title":"Source files"},{"location":"Gcc/#compile-all-files-in-one-command","text":"","title":"Compile all files in one command"},{"location":"Gcc/#1-code","text":"g++ Main.cpp Fun.cpp -o Main.exe","title":"1. Code"},{"location":"Gcc/#2-usage","text":"Compile Main.cpp and Fun.cpp into Main.o and Fun.o separately. Link them to generate an executable file.","title":"2. Usage"},{"location":"Gcc/#3-output","text":"Main.o Fun.o Main.exe","title":"3. Output"},{"location":"Gcc/#4-alternative-if-all-files-are-in-one-folder","text":"g++ *.cpp -o Main.exe","title":"4. Alternative: If All Files Are in One Folder"},{"location":"Gcc/#compile-all-files-separately-and-then-link-them-together","text":"","title":"Compile All Files Separately and Then Link Them Together"},{"location":"Gcc/#1-code_1","text":"g++ -c Main.cpp g++ -c Fun.cpp g++ -o Main.o Fun.o -o Main.exe","title":"1. Code"},{"location":"Gcc/#2-usage_1","text":"Compile Main.cpp and Fun.cpp into Main.o and Fun.o with separate commands. Link them to generate an executable file.","title":"2. Usage"},{"location":"Gcc/#3-output_1","text":"Main.o Fun.o Main.exe","title":"3. Output"},{"location":"Gcc/#how-to-compile-and-link-a-library","text":"","title":"How to Compile and Link a Library"},{"location":"Gcc/#source-files_2","text":"Main.cpp Fun.cpp","title":"Source files"},{"location":"Gcc/#setup-paths-of-header-files","text":"","title":"Setup Paths of Header Files"},{"location":"Gcc/#1-code_2","text":"g++ Main.cpp Fun.cpp -o Main.exe -I/the/first/path/of/header/files \\ -I/the/second/path/of/header/files ...;","title":"1. Code"},{"location":"Gcc/#how-to-link-multiple-static-libraries","text":"","title":"How to Link Multiple Static Libraries"},{"location":"Gcc/#1-code_3","text":"g++ Main.cpp -L/the/first/path/of/static/libraries \\ -L/the/second/path/of/static/libraries ... \\ -Wl,-Bstatic -lxxx -lyyy ... -Wl,-Bdynamic -o Main.exe","title":"1. Code"},{"location":"Gcc/#how-to-create-a-static-library","text":"","title":"How to Create a Static Library"},{"location":"Gcc/#1-code_4","text":"g++ -c Fun.cpp ar rcs libFun.a Fun.o g++ Main.cpp -L. -lFun -o Main.exe","title":"1. Code"},{"location":"Gcc/#2-usage_2","text":"Use g++ to compile Fun.cpp into an object file. Use ar to create a static library from the object file. Compile Main.cpp and link it with libFun.a to generate an executable file.","title":"2. Usage"},{"location":"Gcc/#3-output_2","text":"Fun.o libFun.a Main.exe","title":"3. Output"},{"location":"Gcc/#how-to-link-multiple-dynamic-libraries","text":"","title":"How to Link Multiple Dynamic Libraries"},{"location":"Gcc/#1-code_5","text":"g++ Main.cpp -L/the/first/path/of/dynamic/libraries -L/the/second/path/of/dynamic/libraries ... \\ -lxxx -lyyy ... -o Main.exe","title":"1. Code"},{"location":"Gcc/#how-to-create-a-dynamic-library","text":"","title":"How to Create a Dynamic Library"},{"location":"Gcc/#1-code_6","text":"g++ -c -fPIC Fun.cpp -o Fun.o g++ -shared -o libFun.so Fun.o g++ Main.cpp -L. -lFun -o Main.exe","title":"1. Code"},{"location":"Gcc/#2-usage_3","text":"Use g++ -c -fPIC to compile Fun.cpp into an object file. Use g++ -shared to create a dynamic library from the object file. Compile Main.cpp and link it with libFun.so to generate an executable file.","title":"2. Usage"},{"location":"Gcc/#3-output_3","text":"Fun.o libFun.so Main.exe","title":"3. Output"},{"location":"Gcc/#how-to-create-and-link-a-static-library","text":"","title":"How to Create and Link a Static Library"},{"location":"Gcc/#1-code_7","text":"g++ -c Fun.cpp ar rcs libFun.a Fun.o g++ -c -fPIC Fun.cpp -o Fun.o g++ -shared -o libFun.so Fun.o g++ Main.cpp -L. -Wl,-Bstatic -lFun -Wl,-Bdynamic -o Main.exe","title":"1. Code"},{"location":"Gcc/#2-wl-bstatic","text":"Instructs the linker ( ld ) to search for static libraries ( .a files).","title":"2. -Wl,-Bstatic"},{"location":"Gcc/#3-wl-bdynamic","text":"Reverts the linker back to dynamic libraries, in case you are linking other dynamic libraries afterward.","title":"3. -Wl,-Bdynamic"},{"location":"Gcc/#4-situation","text":"A static library has the same name as a dynamic library in the same folder.","title":"4. Situation"},{"location":"Gcc/#5-usage","text":"Create both a static library and a dynamic library. They have the same name. Link the static library explicitly.","title":"5. Usage"},{"location":"Gcc/#6-output","text":"Fun.o libFun.a libFun.so Main.exe","title":"6. Output"},{"location":"Gcc/#how-to-create-and-link-a-dynamic-library","text":"","title":"How to Create and Link a Dynamic Library"},{"location":"Gcc/#1-code_8","text":"g++ -c Fun.cpp ar rcs libFun.a Fun.o g++ -c -fPIC Fun.cpp -o Fun.o g++ -shared -o libFun.so Fun.o g++ Main.cpp -L. -lFun -o Main.exe","title":"1. Code"},{"location":"Gcc/#2-situation","text":"A dynamic library has the same name as a static library in the same folder.","title":"2. Situation"},{"location":"Gcc/#3-usage","text":"Create both a static library and a dynamic library. They have the same name. Link the dynamic library explicitly.","title":"3. Usage"},{"location":"Gcc/#4-output","text":"Fun.o libFun.a libFun.so Main.exe","title":"4. Output"},{"location":"Gcc/#5-special-notes","text":"g++ links a dynamic library by default.","title":"5. Special Notes"},{"location":"Git/","text":"Git Perface Create and Initialize a Repository Code The Workflow of git add TargetList and git commit -m \"Your comments\" The Workflow Explanation Add Files to a Branch Delete Files of a Branch Check the Status Discard Current Modifications Check the Differences Check the Revision History Revert to the Previous Version While Keeping Current Modifications Revert to the Previous Version and Discard Current Modifications Link the Local Repository to a Remote Repository Clone a Remote Repository Update the Local Repository form a Remote Repository Push the Local Repository to the Remote Repository Check Branches Create a New Branch and Switch to The New Branch Merge Another Branch into the Current Branch Delete a Branch Stash Current Changes and Restore Previous Changes Copy the Specific Modification from Another Branch to the Current Branch Push the Current Branch to The Remote Repository Reorganize the Commit History Tag Commits Git Perface This file lists only common Git commands. For a deeper understanding of Git, you should learn from a comprehensive Git tutorial. Create and Initialize a Repository Code cd ~ mkdir repository_name cd repository_name git init ### Edit lots of files. git add TargetList git commit -m \"Your comments\" The Workflow of git add TargetList and git commit -m \"Your comments\" The Workflow flowchart LR A[Working Directory] -->|git add TargetList| B[Stage #40;Index#41;] B -->|git commit -m #quot;Your comments#quot;| C[Current Branch] D[Head] --> C subgraph Repository B C end Explanation Working directory: This is the directory where you work on your project. Typically, it serves as the root directory and often contains a .git directory, which primarily includes the config file, the staging area, branches, and the head. You can use the exa command to explore its tree structure. Stage: After executing the git add TargetList command, all changes to the files in TargetList are submitted to the staging area. Current branch: This refers to the branch you are currently working on in your project. HEAD: It is a pointer that refers to the current commit in your local repository. It indicates where you are in the commit history. When you make new commits, HEAD moves forward to point to the latest commit. master: It is typically the name of the main branch in your local repository. It represents the latest commit on that branch. When you switch to the master branch, HEAD points to master. origin/master: It is a remote-tracking branch that represents the state of the master branch on the remote repository (usually named origin). It reflects the last known state of the master branch on the remote when you last fetched or pulled changes. It doesn't change unless you explicitly fetch or pull. origin/HEAD: It is a symbolic reference that points to the default branch of the origin remote repository, often pointing to origin/master. It helps Git determine which branch to track for new clones of the repository. Add Files to a Branch git add TargetList git commit -m \"Your comments\" Delete Files of a Branch git rm TargetList git commit -m \"Your comments\" Check the Status git status Discard Current Modifications git checkout -- TargetList Check the Differences git log -Number(How many, Optional) git diff CommitNumber(A sequence of number, Optional) TargetList(Optional) Check the Revision History git log -Number(How many, Optional) git show CommitNumber(A sequence of number, Optional) TargetList(Optional) Revert to the Previous Version While Keeping Current Modifications git log -Number(How many, Optional) git reset CommitNumber(A sequence of number) TargetList(Optional) Revert to the Previous Version and Discard Current Modifications git log -Number(How many, Optional) git reset --hard CommitNumber(A sequence of number) TargetList(Optional) Link the Local Repository to a Remote Repository git remote add origin TheRemoteRepositoryLink git push -u origin CurrentBranch Clone a Remote Repository git clone TheRemoteRepositoryLink // If the remote repository is too large to clone successfully, use the following commands. git clone TheRemoteRepositoryLink --depth 1 cd TheRemoteRepositoryName git fetch --unshallow Update the Local Repository form a Remote Repository git pull Push the Local Repository to the Remote Repository git push git push -f # Force Check Branches git branch Create a New Branch and Switch to The New Branch # Old method git checkout -b ANewBranch # Create and swithc # Old method git branch ANewBranch # Create git checkout ANewBranch # Switch # New method git switch -c ANewBranch # Create and swithc # New method git branch ANewBranch # Create git switch ANewBranch # Switch Merge Another Branch into the Current Branch git merge AnotherBranch git merge --no-ff -m \"Your comments\" AnotherBranch # Ban fast forward Delete a Branch git branch -d ABranch git branch -D ABranch # Force Stash Current Changes and Restore Previous Changes git stash # Stash current changes git stash list # List all stashes # The structure of the stash is a stack. git stash pop # Restore the recent stash and delete it in the stash. git stash list # List all stashes git stash apply stash@{number}(Optional) # Restore the recent stash git stash drop stash@{number}(Optional) # Delete it in the stash. # The larger the number, the earlier the stash. Copy the Specific Modification from Another Branch to the Current Branch git switch AnotherBranch git log # Find the specific Modification git switch CurrentBranch git cherry-pick CommitNumber Push the Current Branch to The Remote Repository git push origin CurrentBranch Reorganize the Commit History git rebase Tag Commits git tag #Check tags git tag TagName CommitNumber(Optional) # If you tag CommitNumber with TagName, TagName can replace CommitNumber in git commands that require it.","title":"Git"},{"location":"Git/#git","text":"","title":"Git"},{"location":"Git/#perface","text":"This file lists only common Git commands. For a deeper understanding of Git, you should learn from a comprehensive Git tutorial.","title":"Perface"},{"location":"Git/#create-and-initialize-a-repository","text":"","title":"Create and Initialize a Repository"},{"location":"Git/#code","text":"cd ~ mkdir repository_name cd repository_name git init ### Edit lots of files. git add TargetList git commit -m \"Your comments\"","title":"Code"},{"location":"Git/#the-workflow-of-git-add-targetlist-and-git-commit-m-your-comments","text":"","title":"The Workflow of git add TargetList and git commit -m \"Your comments\""},{"location":"Git/#the-workflow","text":"flowchart LR A[Working Directory] -->|git add TargetList| B[Stage #40;Index#41;] B -->|git commit -m #quot;Your comments#quot;| C[Current Branch] D[Head] --> C subgraph Repository B C end","title":"The Workflow"},{"location":"Git/#explanation","text":"Working directory: This is the directory where you work on your project. Typically, it serves as the root directory and often contains a .git directory, which primarily includes the config file, the staging area, branches, and the head. You can use the exa command to explore its tree structure. Stage: After executing the git add TargetList command, all changes to the files in TargetList are submitted to the staging area. Current branch: This refers to the branch you are currently working on in your project. HEAD: It is a pointer that refers to the current commit in your local repository. It indicates where you are in the commit history. When you make new commits, HEAD moves forward to point to the latest commit. master: It is typically the name of the main branch in your local repository. It represents the latest commit on that branch. When you switch to the master branch, HEAD points to master. origin/master: It is a remote-tracking branch that represents the state of the master branch on the remote repository (usually named origin). It reflects the last known state of the master branch on the remote when you last fetched or pulled changes. It doesn't change unless you explicitly fetch or pull. origin/HEAD: It is a symbolic reference that points to the default branch of the origin remote repository, often pointing to origin/master. It helps Git determine which branch to track for new clones of the repository.","title":"Explanation"},{"location":"Git/#add-files-to-a-branch","text":"git add TargetList git commit -m \"Your comments\"","title":"Add Files to a Branch"},{"location":"Git/#delete-files-of-a-branch","text":"git rm TargetList git commit -m \"Your comments\"","title":"Delete Files of a Branch"},{"location":"Git/#check-the-status","text":"git status","title":"Check the Status"},{"location":"Git/#discard-current-modifications","text":"git checkout -- TargetList","title":"Discard Current Modifications"},{"location":"Git/#check-the-differences","text":"git log -Number(How many, Optional) git diff CommitNumber(A sequence of number, Optional) TargetList(Optional)","title":"Check the Differences"},{"location":"Git/#check-the-revision-history","text":"git log -Number(How many, Optional) git show CommitNumber(A sequence of number, Optional) TargetList(Optional)","title":"Check the Revision History"},{"location":"Git/#revert-to-the-previous-version-while-keeping-current-modifications","text":"git log -Number(How many, Optional) git reset CommitNumber(A sequence of number) TargetList(Optional)","title":"Revert to the Previous Version While Keeping Current Modifications"},{"location":"Git/#revert-to-the-previous-version-and-discard-current-modifications","text":"git log -Number(How many, Optional) git reset --hard CommitNumber(A sequence of number) TargetList(Optional)","title":"Revert to the Previous Version and Discard Current Modifications"},{"location":"Git/#link-the-local-repository-to-a-remote-repository","text":"git remote add origin TheRemoteRepositoryLink git push -u origin CurrentBranch","title":"Link the Local Repository to a Remote Repository"},{"location":"Git/#clone-a-remote-repository","text":"git clone TheRemoteRepositoryLink // If the remote repository is too large to clone successfully, use the following commands. git clone TheRemoteRepositoryLink --depth 1 cd TheRemoteRepositoryName git fetch --unshallow","title":"Clone a Remote Repository"},{"location":"Git/#update-the-local-repository-form-a-remote-repository","text":"git pull","title":"Update the Local Repository form a Remote Repository"},{"location":"Git/#push-the-local-repository-to-the-remote-repository","text":"git push git push -f # Force","title":"Push the Local Repository to the Remote Repository"},{"location":"Git/#check-branches","text":"git branch","title":"Check Branches"},{"location":"Git/#create-a-new-branch-and-switch-to-the-new-branch","text":"# Old method git checkout -b ANewBranch # Create and swithc # Old method git branch ANewBranch # Create git checkout ANewBranch # Switch # New method git switch -c ANewBranch # Create and swithc # New method git branch ANewBranch # Create git switch ANewBranch # Switch","title":"Create a New Branch and Switch to The New Branch"},{"location":"Git/#merge-another-branch-into-the-current-branch","text":"git merge AnotherBranch git merge --no-ff -m \"Your comments\" AnotherBranch # Ban fast forward","title":"Merge Another Branch into the Current Branch"},{"location":"Git/#delete-a-branch","text":"git branch -d ABranch git branch -D ABranch # Force","title":"Delete a Branch"},{"location":"Git/#stash-current-changes-and-restore-previous-changes","text":"git stash # Stash current changes git stash list # List all stashes # The structure of the stash is a stack. git stash pop # Restore the recent stash and delete it in the stash. git stash list # List all stashes git stash apply stash@{number}(Optional) # Restore the recent stash git stash drop stash@{number}(Optional) # Delete it in the stash. # The larger the number, the earlier the stash.","title":"Stash Current Changes and Restore Previous Changes"},{"location":"Git/#copy-the-specific-modification-from-another-branch-to-the-current-branch","text":"git switch AnotherBranch git log # Find the specific Modification git switch CurrentBranch git cherry-pick CommitNumber","title":"Copy the Specific Modification from Another Branch to the Current Branch"},{"location":"Git/#push-the-current-branch-to-the-remote-repository","text":"git push origin CurrentBranch","title":"Push the Current Branch to The Remote Repository"},{"location":"Git/#reorganize-the-commit-history","text":"git rebase","title":"Reorganize the Commit History"},{"location":"Git/#tag-commits","text":"git tag #Check tags git tag TagName CommitNumber(Optional) # If you tag CommitNumber with TagName, TagName can replace CommitNumber in git commands that require it.","title":"Tag Commits"},{"location":"Handles/","text":"Handles Explanation Types of Handles Usage Handles Explanation Handles are an abstract reference or identifier for a resource (e.g., file, memory, window) that is managed by the operating system or runtime system . They allow interaction with resources without exposing low-level details , ensuring safe and controlled access . They provides abstraction , resource management , and cross-platform compatibility . Types of Handles File handle: A reference used to interact with a file (e.g., open, read, write). Window handle (HWND): A unique identifier for a window or UI component in GUI programming. Memory handle: A reference to a block of memory, typically used for managing resources like shared memory. Object handle: A pointer or reference to an object, often used in object-oriented programming to manage object instances. Database handle: A reference to a database connection used to execute SQL queries and retrieve results. Usage File I/O operations: Interacting with files via file handles. GUI programming: Managing windows or UI elements through window handles. Memory management: Interacting with allocated memory via memory handles. Database operations: Executing queries and transactions using a database handle.","title":"Handles"},{"location":"Handles/#handles","text":"","title":"Handles"},{"location":"Handles/#explanation","text":"Handles are an abstract reference or identifier for a resource (e.g., file, memory, window) that is managed by the operating system or runtime system . They allow interaction with resources without exposing low-level details , ensuring safe and controlled access . They provides abstraction , resource management , and cross-platform compatibility .","title":"Explanation"},{"location":"Handles/#types-of-handles","text":"File handle: A reference used to interact with a file (e.g., open, read, write). Window handle (HWND): A unique identifier for a window or UI component in GUI programming. Memory handle: A reference to a block of memory, typically used for managing resources like shared memory. Object handle: A pointer or reference to an object, often used in object-oriented programming to manage object instances. Database handle: A reference to a database connection used to execute SQL queries and retrieve results.","title":"Types of Handles"},{"location":"Handles/#usage","text":"File I/O operations: Interacting with files via file handles. GUI programming: Managing windows or UI elements through window handles. Memory management: Interacting with allocated memory via memory handles. Database operations: Executing queries and transactions using a database handle.","title":"Usage"},{"location":"HidingOverloadingOverridingAndOverwriting/","text":"Hiding, Overloading, Overriding, and Overwriting Hiding (Name Hiding) Explanation Syntax How to Access Hidden Function Overloading Explanation Syntax Overriding Explanation Syntax Overwriting (Not a C++ Term) Explanation Syntax Hiding, Overloading, Overriding, and Overwriting Hiding (Name Hiding) Explanation Hiding occurs when a derived class declares a function (or variable) with the same name as a function (or variable) in the base class , regardless of the parameters. The base class function is hidden in the derived class scope, even if the signatures (parameter types) differ . This can lead to confusion or errors because the base class function is no longer accessible directly from the derived class. Syntax class Base { public: RetType1 funcName( para_list1 ) { ...; }; }; class Derived: public Base { public: RetType2 funcName( para_list2 ) { ...; }; }; int main() { Derived obj_name; // Error: Base::funcName( para_list1 ) is hidden by Derived::funcName( para_list2 ) obj_name.show(); }; How to Access Hidden Function obj_name.Base::funcName( para_list1 ); // Calls Base class funcName( para_list1 ) Overloading Explanation Overloading occurs when two or more functions in the same scope have the same name but different parameter types or numbers of parameters . Additionally, if a keyword appears between the function parameters and the function body , it can be used to create overloaded functions because their signatures are different . For example, const functions and noexcept functions . However, the return type does not play a role in distinguishing overloaded functions. Functions cannot be overloaded solely based on different return types . C++ allows overloading based on the number of arguments, their types, or both . Overloading is resolved at compile time ( static polymorphism ). Syntax class ClassName { public: RetType1 funcName( para_list1 ) { ...; }; RetType1 funcName( para_list1 ) const { ...; }; RetType1 funcName( para_list1 ) noexcept { ...; }; RetType2 funcName( para_list2 ) { ...; }; RetType2 funcName( para_list3 ) { ...; }; }; Overriding Explanation Overriding occurs when a derived class provides its own implementation of a virtual function (or a pure virtual function) that is already defined in the base class. The function in the derived class must have the same signature as the base class's virtual function . This means, for a function in a derived class to override a function in a base class, it must have the same name , parameter list , and qualifiers as the function in the base class. Overriding is resolved at runtime ( dynamic polymorphism ). Syntax class Base { public: virtual RetType funcName( para_list ) {}; }; class Derived: public Base { public: virtual RetType funcName( para_list ) override { // This function overrides Base::funcName(). }; }; int main() { Base* obj = new Derived(); obj->funcName( arg_list ); // Calls Derived class funcName (runtime polymorphism). }; Overwriting (Not a C++ Term) Explanation Overwriting is not a formal term in C++ . However, it is sometimes colloquially used to describe a situation where a function or variable in a derived class replaces or redefines a function or variable from a base class . This serves as a general description rather than a specific C++ concept. Additionally, the term \"overwriting\" typically refers to the process of replacing an existing value in memory , which includes assigning a new value to an existing variable to replace the old value and writing data to unintended memory locations, often resulting in undefined behavior or memory corruption. This can occur in various contexts, such as variables, function definitions, or data structures. Syntax class Base { public: Type _mem = initializer1; }; class Derived: public Base { public: Type _mem = initializer2; // Overwrites Base::_mem. };","title":"Hiding, Overloading, Overriding, and Overwriting"},{"location":"HidingOverloadingOverridingAndOverwriting/#hiding-overloading-overriding-and-overwriting","text":"","title":"Hiding, Overloading, Overriding, and Overwriting"},{"location":"HidingOverloadingOverridingAndOverwriting/#hiding-name-hiding","text":"","title":"Hiding (Name Hiding)"},{"location":"HidingOverloadingOverridingAndOverwriting/#explanation","text":"Hiding occurs when a derived class declares a function (or variable) with the same name as a function (or variable) in the base class , regardless of the parameters. The base class function is hidden in the derived class scope, even if the signatures (parameter types) differ . This can lead to confusion or errors because the base class function is no longer accessible directly from the derived class.","title":"Explanation"},{"location":"HidingOverloadingOverridingAndOverwriting/#syntax","text":"class Base { public: RetType1 funcName( para_list1 ) { ...; }; }; class Derived: public Base { public: RetType2 funcName( para_list2 ) { ...; }; }; int main() { Derived obj_name; // Error: Base::funcName( para_list1 ) is hidden by Derived::funcName( para_list2 ) obj_name.show(); };","title":"Syntax"},{"location":"HidingOverloadingOverridingAndOverwriting/#how-to-access-hidden-function","text":"obj_name.Base::funcName( para_list1 ); // Calls Base class funcName( para_list1 )","title":"How to Access Hidden Function"},{"location":"HidingOverloadingOverridingAndOverwriting/#overloading","text":"","title":"Overloading"},{"location":"HidingOverloadingOverridingAndOverwriting/#explanation_1","text":"Overloading occurs when two or more functions in the same scope have the same name but different parameter types or numbers of parameters . Additionally, if a keyword appears between the function parameters and the function body , it can be used to create overloaded functions because their signatures are different . For example, const functions and noexcept functions . However, the return type does not play a role in distinguishing overloaded functions. Functions cannot be overloaded solely based on different return types . C++ allows overloading based on the number of arguments, their types, or both . Overloading is resolved at compile time ( static polymorphism ).","title":"Explanation"},{"location":"HidingOverloadingOverridingAndOverwriting/#syntax_1","text":"class ClassName { public: RetType1 funcName( para_list1 ) { ...; }; RetType1 funcName( para_list1 ) const { ...; }; RetType1 funcName( para_list1 ) noexcept { ...; }; RetType2 funcName( para_list2 ) { ...; }; RetType2 funcName( para_list3 ) { ...; }; };","title":"Syntax"},{"location":"HidingOverloadingOverridingAndOverwriting/#overriding","text":"","title":"Overriding"},{"location":"HidingOverloadingOverridingAndOverwriting/#explanation_2","text":"Overriding occurs when a derived class provides its own implementation of a virtual function (or a pure virtual function) that is already defined in the base class. The function in the derived class must have the same signature as the base class's virtual function . This means, for a function in a derived class to override a function in a base class, it must have the same name , parameter list , and qualifiers as the function in the base class. Overriding is resolved at runtime ( dynamic polymorphism ).","title":"Explanation"},{"location":"HidingOverloadingOverridingAndOverwriting/#syntax_2","text":"class Base { public: virtual RetType funcName( para_list ) {}; }; class Derived: public Base { public: virtual RetType funcName( para_list ) override { // This function overrides Base::funcName(). }; }; int main() { Base* obj = new Derived(); obj->funcName( arg_list ); // Calls Derived class funcName (runtime polymorphism). };","title":"Syntax"},{"location":"HidingOverloadingOverridingAndOverwriting/#overwriting-not-a-c-term","text":"","title":"Overwriting (Not a C++ Term)"},{"location":"HidingOverloadingOverridingAndOverwriting/#explanation_3","text":"Overwriting is not a formal term in C++ . However, it is sometimes colloquially used to describe a situation where a function or variable in a derived class replaces or redefines a function or variable from a base class . This serves as a general description rather than a specific C++ concept. Additionally, the term \"overwriting\" typically refers to the process of replacing an existing value in memory , which includes assigning a new value to an existing variable to replace the old value and writing data to unintended memory locations, often resulting in undefined behavior or memory corruption. This can occur in various contexts, such as variables, function definitions, or data structures.","title":"Explanation"},{"location":"HidingOverloadingOverridingAndOverwriting/#syntax_3","text":"class Base { public: Type _mem = initializer1; }; class Derived: public Base { public: Type _mem = initializer2; // Overwrites Base::_mem. };","title":"Syntax"},{"location":"IntroductionToTheCPPSTL/","text":"Introduction to C++ STL Explanation Containers Explanation Types of Containers Header File Algorithms Explanation Common Algorithms Header File Iterators Explanation Types of Iterators Header File Function Objects and Lambdas Explanation Usage Header File Input/Output (I/O) Explanation Common Classes Header File Utilities Explanation Common Utilities Header File EASTL Notes Introduction to C++ STL Explanation The C++ Standard Template Library (STL) is a powerful collection of template classes and functions that provide generic and reusable components. It consists of various components that work together to simplify the development of complex programs. Because it is a collection of template classes and functions , all syntax applicable to templates, classes, and functions can also be applied to it. The C++ STL components are typically defined in header files because they rely heavily on templates. Below are the six basic components of STL. Containers Explanation Containers are data structures that store collections of objects. They manage the storage , organization , and access of data . Containers in STL can be broadly categorized into four types : sequence containers , associative containers , unordered associative containers and container adopters . Types of Containers Sequence containers: Store elements in a linear order. std::vector : A dynamic array that allows fast random access. std::list : A doubly-linked list that allows efficient insertions and deletions. std::deque : A double-ended queue that allows fast insertions and removals from both ends. Associative containers: Store elements in a specific order, typically based on keys. std::set : A collection of unique keys that are sorted automatically. std::multiset : A collection of keys that are sorted automatically. std::map : A collection of key-value pairs where keys are unique and sorted. std::multimap : A collection of key-value pairs where keys are not unique and sorted. Unordered associative containers: Store elements without a specific order, allowing for faster access. std::unordered_set : A collection of unique keys with no order. std::unordered_multiset : A collection of keys with no order. std::unordered_map : A collection of key-value pairs with no order and each key is unique. std::unordered_multimap : A collection of key-value pairs with no order and multiple elements Container adaptors: Provide a specific interface for using underlying containers. std::stack : A last-in, first-out (LIFO) data structure that allows access to the most recently added element. std::queue : A first-in, first-out (FIFO) data structure that allows access to the oldest added element. std::priority_queue : A data structure that allows access to the largest (or smallest) element based on a priority criterion. flat_set : A sorted collection of unique keys, implemented using a std::vector . flat_multiset : A sorted collection of keys that can contain duplicates, also implemented using a std::vector . flat_map : A sorted collection of key-value pairs where keys are unique, implemented using a std::vector . flat_multimap : A sorted collection of key-value pairs where keys can be duplicated, implemented using a std::vector . can have the equivalent key. Header File <vector> , <list> , <deque> , <set> , <map> , <unordered_set> , <unordered_map> , <stack> , <queue> , <flat_set> , <flat_map> . Algorithms Explanation Algorithms are a set of functions that operate on containers . They provide a range of operations such as searching, sorting, transforming, and manipulating data within containers. Common Algorithms std::sort : Sorts the elements in a range. std::find : Searches for a value in a range. std::copy : Copies elements from one range to another. Header File <algorithm> . Iterators Explanation Iterators are objects that allow traversal through the elements of a container . They provide a uniform way to access container elements without exposing the underlying implementation. It is not a pointer , but behaves like one (stores an address and can be dereferenced) because it encapsulates a pointer and overloads certain operators . When a container resizes its capacity or rehashes , its iterators may become invalid . Using invalid iterators causes undefined behaviors . More information on iterator validity after modification operations is provided below. iterator invalidation . Types of Iterators Input iterators: Read elements from a container. Output iterators: Write elements to a container. Forward iterators: Move forward in a container and allow reading and writing. Bidirectional iterators: Move in both directions (forward and backward). Random Access iterators: Provide direct access to elements using offsets. Header File <iterator> . Function Objects and Lambdas Explanation Function objects (functors) are objects that can be called as if they were functions . They overload the function call operator() ; for example, for comparisons, sorting, etc. They can store state and are often used in algorithms to customize their behavior . Lambda expressions provide a concise way to define anonymous function objects. Usage Function objects can be created by overloading the operator() . Lambda expressions can be defined using the syntax [capture]( para_list ) { body; }; . More information about lambdas is provided in Section 1Lambda Functions . Header File <functional> Input/Output (I/O) Explanation The I/O component of STL provides facilities for reading and writing data . It simplifies interactions with various input and output sources, such as files and standard input/output streams. Common Classes std::istream : For input streams (e.g., reading from the console). std::ostream : For output streams (e.g., writing to the console). std::fstream : For file input and output. Header File <iostream> , <fstream> , <sstream> Utilities Explanation Utilities in STL provide general-purpose functionality that aids in programming tasks. This includes support for pairs, tuples, and smart pointers. Common Utilities std::pair : A simple container to store two values. std::tuple : A fixed-size collection of heterogeneous values. std::unique_ptr : A smart pointer that manages a dynamically allocated object. Header File <utility> , <tuple> , <memory> EASTL EASTL is a open source library , optimized for game developers . The performance of EASTL is higher than STL . Notes Most methods that add or remove elements in containers return a valid iterator. References and iterators to individual elements within a container can become invalid after adding or inserting elements","title":"Introduction to C++ STL"},{"location":"IntroductionToTheCPPSTL/#introduction-to-c-stl","text":"","title":"Introduction to C++ STL"},{"location":"IntroductionToTheCPPSTL/#explanation","text":"The C++ Standard Template Library (STL) is a powerful collection of template classes and functions that provide generic and reusable components. It consists of various components that work together to simplify the development of complex programs. Because it is a collection of template classes and functions , all syntax applicable to templates, classes, and functions can also be applied to it. The C++ STL components are typically defined in header files because they rely heavily on templates. Below are the six basic components of STL.","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#containers","text":"","title":"Containers"},{"location":"IntroductionToTheCPPSTL/#explanation_1","text":"Containers are data structures that store collections of objects. They manage the storage , organization , and access of data . Containers in STL can be broadly categorized into four types : sequence containers , associative containers , unordered associative containers and container adopters .","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#types-of-containers","text":"Sequence containers: Store elements in a linear order. std::vector : A dynamic array that allows fast random access. std::list : A doubly-linked list that allows efficient insertions and deletions. std::deque : A double-ended queue that allows fast insertions and removals from both ends. Associative containers: Store elements in a specific order, typically based on keys. std::set : A collection of unique keys that are sorted automatically. std::multiset : A collection of keys that are sorted automatically. std::map : A collection of key-value pairs where keys are unique and sorted. std::multimap : A collection of key-value pairs where keys are not unique and sorted. Unordered associative containers: Store elements without a specific order, allowing for faster access. std::unordered_set : A collection of unique keys with no order. std::unordered_multiset : A collection of keys with no order. std::unordered_map : A collection of key-value pairs with no order and each key is unique. std::unordered_multimap : A collection of key-value pairs with no order and multiple elements Container adaptors: Provide a specific interface for using underlying containers. std::stack : A last-in, first-out (LIFO) data structure that allows access to the most recently added element. std::queue : A first-in, first-out (FIFO) data structure that allows access to the oldest added element. std::priority_queue : A data structure that allows access to the largest (or smallest) element based on a priority criterion. flat_set : A sorted collection of unique keys, implemented using a std::vector . flat_multiset : A sorted collection of keys that can contain duplicates, also implemented using a std::vector . flat_map : A sorted collection of key-value pairs where keys are unique, implemented using a std::vector . flat_multimap : A sorted collection of key-value pairs where keys can be duplicated, implemented using a std::vector . can have the equivalent key.","title":"Types of Containers"},{"location":"IntroductionToTheCPPSTL/#header-file","text":"<vector> , <list> , <deque> , <set> , <map> , <unordered_set> , <unordered_map> , <stack> , <queue> , <flat_set> , <flat_map> .","title":"Header File"},{"location":"IntroductionToTheCPPSTL/#algorithms","text":"","title":"Algorithms"},{"location":"IntroductionToTheCPPSTL/#explanation_2","text":"Algorithms are a set of functions that operate on containers . They provide a range of operations such as searching, sorting, transforming, and manipulating data within containers.","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#common-algorithms","text":"std::sort : Sorts the elements in a range. std::find : Searches for a value in a range. std::copy : Copies elements from one range to another.","title":"Common Algorithms"},{"location":"IntroductionToTheCPPSTL/#header-file_1","text":"<algorithm> .","title":"Header File"},{"location":"IntroductionToTheCPPSTL/#iterators","text":"","title":"Iterators"},{"location":"IntroductionToTheCPPSTL/#explanation_3","text":"Iterators are objects that allow traversal through the elements of a container . They provide a uniform way to access container elements without exposing the underlying implementation. It is not a pointer , but behaves like one (stores an address and can be dereferenced) because it encapsulates a pointer and overloads certain operators . When a container resizes its capacity or rehashes , its iterators may become invalid . Using invalid iterators causes undefined behaviors . More information on iterator validity after modification operations is provided below. iterator invalidation .","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#types-of-iterators","text":"Input iterators: Read elements from a container. Output iterators: Write elements to a container. Forward iterators: Move forward in a container and allow reading and writing. Bidirectional iterators: Move in both directions (forward and backward). Random Access iterators: Provide direct access to elements using offsets.","title":"Types of Iterators"},{"location":"IntroductionToTheCPPSTL/#header-file_2","text":"<iterator> .","title":"Header File"},{"location":"IntroductionToTheCPPSTL/#function-objects-and-lambdas","text":"","title":"Function Objects and Lambdas"},{"location":"IntroductionToTheCPPSTL/#explanation_4","text":"Function objects (functors) are objects that can be called as if they were functions . They overload the function call operator() ; for example, for comparisons, sorting, etc. They can store state and are often used in algorithms to customize their behavior . Lambda expressions provide a concise way to define anonymous function objects.","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#usage","text":"Function objects can be created by overloading the operator() . Lambda expressions can be defined using the syntax [capture]( para_list ) { body; }; . More information about lambdas is provided in Section 1Lambda Functions .","title":"Usage"},{"location":"IntroductionToTheCPPSTL/#header-file_3","text":"<functional>","title":"Header File"},{"location":"IntroductionToTheCPPSTL/#inputoutput-io","text":"","title":"Input/Output (I/O)"},{"location":"IntroductionToTheCPPSTL/#explanation_5","text":"The I/O component of STL provides facilities for reading and writing data . It simplifies interactions with various input and output sources, such as files and standard input/output streams.","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#common-classes","text":"std::istream : For input streams (e.g., reading from the console). std::ostream : For output streams (e.g., writing to the console). std::fstream : For file input and output.","title":"Common Classes"},{"location":"IntroductionToTheCPPSTL/#header-file_4","text":"<iostream> , <fstream> , <sstream>","title":"Header File"},{"location":"IntroductionToTheCPPSTL/#utilities","text":"","title":"Utilities"},{"location":"IntroductionToTheCPPSTL/#explanation_6","text":"Utilities in STL provide general-purpose functionality that aids in programming tasks. This includes support for pairs, tuples, and smart pointers.","title":"Explanation"},{"location":"IntroductionToTheCPPSTL/#common-utilities","text":"std::pair : A simple container to store two values. std::tuple : A fixed-size collection of heterogeneous values. std::unique_ptr : A smart pointer that manages a dynamically allocated object.","title":"Common Utilities"},{"location":"IntroductionToTheCPPSTL/#header-file_5","text":"<utility> , <tuple> , <memory>","title":"Header File"},{"location":"IntroductionToTheCPPSTL/#eastl","text":"EASTL is a open source library , optimized for game developers . The performance of EASTL is higher than STL .","title":"EASTL"},{"location":"IntroductionToTheCPPSTL/#notes","text":"Most methods that add or remove elements in containers return a valid iterator. References and iterators to individual elements within a container can become invalid after adding or inserting elements","title":"Notes"},{"location":"ListsAndForwardLists/","text":"Lists (Doubly-linked Lists) Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::list Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Forward Lists (Singly-linked Lists) Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::forward_list Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Lists (Doubly-linked Lists) Explanation Lists are sequence containers that allow constant-time insertion and deletion operations anywhere within the sequence, as well as iteration in both directions . List containers are implemented as doubly linked lists . These lists can store their elements in different and unrelated storage locations. They can be implemented using two pointers in a class or structure , allowing them to dynamically grow in size . Adding and removing elements at the beginning or end of a list costs only constant time , while vectors are generally optimized for additions and removals at the end . Unlike vectors, lists do not support random access , meaning they cannot be directly accessed at a specific index or have elements retrieved by their index numbers. Their header file is <list> . Declaration Syntax std::list< Type > list_name; std::list< Type >* list_ptr; Initialization Syntax // Initializer list constructor. std::list< Type > list_name = { ... }; // Initializer list constructor. std::list< Type > list_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::list< Type > list_name; // No initialization, contain garbage values and behave unpredictably. std::list< Type > list_name( size ); // Initialization with the specific value. std::list< Type > list_name( size, value ); // Initializer list constructor. std::list< Type > list_name1 = { ... }; // Copy constructor. std::list< Type > list_name2( list_name1 ); // Initializer list constructor. std::list< Type > list_name1 = { ... }; // Copy constructor. std::list< Type > list_name2 = list_name1; // Initializer list constructor. std::list< Type > list_name1( { ... } ); // Move constructor. std::list< Type > list_name2 = std::move( list_name1 ); // Constructs the container with the contents of the range `[first, last)`. std::list< Type > list_name1( { ... } ); std::list< Type > list_name2( list_name1.begin(), list_name1.end() ); std::list< Type >* list_ptr = new std::list< Type >( size ); std::list< Type >* list_ptr = new std::list< Type >( size, value ); // Initializer list constructor. std::list< Type > list_name = { ... }; std::list< Type >* list_ptr = new std::list< Type >( list_name ); std::list< Type >* list_ptr = new std::list< Type >{ ... }; Syntax for Deleting std::list Pointers delete list_ptr; Members and Related Stuffs Links std::list in cplusplus . std::list in cppreference . Template Parameters T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Functions (constructor): Constructs the list (public member function). (destructor): Destructs the list (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). front : Access the first element (public member function). back : Access the last element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). erase : Erases elements and returns a valid iterator (public member function). push_back : Adds an element to the end (public member function). emplace_back : Constructs an element in-place at the end (public member function). append_range (C++23): Adds a range of elements to the end (public member function). pop_back : Removes the last element (public member function). push_front : Inserts an element to the beginning (public member function). emplace_front : Constructs an element in-place at the beginning (public member function). prepend_range (C++23): Adds a range of elements to the beginning (public member function). pop_front : Removes the first element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function). merge : Merges two sorted lists (public member function). splice : Moves elements from another list (public member function). remove , remove_if : Removes elements satisfying specific criteria (public member function). reverse : Reverses the order of the elements (public member function). unique : Removes consecutive duplicate elements (public member function). sort : Sorts the elements (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two lists (function template). std::swap( std::list ) : Specializes the std::swap algorithm (function template). erase( std::list ) (C++20), erase_if( std::list ) (C++20): Erases all elements satisfying specific criteria (function template). Forward Lists (Singly-linked Lists) Explanation Forward lists are sequence containers that allow constant-time insertion and deletion operations at any point within the sequence. Forward lists are implemented as singly linked lists . These lists can store their elements in different, unrelated storage locations, with order maintained through a link from each element to the next in the sequence. They can be implemented using a single pointer within a class or structure , enabling them to grow dynamically in size . Unlike vectors, forward lists do not support random access , meaning elements cannot be accessed directly at specific indices or retrieved by index numbers. Their header file is <forward_list> . Declaration Syntax std::forward_list< Type > list_name; std::forward_list< Type >* list_ptr; Initialization Syntax // Initializer list constructor. std::forward_list< Type > list_name = { ... }; // Initializer list constructor. std::forward_list< Type > list_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::forward_list< Type > list_name; // No initialization, contain garbage values and behave unpredictably. std::forward_list< Type > list_name( size ); // Initialization with the specific value. std::forward_list< Type > list_name( size, value ); // Initializer list constructor. std::forward_list< Type > list_name1 = { ... }; // Copy constructor. std::forward_list< Type > list_name2( list_name1 ); // Initializer list constructor. std::forward_list< Type > list_name1 = { ... }; // Copy constructor. std::forward_list< Type > list_name2 = list_name1; // Initializer list constructor. std::forward_list< Type > list_name1( { ... } ); // Move constructor. std::forward_list< Type > list_name2 = std::move( list_name1 ); // Constructs the container with the contents of the range `[first, last)`. std::forward_list< Type > list_name1( { ... } ); std::forward_list< Type > list_name2( list_name1.begin(), list_name1.end() ); std::forward_list< Type >* list_ptr = new std::forward_list< Type >( size ); std::forward_list< Type >* list_ptr = new std::forward_list< Type >( size, value ); // Initializer list constructor. std::forward_list< Type > list_name = { ... }; std::forward_list< Type >* list_ptr = new std::forward_list< Type >( list_name ); std::forward_list< Type >* list_ptr = new std::forward_list< Type >{ ... }; Syntax for Deleting std::forward_list Pointers delete list_ptr; Members and Related Stuffs Links std::forward_list in cplusplus . std::forward_list in cppreference . Template Parameters T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . Member Functions (constructor): Constructs the forward_list (public member function). (destructor): Destructs the forward_list (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). front : Access the first element (public member function). before_begin , cbefore_begin : Returns an iterator to the element before beginning (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert_after : Inserts elements after an element (public member function). emplace_after : Constructs elements in-place after an element (public member function). insert_range_after (C++23): Inserts a range of elements after an element (public member function). erase_after : Erases elements after an element (public member function). push_front : Inserts an element to the beginning (public member function). emplace_front : Constructs an element in-place at the beginning (public member function). prepend_range (C++23): Adds a range of elements to the beginning (public member function). pop_front : Removes the first element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function). merge : Merges two sorted lists (public member function). splice_after : Moves elements from another forward_list (public member function). remove , remove_if : Removes elements satisfying specific criteria (public member function). reverse : Reverses the order of the elements (public member function). unique : Removes consecutive duplicate elements (public member function). sort : Sorts the elements (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two forward_lists (function template). std::swap( std::forward_list ) : Specializes the std::swap algorithm (function template). erase( std::forward_list ) (C++20), erase_if( std::list ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Lists and Forward Lists"},{"location":"ListsAndForwardLists/#lists-doubly-linked-lists","text":"","title":"Lists (Doubly-linked Lists)"},{"location":"ListsAndForwardLists/#explanation","text":"Lists are sequence containers that allow constant-time insertion and deletion operations anywhere within the sequence, as well as iteration in both directions . List containers are implemented as doubly linked lists . These lists can store their elements in different and unrelated storage locations. They can be implemented using two pointers in a class or structure , allowing them to dynamically grow in size . Adding and removing elements at the beginning or end of a list costs only constant time , while vectors are generally optimized for additions and removals at the end . Unlike vectors, lists do not support random access , meaning they cannot be directly accessed at a specific index or have elements retrieved by their index numbers. Their header file is <list> .","title":"Explanation"},{"location":"ListsAndForwardLists/#declaration-syntax","text":"std::list< Type > list_name; std::list< Type >* list_ptr;","title":"Declaration Syntax"},{"location":"ListsAndForwardLists/#initialization-syntax","text":"// Initializer list constructor. std::list< Type > list_name = { ... }; // Initializer list constructor. std::list< Type > list_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::list< Type > list_name; // No initialization, contain garbage values and behave unpredictably. std::list< Type > list_name( size ); // Initialization with the specific value. std::list< Type > list_name( size, value ); // Initializer list constructor. std::list< Type > list_name1 = { ... }; // Copy constructor. std::list< Type > list_name2( list_name1 ); // Initializer list constructor. std::list< Type > list_name1 = { ... }; // Copy constructor. std::list< Type > list_name2 = list_name1; // Initializer list constructor. std::list< Type > list_name1( { ... } ); // Move constructor. std::list< Type > list_name2 = std::move( list_name1 ); // Constructs the container with the contents of the range `[first, last)`. std::list< Type > list_name1( { ... } ); std::list< Type > list_name2( list_name1.begin(), list_name1.end() ); std::list< Type >* list_ptr = new std::list< Type >( size ); std::list< Type >* list_ptr = new std::list< Type >( size, value ); // Initializer list constructor. std::list< Type > list_name = { ... }; std::list< Type >* list_ptr = new std::list< Type >( list_name ); std::list< Type >* list_ptr = new std::list< Type >{ ... };","title":"Initialization Syntax"},{"location":"ListsAndForwardLists/#syntax-for-deleting-stdlist-pointers","text":"delete list_ptr;","title":"Syntax for Deleting std::list Pointers"},{"location":"ListsAndForwardLists/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"ListsAndForwardLists/#links","text":"std::list in cplusplus . std::list in cppreference .","title":"Links"},{"location":"ListsAndForwardLists/#template-parameters","text":"T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"ListsAndForwardLists/#member-types","text":"value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"ListsAndForwardLists/#member-functions","text":"(constructor): Constructs the list (public member function). (destructor): Destructs the list (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). front : Access the first element (public member function). back : Access the last element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). erase : Erases elements and returns a valid iterator (public member function). push_back : Adds an element to the end (public member function). emplace_back : Constructs an element in-place at the end (public member function). append_range (C++23): Adds a range of elements to the end (public member function). pop_back : Removes the last element (public member function). push_front : Inserts an element to the beginning (public member function). emplace_front : Constructs an element in-place at the beginning (public member function). prepend_range (C++23): Adds a range of elements to the beginning (public member function). pop_front : Removes the first element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function). merge : Merges two sorted lists (public member function). splice : Moves elements from another list (public member function). remove , remove_if : Removes elements satisfying specific criteria (public member function). reverse : Reverses the order of the elements (public member function). unique : Removes consecutive duplicate elements (public member function). sort : Sorts the elements (public member function).","title":"Member Functions"},{"location":"ListsAndForwardLists/#non-member-functions","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two lists (function template). std::swap( std::list ) : Specializes the std::swap algorithm (function template). erase( std::list ) (C++20), erase_if( std::list ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"ListsAndForwardLists/#forward-lists-singly-linked-lists","text":"","title":"Forward Lists (Singly-linked Lists)"},{"location":"ListsAndForwardLists/#explanation_1","text":"Forward lists are sequence containers that allow constant-time insertion and deletion operations at any point within the sequence. Forward lists are implemented as singly linked lists . These lists can store their elements in different, unrelated storage locations, with order maintained through a link from each element to the next in the sequence. They can be implemented using a single pointer within a class or structure , enabling them to grow dynamically in size . Unlike vectors, forward lists do not support random access , meaning elements cannot be accessed directly at specific indices or retrieved by index numbers. Their header file is <forward_list> .","title":"Explanation"},{"location":"ListsAndForwardLists/#declaration-syntax_1","text":"std::forward_list< Type > list_name; std::forward_list< Type >* list_ptr;","title":"Declaration Syntax"},{"location":"ListsAndForwardLists/#initialization-syntax_1","text":"// Initializer list constructor. std::forward_list< Type > list_name = { ... }; // Initializer list constructor. std::forward_list< Type > list_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::forward_list< Type > list_name; // No initialization, contain garbage values and behave unpredictably. std::forward_list< Type > list_name( size ); // Initialization with the specific value. std::forward_list< Type > list_name( size, value ); // Initializer list constructor. std::forward_list< Type > list_name1 = { ... }; // Copy constructor. std::forward_list< Type > list_name2( list_name1 ); // Initializer list constructor. std::forward_list< Type > list_name1 = { ... }; // Copy constructor. std::forward_list< Type > list_name2 = list_name1; // Initializer list constructor. std::forward_list< Type > list_name1( { ... } ); // Move constructor. std::forward_list< Type > list_name2 = std::move( list_name1 ); // Constructs the container with the contents of the range `[first, last)`. std::forward_list< Type > list_name1( { ... } ); std::forward_list< Type > list_name2( list_name1.begin(), list_name1.end() ); std::forward_list< Type >* list_ptr = new std::forward_list< Type >( size ); std::forward_list< Type >* list_ptr = new std::forward_list< Type >( size, value ); // Initializer list constructor. std::forward_list< Type > list_name = { ... }; std::forward_list< Type >* list_ptr = new std::forward_list< Type >( list_name ); std::forward_list< Type >* list_ptr = new std::forward_list< Type >{ ... };","title":"Initialization Syntax"},{"location":"ListsAndForwardLists/#syntax-for-deleting-stdforward_list-pointers","text":"delete list_ptr;","title":"Syntax for Deleting std::forward_list Pointers"},{"location":"ListsAndForwardLists/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"ListsAndForwardLists/#links_1","text":"std::forward_list in cplusplus . std::forward_list in cppreference .","title":"Links"},{"location":"ListsAndForwardLists/#template-parameters_1","text":"T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"ListsAndForwardLists/#member-types_1","text":"value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type .","title":"Member Types"},{"location":"ListsAndForwardLists/#member-functions_1","text":"(constructor): Constructs the forward_list (public member function). (destructor): Destructs the forward_list (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). front : Access the first element (public member function). before_begin , cbefore_begin : Returns an iterator to the element before beginning (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert_after : Inserts elements after an element (public member function). emplace_after : Constructs elements in-place after an element (public member function). insert_range_after (C++23): Inserts a range of elements after an element (public member function). erase_after : Erases elements after an element (public member function). push_front : Inserts an element to the beginning (public member function). emplace_front : Constructs an element in-place at the beginning (public member function). prepend_range (C++23): Adds a range of elements to the beginning (public member function). pop_front : Removes the first element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function). merge : Merges two sorted lists (public member function). splice_after : Moves elements from another forward_list (public member function). remove , remove_if : Removes elements satisfying specific criteria (public member function). reverse : Reverses the order of the elements (public member function). unique : Removes consecutive duplicate elements (public member function). sort : Sorts the elements (public member function).","title":"Member Functions"},{"location":"ListsAndForwardLists/#non-member-functions_1","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two forward_lists (function template). std::swap( std::forward_list ) : Specializes the std::swap algorithm (function template). erase( std::forward_list ) (C++20), erase_if( std::list ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MacrosAndPragma/","text":"Macro and Related Keywords (Including pragma ) Explanation Syntax Related Keywords #ifdef , #ifndef , #else , #endif Explanation Syntax #undef Explanation Syntax #include Explanation Syntax #pragma Explanation Syntax const and constexpr inline Macro and Related Keywords (Including pragma ) Explanation Macros are typically defined using the preprocessor directive #define , which allows for text substitution prior to the actual compilation of the code. They are classified as preprocessor statements . Macros may represent simple constants or complex expressions . When the preprocessor encounters a macro, it replaces it with the corresponding value or code. They enable the compilation of identical code to produce varied outcomes based on distinct configurations . The backslash ( \\ ) can be utilized to create multi-line macros . Excessive use of macros may adversely affect the readability of the code. Function-like macros can be difficult to debug . Syntax #define MACRO_NAME replacement_text // Function-like Macros #define funcName( para_list ) replacement_text // Multi-line Macros #define MACRO_NAME replacement_text1 \\ replacement_text2 \\ ...; Related Keywords #ifdef , #ifndef , #else , #endif Explanation These directives are used for conditional compilation , allowing code to be included or excluded based on whether a macro is defined or not. Syntax #ifdef MACRO_NAME // Code Block #else // Code Block #endif #ifdef MACRO_NAME // Code Block #else #define MACRO_NAME replacement_text #endif #ifndef MACRO_NAME // Code Block #else // Code Block #endif #ifndef MACRO_NAME #define MACRO_NAME replacement_text #else // Code Block #endif #undef Explanation This directive is used to undefine a macro , making it unavailable after that point in the code. Syntax #define MACRO_NAME replacement_text #undef MACRO_NAME #include Explanation This directive is not a macro but is often used with macros to include header files where macros may be defined. #include <HeaderFile> : This syntax instructs the preprocessor to search for the specified header file exclusively in the standard include directories . It is typically used for system or library headers . #include \"path/to/HeaderFile\" : This syntax tells the preprocessor to look for the specified header file in the specific path first . If it is not found there, it then searches the standard include directories . Syntax #include <HeaderFile> #include \"path/to/HeaderFile\" #pragma Explanation This directive provides additional information to the compiler, often used for controlling compiler-specific behaviors but can also be relevant in the context of macros. Syntax #pragma once // Ensures the file is included only once const and constexpr These keywords are alternatives to macros for defining constant values with type safety . const . constexpr . inline This keyword can be used to define functions that behave like macros but with type checking and scope . inline .","title":"Macros and Related Keywords ( Including pragma"},{"location":"MacrosAndPragma/#macro-and-related-keywords-including-pragma","text":"","title":"Macro and Related Keywords (Including pragma)"},{"location":"MacrosAndPragma/#explanation","text":"Macros are typically defined using the preprocessor directive #define , which allows for text substitution prior to the actual compilation of the code. They are classified as preprocessor statements . Macros may represent simple constants or complex expressions . When the preprocessor encounters a macro, it replaces it with the corresponding value or code. They enable the compilation of identical code to produce varied outcomes based on distinct configurations . The backslash ( \\ ) can be utilized to create multi-line macros . Excessive use of macros may adversely affect the readability of the code. Function-like macros can be difficult to debug .","title":"Explanation"},{"location":"MacrosAndPragma/#syntax","text":"#define MACRO_NAME replacement_text // Function-like Macros #define funcName( para_list ) replacement_text // Multi-line Macros #define MACRO_NAME replacement_text1 \\ replacement_text2 \\ ...;","title":"Syntax"},{"location":"MacrosAndPragma/#related-keywords","text":"","title":"Related Keywords"},{"location":"MacrosAndPragma/#ifdef-ifndef-else-endif","text":"","title":"#ifdef, #ifndef, #else, #endif"},{"location":"MacrosAndPragma/#explanation_1","text":"These directives are used for conditional compilation , allowing code to be included or excluded based on whether a macro is defined or not.","title":"Explanation"},{"location":"MacrosAndPragma/#syntax_1","text":"#ifdef MACRO_NAME // Code Block #else // Code Block #endif #ifdef MACRO_NAME // Code Block #else #define MACRO_NAME replacement_text #endif #ifndef MACRO_NAME // Code Block #else // Code Block #endif #ifndef MACRO_NAME #define MACRO_NAME replacement_text #else // Code Block #endif","title":"Syntax"},{"location":"MacrosAndPragma/#undef","text":"","title":"#undef"},{"location":"MacrosAndPragma/#explanation_2","text":"This directive is used to undefine a macro , making it unavailable after that point in the code.","title":"Explanation"},{"location":"MacrosAndPragma/#syntax_2","text":"#define MACRO_NAME replacement_text #undef MACRO_NAME","title":"Syntax"},{"location":"MacrosAndPragma/#include","text":"","title":"#include"},{"location":"MacrosAndPragma/#explanation_3","text":"This directive is not a macro but is often used with macros to include header files where macros may be defined. #include <HeaderFile> : This syntax instructs the preprocessor to search for the specified header file exclusively in the standard include directories . It is typically used for system or library headers . #include \"path/to/HeaderFile\" : This syntax tells the preprocessor to look for the specified header file in the specific path first . If it is not found there, it then searches the standard include directories .","title":"Explanation"},{"location":"MacrosAndPragma/#syntax_3","text":"#include <HeaderFile> #include \"path/to/HeaderFile\"","title":"Syntax"},{"location":"MacrosAndPragma/#pragma","text":"","title":"#pragma"},{"location":"MacrosAndPragma/#explanation_4","text":"This directive provides additional information to the compiler, often used for controlling compiler-specific behaviors but can also be relevant in the context of macros.","title":"Explanation"},{"location":"MacrosAndPragma/#syntax_4","text":"#pragma once // Ensures the file is included only once","title":"Syntax"},{"location":"MacrosAndPragma/#const-and-constexpr","text":"These keywords are alternatives to macros for defining constant values with type safety . const . constexpr .","title":"const and constexpr"},{"location":"MacrosAndPragma/#inline","text":"This keyword can be used to define functions that behave like macros but with type checking and scope . inline .","title":"inline"},{"location":"MapsUnorderedMapsAndFlatMaps/","text":"Maps Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::map Pointers Members and Related Stuffs Links Template Parameters Member Types Member Classes Member Functions Non-member Functions Multimaps Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::multimap Pointers Members and Related Stuffs Links Template Parameters Member Types Member Classes Member Functions Non-member Functions Unordered Maps Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::unordered_map Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Unordered Multimaps Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::unordered_multimap Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Flat Maps Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::flat_map Pointers Members and Related Stuffs Links Template Parameters Member Types Member Classes Member Objects Member Functions Non-member Functions Helper classes Tags Flat Multimaps Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::flat_multimap Pointers Members and Related Stuffs Links Template Parameters Member Types Member Classes Member Objects Member Functions Non-member Functions Helper classes Tags Maps Explanation Maps are associative containers that store elements formed by a combination of a key value and a mapped value , following a specific order . In a map, the key values are generally used to sort and uniquely identify the elements , while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type , which is a pair type combining both: typedef pair<const Key, T> value_type; . Different mapped values must have different key values . Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare). Map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ( (operator[] ) . Maps are typically implemented as red\u2013black trees . Their header file is <map> . Declaration Syntax std::map< KType, VType > map_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::map< KType, VType, Compare > map_name; std::map< KType, VType >* map_ptr; Initialization Syntax // Initializer list constructor. std::map< KType, VType > map_name = { ... }; // Initializer list constructor. std::map< KType, VType > map_name{ ... }; // Default constructor. Constructs an empty container. std::map< KType, VType > map_name; // Default constructor. Constructs an empty container. std::map< KType, VType, Compare > map_name; // Default constructor. Constructs an empty container. std::map< KType, VType, Compare > map_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::map< KType, VType, Compare > rmap_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::map< KType, VType, Compare > map_name( comp ); // Default constructor. Constructs an empty container. std::map< KType, VType > map_name1; // Copy constructor. std::map< KType, VType > map_name2( map_name1 ); // Default constructor. Constructs an empty container. std::map< KType, VType > map_name1; // Copy constructor. std::map< KType, VType > map_name2 = map_name1; // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::map< KType, VType, Compare > map_name1( comp ); std::map< KType, VType, Compare > map_name2( map_name1.begin(), map_name1.end(), comp /* optional */ ); // Default constructor. Constructs an empty container. std::map< KType, VType > map_name1; // Move constructor. std::map< KType, VType > map_name2( std::move( map_name1 ) ); std::map< KType, VType >* map_ptr = new std::map< KType, VType >; // Default constructor. Constructs an empty container. std::map< KType, VType > map_name; std::map< KType, VType >* map_ptr = new std::map< KType, VType >( map_name ); Syntax for Deleting std::map Pointers delete map_ptr; Members and Related Stuffs Links std::map in cplusplus . std::map in cppreference . Template Parameters Key : Type of the keys. T : Type of the mapped value. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the map because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17) : Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type . Member Classes value_compare : Compares objects of type value_type (class). Member Functions (constructor): Constructs the map (public member function). (destructor): Destructs the map (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key already exists (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key exists (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two maps (function template). std::swap( std::map ) : Specializes the std::swap algorithm (function template). erase_if( std::map ) (C++20): Erases all elements satisfying specific criteria (function template). Multimaps Explanation Multimaps are associative containers that store elements formed by a combination of a key value and a mapped value , following a specific order , and where multiple elements can have equivalent keys . In a multimap, the key values are generally used to sort and uniquely identify the elements , while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type , which is a pair type combining both: typedef pair<const Key, T> value_type; . Internally, the elements in a multimap are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare). Multimap containers are generally slower than unordered_multimap containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. Multimaps are typically implemented as red\u2013black trees . Their header file is <map> . Declaration Syntax std::multimap< KType, VType > mmap_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::multimap< KType, VType, Compare > mmap_name; std::multimap< KType, VType >* mmap_ptr; Initialization Syntax // Initializer list constructor. std::multimap< KType, VType > mmap_name = { ... }; // Initializer list constructor. std::multimap< KType, VType > mmap_name{ ... }; // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name; // Default constructor. Constructs an empty container. std::multimap< KType, VType, Compare > mmap_name; // Default constructor. Constructs an empty container. std::multimap< KType, VType, Compare > mmap_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::multimap< KType, VType, Compare > rmmap_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::multimap< KType, VType, Compare > mmap_name( comp ); // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name1; // Copy constructor. std::multimap< KType, VType > mmap_name2( mmap_name1 ); // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name1; // Copy constructor. std::multimap< KType, VType > mmap_name2 = mmap_name1; // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name1; // Move constructor. std::multimap< KType, VType > mmap_name2( std::move( mmap_name1 ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::multimap< KType, VType, Compare > mmap_name1( comp ); std::multimap< KType, VType, Compare > mmap_name2( mmap_name1.begin(), mmap_name1.end(), comp /* optional */ ); std::multimap< KType, VType >* mmap_ptr = new std::multimap< KType, VType >; // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name; std::multimap< KType, VType >* mmap_ptr = new std::multimap< KType, VType >( mmap_name ); Syntax for Deleting std::multimap Pointers delete mmap_ptr; Members and Related Stuffs Links std::multimap in cplusplus . std::multimap in cppreference . Template Parameters Key : Type of the keys. T : Type of the mapped value. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the multimap because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node. Member Classes value_compare : Compares objects of type value_type (class). Member Functions (constructor): Constructs the multimap (public member function). (destructor): Destructs the multimap (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two multimaps (function template). std::swap( std::multimap ) : Specializes the std::swap algorithm (function template). erase_if( std::multimap ) (C++20): Erases all elements satisfying specific criteria (function template). Unordered Maps Explanation Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value , and which allows for fast retrieval of individual elements based on their keys. In an unordered_map , the key value is generally used to uniquely identify the element , while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ. Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values ( with a constant average time complexity on average ). unordered_map containers are faster than map containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements. Unordered maps implement the direct access operator ( operator[] ) which allows for direct access of the mapped value using its key value as argument. Iterators in the container are at least forward iterators . Their header file is <unordered_map> . Declaration Syntax std::unordered_map< KType, VType > umap_name; // Not common, not recommend struct Hash { std::size_t operator()( const KType& obj ) const { // This is only an example. return std::hash< SubKType1 >()( obj._mem1 ) ^ std::hash< SubKType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const KType& lhs, const KType& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name; std::unordered_map< KType, VType >* umap_ptr; Initialization Syntax // Initializer list constructor. std::unordered_map< KType, VType > umap_name = { ... }; // Initializer list constructor. std::unordered_map< KType, VType > umap_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType, Hash, KeyEqual > umap_name; // Constructs an empty container. Hash hash; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( hash, key_equal ); // Constructs an empty container. std::unordered_map< KType, VType > umap_name( size ); // Constructs an empty container. std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( size ); // Constructs an empty container. Hash hash; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name1; // Copy constructor. std::unordered_map< KType, VType > umap_name2( umap_name1 ); // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name1; // Copy constructor. std::unordered_map< KType, VType > umap_name2 = umap_name1; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name1; // Move constructor. std::unordered_map< KType, VType > umap_name2( std::move( umap_name1 ) ); // Initializer list constructor. std::unordered_map< KType, VType, Hash, KeyEqual > umap_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name2( umap_name1.begin(), umap_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_map< KType, VType >* umap_ptr = new std::unordered_map< KType, VType >; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name; std::unordered_map< KType, VType >* umap_ptr = new std::unordered_map< KType, VType >( umap_name ); Syntax for Deleting std::unordered_map Pointers delete umap_ptr; Members and Related Stuffs Links std::unordered_map in cplusplus . std::unordered_map in cppreference . Template Parameters Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17): Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type . Member Functions (constructor): Constructs the unordered map (public member function). (destructor): Destructs the unordered map (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function). Non-member Functions operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered maps (function template). std::swap( std::unordered_map ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_map ) (C++20): Erases all elements satisfying specific criteria (function template). Unordered Multimaps Explanation Unordered multimaps are associative containers that store elements formed by the combination of a key value and a mapped value , much like unordered_map containers, but allowing different elements to have equivalent keys . In an unordered_multimap , the key value is generally used to uniquely identify the element , while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ. Internally, the elements in the unordered_multimap are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values ( with a constant average time complexity on average ). Elements with equivalent keys are grouped together in the same bucket and in such a way that an iterator (see equal_range ) can iterate through all of them. Iterators in the container are at least forward iterators . Their header file is <unordered_map> . Declaration Syntax std::unordered_multimap< KType, VType > ummap_name; // Not common, not recommend struct Hash { std::size_t operator()( const KType& obj ) const { // This is only an example. return std::hash< SubKType1 >()( obj._mem1 ) ^ std::hash< SubKType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const KType& lhs, const KType& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name; std::unordered_multimap< KType, VType >* ummap_ptr; Initialization Syntax // Initializer list constructor. std::unordered_multimap< KType, VType > ummap_name = { ... }; // Initializer list constructor. std::unordered_multimap< KType, VType > ummap_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name; // Constructs an empty container. Hash hash; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( hash, key_equal ); // Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name( size ); // Constructs an empty container. std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( size ); // Constructs an empty container. Hash hash; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name1; // Copy constructor. std::unordered_multimap< KType, VType > ummap_name2( ummap_name1 ); // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name1; // Copy constructor. std::unordered_multimap< KType, VType > ummap_name2 = ummap_name1; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name1; // Move constructor. std::unordered_multimap< KType, VType > ummap_name2( std::move( ummap_name1 ) ); // Initializer list constructor. std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name2( ummap_name1.begin(), ummap_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_multimap< KType, VType >* ummap_ptr = new std::unordered_multimap< KType, VType >; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name; std::unordered_multimap< KType, VType >* ummap_ptr = new std::unordered_multimap< KType, VType >( ummap_name ); Syntax for Deleting std::unordered_multimap Pointers delete ummap_ptr; Members and Related Stuffs Links std::unordered_multimap in cplusplus . std::unordered_multimap in cppreference . Template Parameters Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17): Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type . Member Functions (constructor): Constructs the unordered multimap (public member function). (destructor): Destructs the unordered multimap (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function). Non-member Functions operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered multimaps (function template). std::swap( std::unordered_multimap ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_multimap ) (C++20): Erases all elements satisfying specific criteria (function template). Flat Maps Explanation Flat maps are an associative container that stores elements formed by a combination of a key value and a mapped value , but is implemented as a sorted sequence , typically using a vector. In a flat_map , the key values are generally used to sort and uniquely identify the elements , while the mapped values store the content associated with this key, similar to traditional maps. The types of key and mapped value may differ and are grouped together in the member type value_type , which is a pair type combining both: typedef std::pair<const Key, T> value_type; . Different mapped values must have different key values , ensuring that each key in a flat_map uniquely identifies a single mapped value. Internally, the elements in a flat_map are stored as a sorted vector , which allows for binary search for efficient lookups and iteration based on the key\u2019s order. flat_map containers can be faster than traditional maps for access to individual elements by their key due to contiguous memory storage , but they may incur overhead for insertions and deletions due to the need to maintain sorted order. The mapped values in a flat_map can be accessed directly by their corresponding key using the bracket operator ( operator[] ) , similar to regular maps. The class template flat_map acts as a wrapper to the two underlying containers , passed as objects of type KeyContainer and MappedContainer respectively. The first container is sorted, and for each key its corresponding value is in the second container at the same index ( offset ). The number of elements in both containers is the same. The header file for flat_map is <experimental/flat_map> (or may be found in other namespaces in different implementations). Declaration Syntax std::flat_map< KType, VType > fmap_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_map< KType, VType, Compare > fmap_name; // Not common, not recommend std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name; std::flat_map< KType, VType >* fmap_ptr; Initialization Syntax // Initializer list constructor std::flat_map< KType, VType > fmap_name = { ... }; // Initializer list constructor std::flat_map< KType, VType > fmap_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_map< KType, VType > fmap_name; // Default constructor. Constructs an empty container adaptor. std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name; // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( kcont, vcont ); // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( kcont, vcont, comp ); // Specify that all elements are unique. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. std::sorted_unique_t s; KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( s, kcont, vcont ); // Specify that all elements are unique. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( s, kcont, vcont, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name1; // Copy constructor. std::flat_map< KType, VType > fmap_name2( fmap_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name1; // Copy constructor. std::flat_map< KType, VType > fmap_name2 = fmap_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name1; // Move constructor. std::flat_map< KType, VType > fmap_name2( std::move( fmap_name1 ) ); // Specify that all elements are unique. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name1( s, kcont, vcont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name2( s /* optional */, fmap_name1.begin(), fmap_name1.end(), comp /* optional */ ); std::flat_map< KType, VType >* fmap_ptr = new std::flat_map< KType, VType >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name; std::flat_map< KType, VType >* fmap_ptr = new std::flat_map< KType, VType >( fmap_name ); Syntax for Deleting std::flat_map Pointers delete fmap_ptr; Members and Related Stuffs Links std::flat_map in cplusplus . std::flat_map in cppreference . Template Parameters Key : The type of the keys. T : The type of mapped values. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat set because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer , MappedContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements. Member Types key_containre_type : KeyContainer . mapped_containre_type : MappedContainer . key_type : Key . mapped_type : T . value_type : std::pair< key_type, mapped_type > . key_compare : Compare . reference : std::pair< const key_type&, mapped_type& > . const_reference : std::pair< const key_type&, const mapped_type& > . size_type : std::size_t . difference_type : std::ptrdiff_t . iterator : Implementation-defined LegacyInputIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyInputIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . containers : Type describing the underlying containers. CPP struct containers { key_container_type keys; mapped_container_type values; }; Member Classes value_compare : Compares objects of type value_type (class). Member Objects c ( private ): The object of type containers (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ). Member Functions (constructor): Constructs the flat map (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key extract : Extracts the underlying containers (public member function). replace : Replaces the underlying containers (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). keys : Direct access to the underlying keys container (public member function). values : Direct access to the underlying values container (public member function). Non-member Functions operator== , operator<=> : Lexicographically compares the values of two flat maps (function template). std::swap( std::flat_map ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_map ) : Erases all elements satisfying specific criteria (function template). Helper classes std::uses_allocator< std::flat_map > (C++23): Specializes the std::uses_allocat or type trait (class template specialization). Tags sorted_unique , sorted_unique_t (C++23): indicates that elements of a range are sorted and unique (tag). Flat Multimaps Explanation Flat multimaps are an associative container that stores elements formed by a combination of a key value and a mapped value , implemented as a sorted sequence , typically using a vector. In a flat_multimap , the key values can be associated with multiple mapped values , allowing for duplicate keys, which distinguishes it from flat_map . The types of key and mapped value may differ and are grouped together in the member type value_type , which is a pair type combining both: typedef std::pair<const Key, T> value_type; . Multiple mapped values can share the same key value , enabling the storage of collections of values for each unique key, reflecting the nature of multimaps. Internally, the elements in a flat_multimap are stored as a sorted vector , which allows for binary search for efficient lookups and iteration based on the key\u2019s order. flat_multimap containers can be faster than traditional multimaps for access to individual elements by their key due to contiguous memory storage , but they may incur overhead for insertions and deletions due to the need to maintain sorted order. The mapped values in a flat_multimap can be accessed using iterators or the equal_range method to retrieve all values corresponding to a particular key . flat_multimap is typically implemented using a sorted vector , allowing for fast lookups while maintaining a compact memory footprint. The header file for flat_multimap is <experimental/flat_map> (or may be found in other namespaces in different implementations). Declaration Syntax std::flat_multimap< KType, VType > fmmap_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_multimap< KType, VType, Compare > fmmap_name; // Not common, not recommend std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name; std::flat_multimap< KType, VType >* fmmap_ptr; Initialization Syntax // Initializer list constructor std::flat_multimap< KType, VType > fmmap_name = { ... }; // Initializer list constructor std::flat_multimap< KType, VType > fmmap_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_multimap< KType, VType > fmmap_name; // Default constructor. Constructs an empty container adaptor. std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name; // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( kcont, vcont ); // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( kcont, vcont, comp ); // Allow different elements with the same value. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( s, kcont, vcont ); // Allow different elements with the same value. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s: KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( s, kcont, vcont, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name1; // Copy constructor. std::flat_multimap< KType, VType > fmmap_name2( fmmap_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name1; // Copy constructor. std::flat_multimap< KType, VType > fmmap_name2 = fmmap_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name1; // Move constructor. std::flat_multimap< KType, VType > fmmap_name2( std::move( fmmap_name1 ) ); // Allow different elements with the same value. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name1( s, kcont, vcont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name2( s /* optional */, fmmap_name1.begin(), fmmap_name1.end(), comp /* optional */ ); std::flat_multimap< KType, VType >* fmmap_ptr = new std::flat_multimap< KType, VType >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name; std::flat_multimap< KType, VType >* fmmap_ptr = new std::flat_multimap< KType, VType >( fmmap_name ); Syntax for Deleting std::flat_multimap Pointers delete fmmap_ptr; Members and Related Stuffs Links std::flat_multimap in cplusplus . std::flat_multimap in cppreference . Template Parameters Key : The type of the keys. T : The type of mapped values. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat set because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer , MappedContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements. Member Types key_containre_type : KeyContainer . mapped_containre_type : MappedContainer . key_type : Key . mapped_type : T . value_type : std::pair< key_type, mapped_type > . key_compare : Compare . reference : std::pair< const key_type&, mapped_type& > . const_reference : std::pair< const key_type&, const mapped_type& > . size_type : std::size_t . difference_type : std::ptrdiff_t . iterator : Implementation-defined LegacyInputIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyInputIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . containers : Type describing the underlying containers. CPP struct containers { key_container_type keys; mapped_container_type values; }; Member Classes value_compare : Compares objects of type value_type (class). Member Objects c ( private ): The object of type containers (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ). Member Functions (constructor): Constructs the flat multimap (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). extract : Extracts the underlying containers (public member function). replace : Replaces the underlying containers (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). keys : Direct access to the underlying keys container (public member function). values : Direct access to the underlying values container (public member function). Non-member Functions operator== , operator<=> : Lexicographically compares the values of two flat multimaps (function template). std::swap( std::flat_multimap ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_multimap ) : Erases all elements satisfying specific criteria (function template). Helper classes std::uses_allocator< std::flat_multimap > (C++23): Specializes the std::uses_allocat or type trait (class template specialization). Tags sorted_equivalent , sorted_equivalent_t (C++23): indicates that elements of a range are sorted and unique (tag).","title":"Maps Unordered Maps and Flat Maps"},{"location":"MapsUnorderedMapsAndFlatMaps/#maps","text":"","title":"Maps"},{"location":"MapsUnorderedMapsAndFlatMaps/#explanation","text":"Maps are associative containers that store elements formed by a combination of a key value and a mapped value , following a specific order . In a map, the key values are generally used to sort and uniquely identify the elements , while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type , which is a pair type combining both: typedef pair<const Key, T> value_type; . Different mapped values must have different key values . Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare). Map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ( (operator[] ) . Maps are typically implemented as red\u2013black trees . Their header file is <map> .","title":"Explanation"},{"location":"MapsUnorderedMapsAndFlatMaps/#declaration-syntax","text":"std::map< KType, VType > map_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::map< KType, VType, Compare > map_name; std::map< KType, VType >* map_ptr;","title":"Declaration Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#initialization-syntax","text":"// Initializer list constructor. std::map< KType, VType > map_name = { ... }; // Initializer list constructor. std::map< KType, VType > map_name{ ... }; // Default constructor. Constructs an empty container. std::map< KType, VType > map_name; // Default constructor. Constructs an empty container. std::map< KType, VType, Compare > map_name; // Default constructor. Constructs an empty container. std::map< KType, VType, Compare > map_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::map< KType, VType, Compare > rmap_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::map< KType, VType, Compare > map_name( comp ); // Default constructor. Constructs an empty container. std::map< KType, VType > map_name1; // Copy constructor. std::map< KType, VType > map_name2( map_name1 ); // Default constructor. Constructs an empty container. std::map< KType, VType > map_name1; // Copy constructor. std::map< KType, VType > map_name2 = map_name1; // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::map< KType, VType, Compare > map_name1( comp ); std::map< KType, VType, Compare > map_name2( map_name1.begin(), map_name1.end(), comp /* optional */ ); // Default constructor. Constructs an empty container. std::map< KType, VType > map_name1; // Move constructor. std::map< KType, VType > map_name2( std::move( map_name1 ) ); std::map< KType, VType >* map_ptr = new std::map< KType, VType >; // Default constructor. Constructs an empty container. std::map< KType, VType > map_name; std::map< KType, VType >* map_ptr = new std::map< KType, VType >( map_name );","title":"Initialization Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#syntax-for-deleting-stdmap-pointers","text":"delete map_ptr;","title":"Syntax for Deleting std::map Pointers"},{"location":"MapsUnorderedMapsAndFlatMaps/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"MapsUnorderedMapsAndFlatMaps/#links","text":"std::map in cplusplus . std::map in cppreference .","title":"Links"},{"location":"MapsUnorderedMapsAndFlatMaps/#template-parameters","text":"Key : Type of the keys. T : Type of the mapped value. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the map because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-types","text":"key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17) : Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type .","title":"Member Types"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-classes","text":"value_compare : Compares objects of type value_type (class).","title":"Member Classes"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-functions","text":"(constructor): Constructs the map (public member function). (destructor): Destructs the map (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key already exists (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key exists (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function).","title":"Member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#non-member-functions","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two maps (function template). std::swap( std::map ) : Specializes the std::swap algorithm (function template). erase_if( std::map ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#multimaps","text":"","title":"Multimaps"},{"location":"MapsUnorderedMapsAndFlatMaps/#explanation_1","text":"Multimaps are associative containers that store elements formed by a combination of a key value and a mapped value , following a specific order , and where multiple elements can have equivalent keys . In a multimap, the key values are generally used to sort and uniquely identify the elements , while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type , which is a pair type combining both: typedef pair<const Key, T> value_type; . Internally, the elements in a multimap are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare). Multimap containers are generally slower than unordered_multimap containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. Multimaps are typically implemented as red\u2013black trees . Their header file is <map> .","title":"Explanation"},{"location":"MapsUnorderedMapsAndFlatMaps/#declaration-syntax_1","text":"std::multimap< KType, VType > mmap_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::multimap< KType, VType, Compare > mmap_name; std::multimap< KType, VType >* mmap_ptr;","title":"Declaration Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#initialization-syntax_1","text":"// Initializer list constructor. std::multimap< KType, VType > mmap_name = { ... }; // Initializer list constructor. std::multimap< KType, VType > mmap_name{ ... }; // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name; // Default constructor. Constructs an empty container. std::multimap< KType, VType, Compare > mmap_name; // Default constructor. Constructs an empty container. std::multimap< KType, VType, Compare > mmap_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::multimap< KType, VType, Compare > rmmap_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::multimap< KType, VType, Compare > mmap_name( comp ); // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name1; // Copy constructor. std::multimap< KType, VType > mmap_name2( mmap_name1 ); // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name1; // Copy constructor. std::multimap< KType, VType > mmap_name2 = mmap_name1; // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name1; // Move constructor. std::multimap< KType, VType > mmap_name2( std::move( mmap_name1 ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::multimap< KType, VType, Compare > mmap_name1( comp ); std::multimap< KType, VType, Compare > mmap_name2( mmap_name1.begin(), mmap_name1.end(), comp /* optional */ ); std::multimap< KType, VType >* mmap_ptr = new std::multimap< KType, VType >; // Default constructor. Constructs an empty container. std::multimap< KType, VType > mmap_name; std::multimap< KType, VType >* mmap_ptr = new std::multimap< KType, VType >( mmap_name );","title":"Initialization Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#syntax-for-deleting-stdmultimap-pointers","text":"delete mmap_ptr;","title":"Syntax for Deleting std::multimap Pointers"},{"location":"MapsUnorderedMapsAndFlatMaps/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"MapsUnorderedMapsAndFlatMaps/#links_1","text":"std::multimap in cplusplus . std::multimap in cppreference .","title":"Links"},{"location":"MapsUnorderedMapsAndFlatMaps/#template-parameters_1","text":"Key : Type of the keys. T : Type of the mapped value. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the multimap because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-types_1","text":"key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node.","title":"Member Types"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-classes_1","text":"value_compare : Compares objects of type value_type (class).","title":"Member Classes"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-functions_1","text":"(constructor): Constructs the multimap (public member function). (destructor): Destructs the multimap (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function).","title":"Member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#non-member-functions_1","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two multimaps (function template). std::swap( std::multimap ) : Specializes the std::swap algorithm (function template). erase_if( std::multimap ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#unordered-maps","text":"","title":"Unordered Maps"},{"location":"MapsUnorderedMapsAndFlatMaps/#explanation_2","text":"Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value , and which allows for fast retrieval of individual elements based on their keys. In an unordered_map , the key value is generally used to uniquely identify the element , while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ. Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values ( with a constant average time complexity on average ). unordered_map containers are faster than map containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements. Unordered maps implement the direct access operator ( operator[] ) which allows for direct access of the mapped value using its key value as argument. Iterators in the container are at least forward iterators . Their header file is <unordered_map> .","title":"Explanation"},{"location":"MapsUnorderedMapsAndFlatMaps/#declaration-syntax_2","text":"std::unordered_map< KType, VType > umap_name; // Not common, not recommend struct Hash { std::size_t operator()( const KType& obj ) const { // This is only an example. return std::hash< SubKType1 >()( obj._mem1 ) ^ std::hash< SubKType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const KType& lhs, const KType& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name; std::unordered_map< KType, VType >* umap_ptr;","title":"Declaration Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#initialization-syntax_2","text":"// Initializer list constructor. std::unordered_map< KType, VType > umap_name = { ... }; // Initializer list constructor. std::unordered_map< KType, VType > umap_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType, Hash, KeyEqual > umap_name; // Constructs an empty container. Hash hash; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( hash, key_equal ); // Constructs an empty container. std::unordered_map< KType, VType > umap_name( size ); // Constructs an empty container. std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( size ); // Constructs an empty container. Hash hash; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name1; // Copy constructor. std::unordered_map< KType, VType > umap_name2( umap_name1 ); // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name1; // Copy constructor. std::unordered_map< KType, VType > umap_name2 = umap_name1; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name1; // Move constructor. std::unordered_map< KType, VType > umap_name2( std::move( umap_name1 ) ); // Initializer list constructor. std::unordered_map< KType, VType, Hash, KeyEqual > umap_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::unordered_map< KType, VType, Hash, KeyEqual > umap_name2( umap_name1.begin(), umap_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_map< KType, VType >* umap_ptr = new std::unordered_map< KType, VType >; // Default constructor. Constructs an empty container. std::unordered_map< KType, VType > umap_name; std::unordered_map< KType, VType >* umap_ptr = new std::unordered_map< KType, VType >( umap_name );","title":"Initialization Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#syntax-for-deleting-stdunordered_map-pointers","text":"delete umap_ptr;","title":"Syntax for Deleting std::unordered_map Pointers"},{"location":"MapsUnorderedMapsAndFlatMaps/#members-and-related-stuffs_2","text":"","title":"Members and Related Stuffs"},{"location":"MapsUnorderedMapsAndFlatMaps/#links_2","text":"std::unordered_map in cplusplus . std::unordered_map in cppreference .","title":"Links"},{"location":"MapsUnorderedMapsAndFlatMaps/#template-parameters_2","text":"Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-types_2","text":"key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17): Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type .","title":"Member Types"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-functions_2","text":"(constructor): Constructs the unordered map (public member function). (destructor): Destructs the unordered map (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function).","title":"Member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#non-member-functions_2","text":"operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered maps (function template). std::swap( std::unordered_map ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_map ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#unordered-multimaps","text":"","title":"Unordered Multimaps"},{"location":"MapsUnorderedMapsAndFlatMaps/#explanation_3","text":"Unordered multimaps are associative containers that store elements formed by the combination of a key value and a mapped value , much like unordered_map containers, but allowing different elements to have equivalent keys . In an unordered_multimap , the key value is generally used to uniquely identify the element , while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ. Internally, the elements in the unordered_multimap are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values ( with a constant average time complexity on average ). Elements with equivalent keys are grouped together in the same bucket and in such a way that an iterator (see equal_range ) can iterate through all of them. Iterators in the container are at least forward iterators . Their header file is <unordered_map> .","title":"Explanation"},{"location":"MapsUnorderedMapsAndFlatMaps/#declaration-syntax_3","text":"std::unordered_multimap< KType, VType > ummap_name; // Not common, not recommend struct Hash { std::size_t operator()( const KType& obj ) const { // This is only an example. return std::hash< SubKType1 >()( obj._mem1 ) ^ std::hash< SubKType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const KType& lhs, const KType& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name; std::unordered_multimap< KType, VType >* ummap_ptr;","title":"Declaration Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#initialization-syntax_3","text":"// Initializer list constructor. std::unordered_multimap< KType, VType > ummap_name = { ... }; // Initializer list constructor. std::unordered_multimap< KType, VType > ummap_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name; // Constructs an empty container. Hash hash; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( hash, key_equal ); // Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name( size ); // Constructs an empty container. std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( size ); // Constructs an empty container. Hash hash; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name1; // Copy constructor. std::unordered_multimap< KType, VType > ummap_name2( ummap_name1 ); // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name1; // Copy constructor. std::unordered_multimap< KType, VType > ummap_name2 = ummap_name1; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name1; // Move constructor. std::unordered_multimap< KType, VType > ummap_name2( std::move( ummap_name1 ) ); // Initializer list constructor. std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::unordered_multimap< KType, VType, Hash, KeyEqual > ummap_name2( ummap_name1.begin(), ummap_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_multimap< KType, VType >* ummap_ptr = new std::unordered_multimap< KType, VType >; // Default constructor. Constructs an empty container. std::unordered_multimap< KType, VType > ummap_name; std::unordered_multimap< KType, VType >* ummap_ptr = new std::unordered_multimap< KType, VType >( ummap_name );","title":"Initialization Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#syntax-for-deleting-stdunordered_multimap-pointers","text":"delete ummap_ptr;","title":"Syntax for Deleting std::unordered_multimap Pointers"},{"location":"MapsUnorderedMapsAndFlatMaps/#members-and-related-stuffs_3","text":"","title":"Members and Related Stuffs"},{"location":"MapsUnorderedMapsAndFlatMaps/#links_3","text":"std::unordered_multimap in cplusplus . std::unordered_multimap in cppreference .","title":"Links"},{"location":"MapsUnorderedMapsAndFlatMaps/#template-parameters_3","text":"Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-types_3","text":"key_type : Key . mapped_type : T . value_type : std::pair< const Key, T > . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17): Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type .","title":"Member Types"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-functions_3","text":"(constructor): Constructs the unordered multimap (public member function). (destructor): Destructs the unordered multimap (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function).","title":"Member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#non-member-functions_3","text":"operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered multimaps (function template). std::swap( std::unordered_multimap ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_multimap ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#flat-maps","text":"","title":"Flat Maps"},{"location":"MapsUnorderedMapsAndFlatMaps/#explanation_4","text":"Flat maps are an associative container that stores elements formed by a combination of a key value and a mapped value , but is implemented as a sorted sequence , typically using a vector. In a flat_map , the key values are generally used to sort and uniquely identify the elements , while the mapped values store the content associated with this key, similar to traditional maps. The types of key and mapped value may differ and are grouped together in the member type value_type , which is a pair type combining both: typedef std::pair<const Key, T> value_type; . Different mapped values must have different key values , ensuring that each key in a flat_map uniquely identifies a single mapped value. Internally, the elements in a flat_map are stored as a sorted vector , which allows for binary search for efficient lookups and iteration based on the key\u2019s order. flat_map containers can be faster than traditional maps for access to individual elements by their key due to contiguous memory storage , but they may incur overhead for insertions and deletions due to the need to maintain sorted order. The mapped values in a flat_map can be accessed directly by their corresponding key using the bracket operator ( operator[] ) , similar to regular maps. The class template flat_map acts as a wrapper to the two underlying containers , passed as objects of type KeyContainer and MappedContainer respectively. The first container is sorted, and for each key its corresponding value is in the second container at the same index ( offset ). The number of elements in both containers is the same. The header file for flat_map is <experimental/flat_map> (or may be found in other namespaces in different implementations).","title":"Explanation"},{"location":"MapsUnorderedMapsAndFlatMaps/#declaration-syntax_4","text":"std::flat_map< KType, VType > fmap_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_map< KType, VType, Compare > fmap_name; // Not common, not recommend std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name; std::flat_map< KType, VType >* fmap_ptr;","title":"Declaration Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#initialization-syntax_4","text":"// Initializer list constructor std::flat_map< KType, VType > fmap_name = { ... }; // Initializer list constructor std::flat_map< KType, VType > fmap_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_map< KType, VType > fmap_name; // Default constructor. Constructs an empty container adaptor. std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name; // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( kcont, vcont ); // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( kcont, vcont, comp ); // Specify that all elements are unique. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. std::sorted_unique_t s; KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( s, kcont, vcont ); // Specify that all elements are unique. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( s, kcont, vcont, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name1; // Copy constructor. std::flat_map< KType, VType > fmap_name2( fmap_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name1; // Copy constructor. std::flat_map< KType, VType > fmap_name2 = fmap_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name1; // Move constructor. std::flat_map< KType, VType > fmap_name2( std::move( fmap_name1 ) ); // Specify that all elements are unique. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name1( s, kcont, vcont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_map< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmap_name2( s /* optional */, fmap_name1.begin(), fmap_name1.end(), comp /* optional */ ); std::flat_map< KType, VType >* fmap_ptr = new std::flat_map< KType, VType >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_map< KType, VType > fmap_name; std::flat_map< KType, VType >* fmap_ptr = new std::flat_map< KType, VType >( fmap_name );","title":"Initialization Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#syntax-for-deleting-stdflat_map-pointers","text":"delete fmap_ptr;","title":"Syntax for Deleting std::flat_map Pointers"},{"location":"MapsUnorderedMapsAndFlatMaps/#members-and-related-stuffs_4","text":"","title":"Members and Related Stuffs"},{"location":"MapsUnorderedMapsAndFlatMaps/#links_4","text":"std::flat_map in cplusplus . std::flat_map in cppreference .","title":"Links"},{"location":"MapsUnorderedMapsAndFlatMaps/#template-parameters_4","text":"Key : The type of the keys. T : The type of mapped values. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat set because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer , MappedContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements.","title":"Template Parameters"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-types_4","text":"key_containre_type : KeyContainer . mapped_containre_type : MappedContainer . key_type : Key . mapped_type : T . value_type : std::pair< key_type, mapped_type > . key_compare : Compare . reference : std::pair< const key_type&, mapped_type& > . const_reference : std::pair< const key_type&, const mapped_type& > . size_type : std::size_t . difference_type : std::ptrdiff_t . iterator : Implementation-defined LegacyInputIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyInputIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . containers : Type describing the underlying containers. CPP struct containers { key_container_type keys; mapped_container_type values; };","title":"Member Types"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-classes_2","text":"value_compare : Compares objects of type value_type (class).","title":"Member Classes"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-objects","text":"c ( private ): The object of type containers (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ).","title":"Member Objects"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-functions_4","text":"(constructor): Constructs the flat map (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access or insert specified element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). try_emplace (C++17): Inserts in-place if the key does not exist, does nothing if the key insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). insert_or_assign (C++17): Inserts an element or assigns to the current element if the key extract : Extracts the underlying containers (public member function). replace : Replaces the underlying containers (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). keys : Direct access to the underlying keys container (public member function). values : Direct access to the underlying values container (public member function).","title":"Member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#non-member-functions_4","text":"operator== , operator<=> : Lexicographically compares the values of two flat maps (function template). std::swap( std::flat_map ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_map ) : Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#helper-classes","text":"std::uses_allocator< std::flat_map > (C++23): Specializes the std::uses_allocat or type trait (class template specialization).","title":"Helper classes"},{"location":"MapsUnorderedMapsAndFlatMaps/#tags","text":"sorted_unique , sorted_unique_t (C++23): indicates that elements of a range are sorted and unique (tag).","title":"Tags"},{"location":"MapsUnorderedMapsAndFlatMaps/#flat-multimaps","text":"","title":"Flat Multimaps"},{"location":"MapsUnorderedMapsAndFlatMaps/#explanation_5","text":"Flat multimaps are an associative container that stores elements formed by a combination of a key value and a mapped value , implemented as a sorted sequence , typically using a vector. In a flat_multimap , the key values can be associated with multiple mapped values , allowing for duplicate keys, which distinguishes it from flat_map . The types of key and mapped value may differ and are grouped together in the member type value_type , which is a pair type combining both: typedef std::pair<const Key, T> value_type; . Multiple mapped values can share the same key value , enabling the storage of collections of values for each unique key, reflecting the nature of multimaps. Internally, the elements in a flat_multimap are stored as a sorted vector , which allows for binary search for efficient lookups and iteration based on the key\u2019s order. flat_multimap containers can be faster than traditional multimaps for access to individual elements by their key due to contiguous memory storage , but they may incur overhead for insertions and deletions due to the need to maintain sorted order. The mapped values in a flat_multimap can be accessed using iterators or the equal_range method to retrieve all values corresponding to a particular key . flat_multimap is typically implemented using a sorted vector , allowing for fast lookups while maintaining a compact memory footprint. The header file for flat_multimap is <experimental/flat_map> (or may be found in other namespaces in different implementations).","title":"Explanation"},{"location":"MapsUnorderedMapsAndFlatMaps/#declaration-syntax_5","text":"std::flat_multimap< KType, VType > fmmap_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const KType& lhs, const KType& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_multimap< KType, VType, Compare > fmmap_name; // Not common, not recommend std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name; std::flat_multimap< KType, VType >* fmmap_ptr;","title":"Declaration Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#initialization-syntax_5","text":"// Initializer list constructor std::flat_multimap< KType, VType > fmmap_name = { ... }; // Initializer list constructor std::flat_multimap< KType, VType > fmmap_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_multimap< KType, VType > fmmap_name; // Default constructor. Constructs an empty container adaptor. std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name; // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( kcont, vcont ); // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( kcont, vcont, comp ); // Allow different elements with the same value. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Construct a default `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( s, kcont, vcont ); // Allow different elements with the same value. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s: KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( s, kcont, vcont, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name1; // Copy constructor. std::flat_multimap< KType, VType > fmmap_name2( fmmap_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name1; // Copy constructor. std::flat_multimap< KType, VType > fmmap_name2 = fmmap_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name1; // Move constructor. std::flat_multimap< KType, VType > fmmap_name2( std::move( fmmap_name1 ) ); // Allow different elements with the same value. Just a tag. // Constructs the two underlying containers by copying the contents of the container `kcont` and `vcont` separately. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< KType > kcont = { ... }; MappedContainer< VType > vcont = { ... }; Compare comp; std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name1( s, kcont, vcont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_multimap< KType, VType, Compare, KeyContainer< KType >, MappedContainer< VType > > fmmap_name2( s /* optional */, fmmap_name1.begin(), fmmap_name1.end(), comp /* optional */ ); std::flat_multimap< KType, VType >* fmmap_ptr = new std::flat_multimap< KType, VType >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multimap< KType, VType > fmmap_name; std::flat_multimap< KType, VType >* fmmap_ptr = new std::flat_multimap< KType, VType >( fmmap_name );","title":"Initialization Syntax"},{"location":"MapsUnorderedMapsAndFlatMaps/#syntax-for-deleting-stdflat_multimap-pointers","text":"delete fmmap_ptr;","title":"Syntax for Deleting std::flat_multimap Pointers"},{"location":"MapsUnorderedMapsAndFlatMaps/#members-and-related-stuffs_5","text":"","title":"Members and Related Stuffs"},{"location":"MapsUnorderedMapsAndFlatMaps/#links_5","text":"std::flat_multimap in cplusplus . std::flat_multimap in cppreference .","title":"Links"},{"location":"MapsUnorderedMapsAndFlatMaps/#template-parameters_5","text":"Key : The type of the keys. T : The type of mapped values. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat set because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer , MappedContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements.","title":"Template Parameters"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-types_5","text":"key_containre_type : KeyContainer . mapped_containre_type : MappedContainer . key_type : Key . mapped_type : T . value_type : std::pair< key_type, mapped_type > . key_compare : Compare . reference : std::pair< const key_type&, mapped_type& > . const_reference : std::pair< const key_type&, const mapped_type& > . size_type : std::size_t . difference_type : std::ptrdiff_t . iterator : Implementation-defined LegacyInputIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyInputIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . containers : Type describing the underlying containers. CPP struct containers { key_container_type keys; mapped_container_type values; };","title":"Member Types"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-classes_3","text":"value_compare : Compares objects of type value_type (class).","title":"Member Classes"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-objects_1","text":"c ( private ): The object of type containers (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ).","title":"Member Objects"},{"location":"MapsUnorderedMapsAndFlatMaps/#member-functions_5","text":"(constructor): Constructs the flat multimap (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). extract : Extracts the underlying containers (public member function). replace : Replaces the underlying containers (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). keys : Direct access to the underlying keys container (public member function). values : Direct access to the underlying values container (public member function).","title":"Member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#non-member-functions_5","text":"operator== , operator<=> : Lexicographically compares the values of two flat multimaps (function template). std::swap( std::flat_multimap ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_multimap ) : Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"MapsUnorderedMapsAndFlatMaps/#helper-classes_1","text":"std::uses_allocator< std::flat_multimap > (C++23): Specializes the std::uses_allocat or type trait (class template specialization).","title":"Helper classes"},{"location":"MapsUnorderedMapsAndFlatMaps/#tags_1","text":"sorted_equivalent , sorted_equivalent_t (C++23): indicates that elements of a range are sorted and unique (tag).","title":"Tags"},{"location":"MemoryPartitions/","text":"Memory Partitions Stack Purpose Allocation/Deallocation Lifetime Scope Size Structure Performance Other Characteristics Heap (Dynamic Memory) Purpose Allocation/Deallocation Lifetime Scope Size Structure Performance Other Characteristics Data Segment (Global/Static Memory) Purpose Allocation/Deallocation Lifetime Scope Size Structure Performance Other Characteristics Code Segment (Text Segment) Purpose Allocation/Deallocation Lifetime Scope Size Structure Performance Other Characteristics Memory Mapping Segment Purpose Allocation/Deallocation Lifetime Scope Size Structure Performance Other Characteristics Memory Partitioning in C++ Program Execution Notes Memory Partitions Stack Purpose Stores local variables and function call information (such as return addresses and parameters). Data is lost when it goes out of scope . Allocation/Deallocation Automatically handled by the compiler. Memory for local variables is allocated when a function is called and deallocated when the function exits . Allocating memory requires only one CPU instruction . Lifetime Local variables exist only for the duration of the function call . Scope Limited to the function where the variables are declared . Size Predefined to a default value (typically between 1 MB and 10 MB , determined by the OS), but the stack can grow as the application progresses. (Grows downward in memory). However, the stack's growth is usually limited by system settings . If the stack grows too large, a stack overflow occurs. The stack is prone to overflow due to deep recursion or large allocations of local variables. On Linux systems, the stack size limit for a process can be adjusted , either temporarily or permanently, using the ulimit command , providing flexibility in managing memory resources during runtime. Structure Follows a LIFO (Last In, First Out) structure. Memory is deallocated in reverse order of allocation. Stores data like a physical stack, pushing new data and updating the stack pointer . Performance Fast access due to contiguous memory layout and minimal overhead. Allocation and deallocation are faster than heap operations. Other Characteristics Data is close together in memory, reducing cache misses . Fits well into one CPU cache line due to the locality of reference. Heap (Dynamic Memory) Purpose Stores dynamically allocated objects created during runtime. Used when the amount of memory needed is not known in advance. Allocation/Deallocation Manual allocation using new/delete or malloc/free . Memory needs to be explicitly deallocated to avoid leaks . Lifetime Exists until explicitly deallocated by the programmer. Remains available even after the function that allocated it exits, as long as the pointer is preserved. If the programmer forgets to release these variables, the system will delete them and reclaim the memory they occupied after the program exits. Scope Global scope if the pointer to allocated memory is retained. Accessible from anywhere in the program through the pointer. Size Predefined to a default value according to the system but can grow and shrink as the application progresses. (Grows upward in memory). Limited by system memory and subject to fragmentation . Large allocations are possible, unlike the stack. Structure Unstructured memory, allocated and freed in any order. Can lead to fragmentation if memory is not carefully managed. Performance Slower than stack due to non-contiguous memory and overhead of managing free space. Fragmentation can impact performance over time. Other Characteristics Maintains a free list to check if there is free memory available for the application to use. If there is not enough heap memory , it will ask the system to allocate more memory . The performance cost of this allocation is high . More cache misses . Data Segment (Global/Static Memory) Purpose Stores global, static, and constant variables . Retains values throughout the entire program lifecycle . Allocation/Deallocation Allocated at program startup and deallocated at program termination . Lifetime Exists for the entire duration of the program. Retains values across function calls. Scope Global scope : Accessible from any part of the program. Size Depends on the size and number of variables. Limited by the linker and system memory . Structure Includes: Constant segment : Stores string literals and constants . Initialized data segment : Stores variables with explicit initial values. BSS (uninitialized data segment, block started by symbol) : Stores variables with no initial values, which are initialized to zero by default . Organized as a continuous memory block for static, global and const variables/values. The storage order: Constant segment, initialized data segment, BSS . Performance Fast access due to fixed memory locations. Avoids runtime allocation overhead. Other Characteristics Persistent values can introduce side effects if not managed properly. Typically read-only for constants to prevent accidental modification. Code Segment (Text Segment) Purpose Stores compiled instructions (machine code) of the program. Allocation/Deallocation Allocated at program startup and remains until the program ends. Managed by the OS and loader . Lifetime Exists for the entire runtime of the program. Scope Not applicable; read-only segment. Size Depends on the size of the compiled code . Limited by system memory and linker constraints. Structure A contiguous block of machine instructions. Organized for sequential execution by the CPU. Performance Fast execution due to CPU caching and sequential access. Code segment is often optimized for cache utilization. Other Characteristics Read-only to prevent accidental or malicious modification. Supports function-level optimizations during compilation. Memory Mapping Segment Purpose Used for mapping files or shared libraries into memory. Enables efficient access to large files without loading them entirely into RAM. Allocation/Deallocation Managed by the OS using functions like mmap . Deallocated when the file is closed or the mapping is removed. Lifetime Varies based on file or library usage . Scope Accessible globally from any part of the program. Size Depends on the size of the mapped file or library . Either fixed or dynamic (grows upward in memory) , depending on the type of mapping. Structure Divided into read-only and read-write segments. Supports lazy loading , where only accessed portions are loaded. Performance Efficient for large files as only necessary parts are loaded. Reduces memory usage compared to loading the entire file. Other Characteristics Enables shared access across processes for libraries or files. Requires OS-level support for memory mapping. Memory Partitioning in C++ Program Execution Stack vs. Heap: The stack is fast and automatically managed , but limited in size . The heap allows for more flexible memory usage at the cost of manual management . Global/Static vs. Local: Global and static variables have global lifetimes, while local variables (on the stack) have a shorter scope, limited to the block they are declared in. Notes store data on stack > store data on heap > store pointers on stack > store pointers on heap. The storage order: Text segment, data segment, memory mapping segment, heap, stack. (May vary, depending on OS, hardwares and compiler settings)","title":"Memory Partitions"},{"location":"MemoryPartitions/#memory-partitions","text":"","title":"Memory Partitions"},{"location":"MemoryPartitions/#stack","text":"","title":"Stack"},{"location":"MemoryPartitions/#purpose","text":"Stores local variables and function call information (such as return addresses and parameters). Data is lost when it goes out of scope .","title":"Purpose"},{"location":"MemoryPartitions/#allocationdeallocation","text":"Automatically handled by the compiler. Memory for local variables is allocated when a function is called and deallocated when the function exits . Allocating memory requires only one CPU instruction .","title":"Allocation/Deallocation"},{"location":"MemoryPartitions/#lifetime","text":"Local variables exist only for the duration of the function call .","title":"Lifetime"},{"location":"MemoryPartitions/#scope","text":"Limited to the function where the variables are declared .","title":"Scope"},{"location":"MemoryPartitions/#size","text":"Predefined to a default value (typically between 1 MB and 10 MB , determined by the OS), but the stack can grow as the application progresses. (Grows downward in memory). However, the stack's growth is usually limited by system settings . If the stack grows too large, a stack overflow occurs. The stack is prone to overflow due to deep recursion or large allocations of local variables. On Linux systems, the stack size limit for a process can be adjusted , either temporarily or permanently, using the ulimit command , providing flexibility in managing memory resources during runtime.","title":"Size"},{"location":"MemoryPartitions/#structure","text":"Follows a LIFO (Last In, First Out) structure. Memory is deallocated in reverse order of allocation. Stores data like a physical stack, pushing new data and updating the stack pointer .","title":"Structure"},{"location":"MemoryPartitions/#performance","text":"Fast access due to contiguous memory layout and minimal overhead. Allocation and deallocation are faster than heap operations.","title":"Performance"},{"location":"MemoryPartitions/#other-characteristics","text":"Data is close together in memory, reducing cache misses . Fits well into one CPU cache line due to the locality of reference.","title":"Other Characteristics"},{"location":"MemoryPartitions/#heap-dynamic-memory","text":"","title":"Heap (Dynamic Memory)"},{"location":"MemoryPartitions/#purpose_1","text":"Stores dynamically allocated objects created during runtime. Used when the amount of memory needed is not known in advance.","title":"Purpose"},{"location":"MemoryPartitions/#allocationdeallocation_1","text":"Manual allocation using new/delete or malloc/free . Memory needs to be explicitly deallocated to avoid leaks .","title":"Allocation/Deallocation"},{"location":"MemoryPartitions/#lifetime_1","text":"Exists until explicitly deallocated by the programmer. Remains available even after the function that allocated it exits, as long as the pointer is preserved. If the programmer forgets to release these variables, the system will delete them and reclaim the memory they occupied after the program exits.","title":"Lifetime"},{"location":"MemoryPartitions/#scope_1","text":"Global scope if the pointer to allocated memory is retained. Accessible from anywhere in the program through the pointer.","title":"Scope"},{"location":"MemoryPartitions/#size_1","text":"Predefined to a default value according to the system but can grow and shrink as the application progresses. (Grows upward in memory). Limited by system memory and subject to fragmentation . Large allocations are possible, unlike the stack.","title":"Size"},{"location":"MemoryPartitions/#structure_1","text":"Unstructured memory, allocated and freed in any order. Can lead to fragmentation if memory is not carefully managed.","title":"Structure"},{"location":"MemoryPartitions/#performance_1","text":"Slower than stack due to non-contiguous memory and overhead of managing free space. Fragmentation can impact performance over time.","title":"Performance"},{"location":"MemoryPartitions/#other-characteristics_1","text":"Maintains a free list to check if there is free memory available for the application to use. If there is not enough heap memory , it will ask the system to allocate more memory . The performance cost of this allocation is high . More cache misses .","title":"Other Characteristics"},{"location":"MemoryPartitions/#data-segment-globalstatic-memory","text":"","title":"Data Segment (Global/Static Memory)"},{"location":"MemoryPartitions/#purpose_2","text":"Stores global, static, and constant variables . Retains values throughout the entire program lifecycle .","title":"Purpose"},{"location":"MemoryPartitions/#allocationdeallocation_2","text":"Allocated at program startup and deallocated at program termination .","title":"Allocation/Deallocation"},{"location":"MemoryPartitions/#lifetime_2","text":"Exists for the entire duration of the program. Retains values across function calls.","title":"Lifetime"},{"location":"MemoryPartitions/#scope_2","text":"Global scope : Accessible from any part of the program.","title":"Scope"},{"location":"MemoryPartitions/#size_2","text":"Depends on the size and number of variables. Limited by the linker and system memory .","title":"Size"},{"location":"MemoryPartitions/#structure_2","text":"Includes: Constant segment : Stores string literals and constants . Initialized data segment : Stores variables with explicit initial values. BSS (uninitialized data segment, block started by symbol) : Stores variables with no initial values, which are initialized to zero by default . Organized as a continuous memory block for static, global and const variables/values. The storage order: Constant segment, initialized data segment, BSS .","title":"Structure"},{"location":"MemoryPartitions/#performance_2","text":"Fast access due to fixed memory locations. Avoids runtime allocation overhead.","title":"Performance"},{"location":"MemoryPartitions/#other-characteristics_2","text":"Persistent values can introduce side effects if not managed properly. Typically read-only for constants to prevent accidental modification.","title":"Other Characteristics"},{"location":"MemoryPartitions/#code-segment-text-segment","text":"","title":"Code Segment (Text Segment)"},{"location":"MemoryPartitions/#purpose_3","text":"Stores compiled instructions (machine code) of the program.","title":"Purpose"},{"location":"MemoryPartitions/#allocationdeallocation_3","text":"Allocated at program startup and remains until the program ends. Managed by the OS and loader .","title":"Allocation/Deallocation"},{"location":"MemoryPartitions/#lifetime_3","text":"Exists for the entire runtime of the program.","title":"Lifetime"},{"location":"MemoryPartitions/#scope_3","text":"Not applicable; read-only segment.","title":"Scope"},{"location":"MemoryPartitions/#size_3","text":"Depends on the size of the compiled code . Limited by system memory and linker constraints.","title":"Size"},{"location":"MemoryPartitions/#structure_3","text":"A contiguous block of machine instructions. Organized for sequential execution by the CPU.","title":"Structure"},{"location":"MemoryPartitions/#performance_3","text":"Fast execution due to CPU caching and sequential access. Code segment is often optimized for cache utilization.","title":"Performance"},{"location":"MemoryPartitions/#other-characteristics_3","text":"Read-only to prevent accidental or malicious modification. Supports function-level optimizations during compilation.","title":"Other Characteristics"},{"location":"MemoryPartitions/#memory-mapping-segment","text":"","title":"Memory Mapping Segment"},{"location":"MemoryPartitions/#purpose_4","text":"Used for mapping files or shared libraries into memory. Enables efficient access to large files without loading them entirely into RAM.","title":"Purpose"},{"location":"MemoryPartitions/#allocationdeallocation_4","text":"Managed by the OS using functions like mmap . Deallocated when the file is closed or the mapping is removed.","title":"Allocation/Deallocation"},{"location":"MemoryPartitions/#lifetime_4","text":"Varies based on file or library usage .","title":"Lifetime"},{"location":"MemoryPartitions/#scope_4","text":"Accessible globally from any part of the program.","title":"Scope"},{"location":"MemoryPartitions/#size_4","text":"Depends on the size of the mapped file or library . Either fixed or dynamic (grows upward in memory) , depending on the type of mapping.","title":"Size"},{"location":"MemoryPartitions/#structure_4","text":"Divided into read-only and read-write segments. Supports lazy loading , where only accessed portions are loaded.","title":"Structure"},{"location":"MemoryPartitions/#performance_4","text":"Efficient for large files as only necessary parts are loaded. Reduces memory usage compared to loading the entire file.","title":"Performance"},{"location":"MemoryPartitions/#other-characteristics_4","text":"Enables shared access across processes for libraries or files. Requires OS-level support for memory mapping.","title":"Other Characteristics"},{"location":"MemoryPartitions/#memory-partitioning-in-c-program-execution","text":"Stack vs. Heap: The stack is fast and automatically managed , but limited in size . The heap allows for more flexible memory usage at the cost of manual management . Global/Static vs. Local: Global and static variables have global lifetimes, while local variables (on the stack) have a shorter scope, limited to the block they are declared in.","title":"Memory Partitioning in C++ Program Execution"},{"location":"MemoryPartitions/#notes","text":"store data on stack > store data on heap > store pointers on stack > store pointers on heap. The storage order: Text segment, data segment, memory mapping segment, heap, stack. (May vary, depending on OS, hardwares and compiler settings)","title":"Notes"},{"location":"NewAndDelete/","text":"new and delete new Explanation Syntax new( address ) Explanation Syntax delete Explanation Syntax ::operator new( size ) Explanation Syntax operator delete( ptr ) Explanation Syntax malloc calloc realloc free Pointers new and delete new Explanation The new operator dynamically allocates memory for an object and calls its constructor . It returns a void pointer to the allocated memory. Syntax Type* ptr = new Type; // For a single object. Type* arr_ptr = new Type[size]; // For an array objects. new( address ) Explanation The placement new operator allows you to construct an object at a specified memory address , which is useful for optimizing memory usage or working with pre-allocated memory . It also calls the constructor of the object and returns a void pointer to the allocated memory. Syntax Type* ptr = new( address ) Type; // For a single object. Type* arr_ptr = new( address ) Type[size]; // For an array objects. delete Explanation The delete operator deallocates memory that was previously allocated with new , calling the destructor of the object before releasing the memory. After calling delete , it's a good practice to set the pointer to nullptr to avoid dangling pointers. Syntax delete ptr; // For a single object. ptr = nullptr; // Good practice to avoid dangling pointers. delete[] arr_ptr; // For an array objects. arr_ptr = nullptr; // Good practice to avoid dangling pointers. ::operator new( size ) Explanation ::operator new is a global operator function that allocates raw memory without initializing it. It's similar to malloc , but it can be overridden to customize memory allocation for user-defined types. It does not call constructors and only allocates memory . ::operator delete should be used to free memory allocated with ::operator new . Syntax // Its declaration syntax. void* ptr = ::operator new( size_t size ); // Its usage syntax. Type* ptr = static_cast< Type* >( ::operator new( num * sizeof( Type ) ) ); operator delete( ptr ) Explanation ::operator delete is a global operator function that deallocates memory previously allocated with ::operator new . It's similar to free , but it can be overridden to customize memory deallocation for user-defined types. ::operator delete does not call destructors and only frees the memory . After calling ::operator delete , it's a good practice to set the pointer to nullptr to avoid dangling pointers. Syntax // Its declaration syntax. void operator delete( void* ptr ) noexcept; // Its usage syntax. ::operator delete( ptr ); ptr = nullptr; // Good practice to avoid dangling pointers. malloc malloc calloc calloc realloc realloc free free Pointers Pointers","title":"new and delete"},{"location":"NewAndDelete/#new-and-delete","text":"","title":"new and delete"},{"location":"NewAndDelete/#new","text":"","title":"new"},{"location":"NewAndDelete/#explanation","text":"The new operator dynamically allocates memory for an object and calls its constructor . It returns a void pointer to the allocated memory.","title":"Explanation"},{"location":"NewAndDelete/#syntax","text":"Type* ptr = new Type; // For a single object. Type* arr_ptr = new Type[size]; // For an array objects.","title":"Syntax"},{"location":"NewAndDelete/#new-address","text":"","title":"new( address )"},{"location":"NewAndDelete/#explanation_1","text":"The placement new operator allows you to construct an object at a specified memory address , which is useful for optimizing memory usage or working with pre-allocated memory . It also calls the constructor of the object and returns a void pointer to the allocated memory.","title":"Explanation"},{"location":"NewAndDelete/#syntax_1","text":"Type* ptr = new( address ) Type; // For a single object. Type* arr_ptr = new( address ) Type[size]; // For an array objects.","title":"Syntax"},{"location":"NewAndDelete/#delete","text":"","title":"delete"},{"location":"NewAndDelete/#explanation_2","text":"The delete operator deallocates memory that was previously allocated with new , calling the destructor of the object before releasing the memory. After calling delete , it's a good practice to set the pointer to nullptr to avoid dangling pointers.","title":"Explanation"},{"location":"NewAndDelete/#syntax_2","text":"delete ptr; // For a single object. ptr = nullptr; // Good practice to avoid dangling pointers. delete[] arr_ptr; // For an array objects. arr_ptr = nullptr; // Good practice to avoid dangling pointers.","title":"Syntax"},{"location":"NewAndDelete/#operator-new-size","text":"","title":"::operator new( size )"},{"location":"NewAndDelete/#explanation_3","text":"::operator new is a global operator function that allocates raw memory without initializing it. It's similar to malloc , but it can be overridden to customize memory allocation for user-defined types. It does not call constructors and only allocates memory . ::operator delete should be used to free memory allocated with ::operator new .","title":"Explanation"},{"location":"NewAndDelete/#syntax_3","text":"// Its declaration syntax. void* ptr = ::operator new( size_t size ); // Its usage syntax. Type* ptr = static_cast< Type* >( ::operator new( num * sizeof( Type ) ) );","title":"Syntax"},{"location":"NewAndDelete/#operator-delete-ptr","text":"","title":"operator delete( ptr )"},{"location":"NewAndDelete/#explanation_4","text":"::operator delete is a global operator function that deallocates memory previously allocated with ::operator new . It's similar to free , but it can be overridden to customize memory deallocation for user-defined types. ::operator delete does not call destructors and only frees the memory . After calling ::operator delete , it's a good practice to set the pointer to nullptr to avoid dangling pointers.","title":"Explanation"},{"location":"NewAndDelete/#syntax_4","text":"// Its declaration syntax. void operator delete( void* ptr ) noexcept; // Its usage syntax. ::operator delete( ptr ); ptr = nullptr; // Good practice to avoid dangling pointers.","title":"Syntax"},{"location":"NewAndDelete/#malloc","text":"malloc","title":"malloc"},{"location":"NewAndDelete/#calloc","text":"calloc","title":"calloc"},{"location":"NewAndDelete/#realloc","text":"realloc","title":"realloc"},{"location":"NewAndDelete/#free","text":"free","title":"free"},{"location":"NewAndDelete/#pointers","text":"Pointers","title":"Pointers"},{"location":"Operators/","text":"Operators Explanation Categories Operator Overloading Explanation Syntax Copy-assignment Operator Default Copy-assignment Operator Explanation Syntax Copy-assignment Operator Overloading Explanation Syntax Move-assignment Operator Default Move-assignment Operator Explanation Syntax Move-assignment Operator Overloading Explanation Syntax Conversion Operator Explanation Conversion Operator Overloading Syntax Notes explicit Conversion Operator new and delete The Usage of the : Operator Notes Operators Explanation Operators are symbols that perform operations on variables or values . They allow concise data manipulation, comparisons, and control of program logic. Operators follow specific rules of precedence and associativity to determine the order of evaluation in complex expressions. Additionally, operators can be overloaded for custom behavior in user-defined types, improving code flexibility and reusability. In fact, it's a function . It makes our code clearer. Categories Arithmetic operators: Perform basic mathematical operations. + (Addition). - (Subtraction). * (Multiplication). / (Division). % (Modulus). Relational (comparison) operators: Compare two values and return a boolean result ( true or false ). == (Equal to). != (Not equal to). < (Less than). > (Greater than). <= (Less than or equal to). >= (Greater than or equal to). Logical operators: Combine or invert boolean expressions. && (Logical AND). || (Logical OR). ! (Logical NOT). Bitwise operators: Perform bit-level operations on integral values. & (AND). | (OR). ^ (XOR). ~ (Complement). << (Left shift). >> (Right shift). Assignment operators: Assign values to variables, sometimes performing operations during assignment. = (Simple assignment). += (Add and assign). -= (Subtract and assign). = (Multiply and assign). /= (Divide and assign). Unary operators: Operate on a single operand. ++ (Increment). -- (Decrement). + (Unary plus). - (Unary minus). Ternary operator: A compact form of an if-else statement. ? : (Conditional operator). Type casting operators: Convert one data type to another. static_cast . dynamic_cast . const_cast . reinterpret_cast . Comma operator ( , ): Evaluates multiple expressions from left to right, returning the value of the last expression. Member access operators: Access members of classes or objects. . (Direct member access). -> (Indirect member access through a pointer). Memory management operators: Allocate and deallocate dynamic memory. new (Allocates memory). new[] (Allocates memory for arrays). delete (Deallocates memory). delete[] (Deallocates memory for arrays). Sizeof operator ( sizeof ): Returns the size, in bytes, of a data type or object. Typeid operator ( typeid ): Returns the type information of an expression or a type. Operator Overloading Explanation Operator overloading allows you to define custom behavior for operators (e.g . , + , - , = , etc.) when they are used with user-defined types (classes or structs). The RetType depends on the output of the operator which you want to overload. The para_list depends on the inputs to the operator and the object you want to operate on. Syntax RetType operatorSymbol( para_list ); Copy-assignment Operator Default Copy-assignment Operator Explanation The default copy-assignment operator is generated by the compiler if no user-defined copy-assignment operator is provided. It handles shallow copies , which may lead to issues like double deletion if pointers are involved. The = default syntax explicitly requests the compiler to generate the default copy-assignment operator . Syntax ClassName& operator=( const ClassName& ) = default; Copy-assignment Operator Overloading Explanation The copy-assignment operator can be overloaded to handle deep copies , manage resources appropriately, and perform self-assignment checks. The parameter of a copy constructor and copy assignment operator should not be passed by value , as this can lead to issues. When passing the argument by value, the copy constructor will be called to create a temporary object for the parameter. This temporary object creation requires another call to the copy constructor, which leads to a recursive cycle. The cycle continues until the call stack overflows, causing a stack overflow error. In other words, passing by value in the copy constructor or copy assignment operator triggers an infinite loop , as each invocation requires another copy of the argument, which again invokes the copy constructor. Syntax ClassName& operator=( const ClassName& other ) { // Custom copy logic here. return *this; }; Move-assignment Operator Default Move-assignment Operator Explanation The default move-assignment operator is generated by the compiler if no user-defined copy-assignment operator is provided. It handles shallow moves , which may lead to issues like double deletion if pointers are involved. The state of the moved-from object is unspecified but valid after the operation. The = default syntax explicitly requests the compiler to generate the default move-assignment operator . Syntax ClassName& operator=( ClassName&& ) = default; Move-assignment Operator Overloading Explanation The move-assignment operator can be overloaded to control how resources are transferred between objects. It handles deep moves , which deals with issues like double deletion if pointers are involved. Syntax ClassName& operator=(ClassName&& other) noexcept { // Custom move logic here. return *this; }; Conversion Operator Explanation The conversion operator specifies how to convert an object of the class to a designated target type , which can be beneficial for implicit conversions or explicit type casting. Implicit conversion : If defined, the conversion can occur automatically in certain contexts (e.g., passing an object to a function expecting a different type). Explicit conversion : If marked with explicit , the conversion will only occur when explicitly requested, thus preventing unintended conversions. Conversion Operator Overloading Syntax // `const` function. operator TargetType() const { // Custom conversion logic here. }; Notes If we implement a smart pointer by ourselves, pass it as a reference into a function and want to judge it if it is a null pointer, bool conversion operator is needed . If a class only possesses one useful member , and we want to assign it to a primitive-type variables outside of the class without calling any function, `bool conversion operator is need . Problem : less readability of code, not work if functions have been overloaded. Advantange : make code cleaner. explicit Conversion Operator Conversion And Casting new and delete new and delete The Usage of the : Operator Scope resolution operator( :: ): CPP ClassName::member; NamespaceName:member; EnumclassName:member; Inheritance. Member initialization list. Conditional operator (ternary operator). Label in goto statements. CPP labelName: statement; Range-based for loop with structured bindings: CPP for ( auto& var : container ); for ( auto& [var1, var2, ...] : container ); Notes It is important to ensure that memory is deallocated using the corresponding operator that was used for allocation to avoid undefined behavior . Using ternary operators to replace an if-else statement when initializing an object can make it slightly faster . Using nested ternary operators can be confusing, so we should avoid using them . The compiler is smart enough so that it can optimize some arithmic operations to some bitwise operations, for example, 5 x 16 to 5 << 4 .","title":"Operators"},{"location":"Operators/#operators","text":"","title":"Operators"},{"location":"Operators/#explanation","text":"Operators are symbols that perform operations on variables or values . They allow concise data manipulation, comparisons, and control of program logic. Operators follow specific rules of precedence and associativity to determine the order of evaluation in complex expressions. Additionally, operators can be overloaded for custom behavior in user-defined types, improving code flexibility and reusability. In fact, it's a function . It makes our code clearer.","title":"Explanation"},{"location":"Operators/#categories","text":"Arithmetic operators: Perform basic mathematical operations. + (Addition). - (Subtraction). * (Multiplication). / (Division). % (Modulus). Relational (comparison) operators: Compare two values and return a boolean result ( true or false ). == (Equal to). != (Not equal to). < (Less than). > (Greater than). <= (Less than or equal to). >= (Greater than or equal to). Logical operators: Combine or invert boolean expressions. && (Logical AND). || (Logical OR). ! (Logical NOT). Bitwise operators: Perform bit-level operations on integral values. & (AND). | (OR). ^ (XOR). ~ (Complement). << (Left shift). >> (Right shift). Assignment operators: Assign values to variables, sometimes performing operations during assignment. = (Simple assignment). += (Add and assign). -= (Subtract and assign). = (Multiply and assign). /= (Divide and assign). Unary operators: Operate on a single operand. ++ (Increment). -- (Decrement). + (Unary plus). - (Unary minus). Ternary operator: A compact form of an if-else statement. ? : (Conditional operator). Type casting operators: Convert one data type to another. static_cast . dynamic_cast . const_cast . reinterpret_cast . Comma operator ( , ): Evaluates multiple expressions from left to right, returning the value of the last expression. Member access operators: Access members of classes or objects. . (Direct member access). -> (Indirect member access through a pointer). Memory management operators: Allocate and deallocate dynamic memory. new (Allocates memory). new[] (Allocates memory for arrays). delete (Deallocates memory). delete[] (Deallocates memory for arrays). Sizeof operator ( sizeof ): Returns the size, in bytes, of a data type or object. Typeid operator ( typeid ): Returns the type information of an expression or a type.","title":"Categories"},{"location":"Operators/#operator-overloading","text":"","title":"Operator Overloading"},{"location":"Operators/#explanation_1","text":"Operator overloading allows you to define custom behavior for operators (e.g . , + , - , = , etc.) when they are used with user-defined types (classes or structs). The RetType depends on the output of the operator which you want to overload. The para_list depends on the inputs to the operator and the object you want to operate on.","title":"Explanation"},{"location":"Operators/#syntax","text":"RetType operatorSymbol( para_list );","title":"Syntax"},{"location":"Operators/#copy-assignment-operator","text":"","title":"Copy-assignment Operator"},{"location":"Operators/#default-copy-assignment-operator","text":"","title":"Default Copy-assignment Operator"},{"location":"Operators/#explanation_2","text":"The default copy-assignment operator is generated by the compiler if no user-defined copy-assignment operator is provided. It handles shallow copies , which may lead to issues like double deletion if pointers are involved. The = default syntax explicitly requests the compiler to generate the default copy-assignment operator .","title":"Explanation"},{"location":"Operators/#syntax_1","text":"ClassName& operator=( const ClassName& ) = default;","title":"Syntax"},{"location":"Operators/#copy-assignment-operator-overloading","text":"","title":"Copy-assignment Operator Overloading"},{"location":"Operators/#explanation_3","text":"The copy-assignment operator can be overloaded to handle deep copies , manage resources appropriately, and perform self-assignment checks. The parameter of a copy constructor and copy assignment operator should not be passed by value , as this can lead to issues. When passing the argument by value, the copy constructor will be called to create a temporary object for the parameter. This temporary object creation requires another call to the copy constructor, which leads to a recursive cycle. The cycle continues until the call stack overflows, causing a stack overflow error. In other words, passing by value in the copy constructor or copy assignment operator triggers an infinite loop , as each invocation requires another copy of the argument, which again invokes the copy constructor.","title":"Explanation"},{"location":"Operators/#syntax_2","text":"ClassName& operator=( const ClassName& other ) { // Custom copy logic here. return *this; };","title":"Syntax"},{"location":"Operators/#move-assignment-operator","text":"","title":"Move-assignment Operator"},{"location":"Operators/#default-move-assignment-operator","text":"","title":"Default Move-assignment Operator"},{"location":"Operators/#explanation_4","text":"The default move-assignment operator is generated by the compiler if no user-defined copy-assignment operator is provided. It handles shallow moves , which may lead to issues like double deletion if pointers are involved. The state of the moved-from object is unspecified but valid after the operation. The = default syntax explicitly requests the compiler to generate the default move-assignment operator .","title":"Explanation"},{"location":"Operators/#syntax_3","text":"ClassName& operator=( ClassName&& ) = default;","title":"Syntax"},{"location":"Operators/#move-assignment-operator-overloading","text":"","title":"Move-assignment Operator Overloading"},{"location":"Operators/#explanation_5","text":"The move-assignment operator can be overloaded to control how resources are transferred between objects. It handles deep moves , which deals with issues like double deletion if pointers are involved.","title":"Explanation"},{"location":"Operators/#syntax_4","text":"ClassName& operator=(ClassName&& other) noexcept { // Custom move logic here. return *this; };","title":"Syntax"},{"location":"Operators/#conversion-operator","text":"","title":"Conversion Operator"},{"location":"Operators/#explanation_6","text":"The conversion operator specifies how to convert an object of the class to a designated target type , which can be beneficial for implicit conversions or explicit type casting. Implicit conversion : If defined, the conversion can occur automatically in certain contexts (e.g., passing an object to a function expecting a different type). Explicit conversion : If marked with explicit , the conversion will only occur when explicitly requested, thus preventing unintended conversions.","title":"Explanation"},{"location":"Operators/#conversion-operator-overloading","text":"","title":"Conversion Operator Overloading"},{"location":"Operators/#syntax_5","text":"// `const` function. operator TargetType() const { // Custom conversion logic here. };","title":"Syntax"},{"location":"Operators/#notes","text":"If we implement a smart pointer by ourselves, pass it as a reference into a function and want to judge it if it is a null pointer, bool conversion operator is needed . If a class only possesses one useful member , and we want to assign it to a primitive-type variables outside of the class without calling any function, `bool conversion operator is need . Problem : less readability of code, not work if functions have been overloaded. Advantange : make code cleaner.","title":"Notes"},{"location":"Operators/#explicit-conversion-operator","text":"Conversion And Casting","title":"explicit Conversion Operator"},{"location":"Operators/#new-and-delete","text":"new and delete","title":"new and delete"},{"location":"Operators/#the-usage-of-the-operator","text":"Scope resolution operator( :: ): CPP ClassName::member; NamespaceName:member; EnumclassName:member; Inheritance. Member initialization list. Conditional operator (ternary operator). Label in goto statements. CPP labelName: statement; Range-based for loop with structured bindings: CPP for ( auto& var : container ); for ( auto& [var1, var2, ...] : container );","title":"The Usage of the : Operator"},{"location":"Operators/#notes_1","text":"It is important to ensure that memory is deallocated using the corresponding operator that was used for allocation to avoid undefined behavior . Using ternary operators to replace an if-else statement when initializing an object can make it slightly faster . Using nested ternary operators can be confusing, so we should avoid using them . The compiler is smart enough so that it can optimize some arithmic operations to some bitwise operations, for example, 5 x 16 to 5 << 4 .","title":"Notes"},{"location":"PairsAndTuples/","text":"Pairs ( std::pair ) Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links std::make_pair Explanation Syntax Links Template Parameters Member Types Member Objects Member functions Non-member Functions Helper Classes Helper Specializations Tuples ( std::tuple ) Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links std::make_tuple Explanation Syntax Links std::get Explanation Syntax Links Template Parameters Member Functions Non-member Functions Helper Concepts Helper Classes Helper Specializations Pairs ( std::pair ) Explanation This template class couples together a pair of values , which may be of different types ( T1 and T2 ). The individual values can be accessed through its public members first and second . Pairs are a particular case of tuple . Their header file is <utility> . Declaration Syntax std::pair< Type1, Type2 > pair_name; Initialization Syntax // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Default constructor. std::pair< Type1, Type2 > pair_name; // Copy var_name1 and var_name2. Type1 var_name1 = intializer1; Type2 var_name2 = intializer2; std::pair< Type1, Type2 > pair_name( var_name1, var_name2 ); // Parameterized constructor. Move temporary val1 and val2. std::pair< Type1, Type2 > pair_name( val1, val2 ); // Move constructor, or copy elision. std::pair< Type1, Type2 > pair_name1 = std::make_pair< Type1, Type2 >( val1, val2 ); // Copy constructor. std::pair< Type1, Type2 > pair_name2 = pair_name1; // Move constructor, or copy elision. std::pair< Type1, Type2 > pair_name1 = std::make_pair< Type1, Type2 >( val1, val2 ); // Move constructor. std::pair< Type1, Type2 > pair_name2 = std::move( pair_name1 ); Members and Related Stuffs Links std::pair in cplusplus . std::pair in cppreference . std::make_pair Explanation std::make_pair is a template function that constructs a pair object with its first element set to t and its second element set to u . The template types can be implicitly deduced from the arguments passed to make_pair . Pair objects can be constructed from other pair objects containing different types, if the respective types are implicitly convertible. Syntax Its declaration syntax. template< class T1, class T2 > std::pair< T1, T2 > make_pair( T1 t, T2 u ); // ( until C++ 11 ). Its declaration syntax. template< class T1, class T2 > std::pair< V1, V2 > make_pair( T1&& t, T2&& u ); // ( since C++ 11 ), ( constexpr since C++ 14 ). Links std::make_pair in cplusplus . std::make_pair in cppreference . Template Parameters T1 , T2 : The types of the elements that the pair stores. Member Types first_type : T1 . second_type : T2 . Member Objects first : T1 . second : T2 . Member functions (constructor): Constructs new pair (public member function). operator= : Assigns the contents (public member function). swap : swaps the contents (public member function). Non-member Functions make_pair : Creates a pair object of type, determined by the argument types (function template). operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values in the pair (function template). std::swap( std::pair ) : Specializes the std::swap algorithm (function template). get( std::pair ) : Accesses an element of a pair (function template). Helper Classes std::tuple_size< std::pair > : Obtains the size of a pair (class template specialization). std::tuple_element< std::pair > : Obtains the type of the elements of pair (class template specialization). std::basic_common_reference< std::pair > (C++23): Determines the common reference type of two pairs (class template specialization). std::common_type< std::pair > (C++23): Determines the common type of two pairs (class template specialization). std::formatter< std::pair > (C++23): Formatting support for pair (class template specialization). Helper Specializations template< class T, class U > constexpr bool enable_nonlocking_formatter_optimization< std::pair< T, U > > = enable_nonlocking_formatter_optimization< T > && enable_nonlocking_formatter_optimization< U >; (since C++23): This specialization of std::enable_nonlocking_formatter_optimization enables efficient implementation of std::print and std::println for printing a pair object when both T and U enable it. Tuples ( std::tuple ) Explanation std::tuple is a template class that can hold a collection of elements , which may be of different types . Unlike pairs, tuples can contain more than two elements. Its header file is <tuple> . Declaration Syntax std::tuple< type_para_list > tuple_name; Initialization Syntax // Aggregate Initialization. std::tuple< type_para_list > tuple_name = { ... }; // Aggregate Initialization. std::tuple< type_para_list > tuple_name{ ... }; // Default constructor. std::tuple< type_para_list > tuple_name; // Parameterized constructor. std::tuple< type_para_list > tuple_name( ... ); // Move constructor, or copy elision. std::tuple< type_para_list > tuple_name1 = std::tuple< type_para_list >( ... ); // Copy constructor. std::tuple< type_para_list > tuple_name2( tuple_name1 ); // Move constructor, or copy elision. std::tuple< type_para_list > tuple_name1 = std::tuple< type_para_list >( ... ); // Move constructor. std::tuple< type_para_list > tuple_name2( std::move( tuple_name1 ) ); // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Copy-conversion constructor. std::tuple< type_para_list > tuple_name( pair_name ); // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Move-onversion constructor. std::tuple< type_para_list > tuple_name( std::move( pair_name ) ); Members and Related Stuffs Links std::tuple in cplusplus . std::tuple in cppreference . std::make_tuple Explanation std::make_tuple is a template function that constructs an object of the appropriate tuple type to contain the elements specified in args . The type of the returned object ( tuple< VTypes... > ) is deduced from Types : For each type in Types, its decay equivalent is used in VTypes (except reference_wrapper types, for which the corresponding reference type is used instead). The function calls tuple's initialization constructor, forwarding args to it. Syntax // Its declaration syntax. template< class... Types > std::tuple< VTypes... > make_tuple( Types&&... args ); // (since C++11), (constexpr since C++14) Links std::make_tuple in cplusplus . std::make_tuple in cppreference . std::get Explanation std::get is a template function that returns a reference to the I th element of tuple t . (1-4) Extracts the I th element from the tuple. I must be an integer value in [0, sizeof...(Types)) . (5-8) Extracts the element of the tuple t whose type is T . Fails to compile unless the tuple has exactly one element of that type. Parameters t is a tuple whose contents to extract Return value. Syntax // Its declaration syntax. template< std::size_t I, class... Types > typename std::tuple_element< I, std::tuple< Types... > >::type& get( std::tuple< Types... >& t ) noexcept; // (1) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< std::size_t I, class... Types > typename std::tuple_element< I, std::tuple< Types... > >::type&& get( std::tuple< Types... >&& t ) noexcept; // (2) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< std::size_t I, class... Types > const typename std::tuple_element< I, std::tuple< Types... > >::type& get( const std::tuple< Types... >& t ) noexcept; // (3) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< std::size_t I, class... Types > const typename std::tuple_element< I, std::tuple< Types... > >::type&& get( const std::tuple< Types... >&& t ) noexcept; // (4) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< class T, class... Types > constexpr T& get( std::tuple< Types... >& t ) noexcept; // (5) (since C++14) // Its declaration syntax. template< class T, class... Types > constexpr T&& get( std::tuple< Types... >&& t ) noexcept; // (6) (since C++14) // Its declaration syntax. template< class T, class... Types > constexpr const T& get( const std::tuple< Types... >& t ) noexcept; // (7) (since C++14) // Its declaration syntax. template< class T, class... Types > constexpr const T&& get( const std::tuple< Types... >&& t ) noexcept; // (8) (since C++14) // Its usage syntax. std::cout << std::get< Index > << std::endl; std::cout << std::get< Type > << std::endl; Links std::get in cplusplus . std::get in cppreference . Template Parameters Types... : The types of the elements that the tuple stores. Empty list is supported. Member Functions (constructor): Constructs a new tuple (public member function). operator= : Assigns the contents of one tuple to another (public member function). swap : Swaps the contents of two tuples (public member function). Non-member Functions make_tuple : Creates a tuple object of the type defined by the argument types (function template). tie : Creates a tuple of lvalue references or unpacks a tuple into individual objects (function template). forward_as_tuple : Creates a tuple of forwarding references (function template). tuple_cat : Creates a tuple by concatenating any number of tuples (function template). get( std::tuple ) : Tuple accesses specified element (function template). operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values in the tuple (function template). std::swap( std::tuple ) : Specializes the std::swap algorithm (function template). Helper Concepts tuple-like (C++23), pair-like (C++23): Specifies that a type implemented the tuple protocol ( std::get , std::tuple_element , std::tuple_size ). (exposition-only concept * ) Helper Classes std::tuple_size< std::tuple > : Obtains the size of a tuple (class template specialization). std::tuple_element< std::tuple > : Obtains the type of the specified element (class template specialization). std::uses_allocator< std::tuple > : Specializes the std::uses_allocator type trait (class template specialization). std::basic_common_reference< tuple-like > (C++23): Determines the common reference type of a tuple and a tuple-like type (class template specialization). std::common_type< tuple-like > (C++23): Determines the common type of a tuple and a tuple-like type (class template specialization). std::formatter< std::tuple > (C++23): Formatting support for tuple (class template specialization). ignore : Placeholder to skip an element when unpacking a tuple using tie (constant). Helper Specializations template< class... Ts > constexpr bool enable_nonlocking_formatter_optimization< std::tuple< Ts... > > = ( enable_nonlocking_formatter_optimization< Ts > && ... ); (since C++23): This specialization of std::enable_nonlocking_formatter_optimization enables efficient implementation of std::print and std::println for printing a tuple object when each element type enables it.","title":"Pairs and Tuples"},{"location":"PairsAndTuples/#pairs-stdpair","text":"","title":"Pairs (std::pair)"},{"location":"PairsAndTuples/#explanation","text":"This template class couples together a pair of values , which may be of different types ( T1 and T2 ). The individual values can be accessed through its public members first and second . Pairs are a particular case of tuple . Their header file is <utility> .","title":"Explanation"},{"location":"PairsAndTuples/#declaration-syntax","text":"std::pair< Type1, Type2 > pair_name;","title":"Declaration Syntax"},{"location":"PairsAndTuples/#initialization-syntax","text":"// Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Default constructor. std::pair< Type1, Type2 > pair_name; // Copy var_name1 and var_name2. Type1 var_name1 = intializer1; Type2 var_name2 = intializer2; std::pair< Type1, Type2 > pair_name( var_name1, var_name2 ); // Parameterized constructor. Move temporary val1 and val2. std::pair< Type1, Type2 > pair_name( val1, val2 ); // Move constructor, or copy elision. std::pair< Type1, Type2 > pair_name1 = std::make_pair< Type1, Type2 >( val1, val2 ); // Copy constructor. std::pair< Type1, Type2 > pair_name2 = pair_name1; // Move constructor, or copy elision. std::pair< Type1, Type2 > pair_name1 = std::make_pair< Type1, Type2 >( val1, val2 ); // Move constructor. std::pair< Type1, Type2 > pair_name2 = std::move( pair_name1 );","title":"Initialization Syntax"},{"location":"PairsAndTuples/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"PairsAndTuples/#links","text":"std::pair in cplusplus . std::pair in cppreference .","title":"Links"},{"location":"PairsAndTuples/#stdmake_pair","text":"","title":"std::make_pair"},{"location":"PairsAndTuples/#explanation_1","text":"std::make_pair is a template function that constructs a pair object with its first element set to t and its second element set to u . The template types can be implicitly deduced from the arguments passed to make_pair . Pair objects can be constructed from other pair objects containing different types, if the respective types are implicitly convertible.","title":"Explanation"},{"location":"PairsAndTuples/#syntax","text":"Its declaration syntax. template< class T1, class T2 > std::pair< T1, T2 > make_pair( T1 t, T2 u ); // ( until C++ 11 ). Its declaration syntax. template< class T1, class T2 > std::pair< V1, V2 > make_pair( T1&& t, T2&& u ); // ( since C++ 11 ), ( constexpr since C++ 14 ).","title":"Syntax"},{"location":"PairsAndTuples/#links_1","text":"std::make_pair in cplusplus . std::make_pair in cppreference .","title":"Links"},{"location":"PairsAndTuples/#template-parameters","text":"T1 , T2 : The types of the elements that the pair stores.","title":"Template Parameters"},{"location":"PairsAndTuples/#member-types","text":"first_type : T1 . second_type : T2 .","title":"Member Types"},{"location":"PairsAndTuples/#member-objects","text":"first : T1 . second : T2 .","title":"Member Objects"},{"location":"PairsAndTuples/#member-functions","text":"(constructor): Constructs new pair (public member function). operator= : Assigns the contents (public member function). swap : swaps the contents (public member function).","title":"Member functions"},{"location":"PairsAndTuples/#non-member-functions","text":"make_pair : Creates a pair object of type, determined by the argument types (function template). operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values in the pair (function template). std::swap( std::pair ) : Specializes the std::swap algorithm (function template). get( std::pair ) : Accesses an element of a pair (function template).","title":"Non-member Functions"},{"location":"PairsAndTuples/#helper-classes","text":"std::tuple_size< std::pair > : Obtains the size of a pair (class template specialization). std::tuple_element< std::pair > : Obtains the type of the elements of pair (class template specialization). std::basic_common_reference< std::pair > (C++23): Determines the common reference type of two pairs (class template specialization). std::common_type< std::pair > (C++23): Determines the common type of two pairs (class template specialization). std::formatter< std::pair > (C++23): Formatting support for pair (class template specialization).","title":"Helper Classes"},{"location":"PairsAndTuples/#helper-specializations","text":"template< class T, class U > constexpr bool enable_nonlocking_formatter_optimization< std::pair< T, U > > = enable_nonlocking_formatter_optimization< T > && enable_nonlocking_formatter_optimization< U >; (since C++23): This specialization of std::enable_nonlocking_formatter_optimization enables efficient implementation of std::print and std::println for printing a pair object when both T and U enable it.","title":"Helper Specializations"},{"location":"PairsAndTuples/#tuples-stdtuple","text":"","title":"Tuples (std::tuple)"},{"location":"PairsAndTuples/#explanation_2","text":"std::tuple is a template class that can hold a collection of elements , which may be of different types . Unlike pairs, tuples can contain more than two elements. Its header file is <tuple> .","title":"Explanation"},{"location":"PairsAndTuples/#declaration-syntax_1","text":"std::tuple< type_para_list > tuple_name;","title":"Declaration Syntax"},{"location":"PairsAndTuples/#initialization-syntax_1","text":"// Aggregate Initialization. std::tuple< type_para_list > tuple_name = { ... }; // Aggregate Initialization. std::tuple< type_para_list > tuple_name{ ... }; // Default constructor. std::tuple< type_para_list > tuple_name; // Parameterized constructor. std::tuple< type_para_list > tuple_name( ... ); // Move constructor, or copy elision. std::tuple< type_para_list > tuple_name1 = std::tuple< type_para_list >( ... ); // Copy constructor. std::tuple< type_para_list > tuple_name2( tuple_name1 ); // Move constructor, or copy elision. std::tuple< type_para_list > tuple_name1 = std::tuple< type_para_list >( ... ); // Move constructor. std::tuple< type_para_list > tuple_name2( std::move( tuple_name1 ) ); // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Copy-conversion constructor. std::tuple< type_para_list > tuple_name( pair_name ); // Aggregate Initialization. std::pair< Type1, Type2 > pair_name = { val1, val2 }; // Move-onversion constructor. std::tuple< type_para_list > tuple_name( std::move( pair_name ) );","title":"Initialization Syntax"},{"location":"PairsAndTuples/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"PairsAndTuples/#links_2","text":"std::tuple in cplusplus . std::tuple in cppreference .","title":"Links"},{"location":"PairsAndTuples/#stdmake_tuple","text":"","title":"std::make_tuple"},{"location":"PairsAndTuples/#explanation_3","text":"std::make_tuple is a template function that constructs an object of the appropriate tuple type to contain the elements specified in args . The type of the returned object ( tuple< VTypes... > ) is deduced from Types : For each type in Types, its decay equivalent is used in VTypes (except reference_wrapper types, for which the corresponding reference type is used instead). The function calls tuple's initialization constructor, forwarding args to it.","title":"Explanation"},{"location":"PairsAndTuples/#syntax_1","text":"// Its declaration syntax. template< class... Types > std::tuple< VTypes... > make_tuple( Types&&... args ); // (since C++11), (constexpr since C++14)","title":"Syntax"},{"location":"PairsAndTuples/#links_3","text":"std::make_tuple in cplusplus . std::make_tuple in cppreference .","title":"Links"},{"location":"PairsAndTuples/#stdget","text":"","title":"std::get"},{"location":"PairsAndTuples/#explanation_4","text":"std::get is a template function that returns a reference to the I th element of tuple t . (1-4) Extracts the I th element from the tuple. I must be an integer value in [0, sizeof...(Types)) . (5-8) Extracts the element of the tuple t whose type is T . Fails to compile unless the tuple has exactly one element of that type. Parameters t is a tuple whose contents to extract Return value.","title":"Explanation"},{"location":"PairsAndTuples/#syntax_2","text":"// Its declaration syntax. template< std::size_t I, class... Types > typename std::tuple_element< I, std::tuple< Types... > >::type& get( std::tuple< Types... >& t ) noexcept; // (1) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< std::size_t I, class... Types > typename std::tuple_element< I, std::tuple< Types... > >::type&& get( std::tuple< Types... >&& t ) noexcept; // (2) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< std::size_t I, class... Types > const typename std::tuple_element< I, std::tuple< Types... > >::type& get( const std::tuple< Types... >& t ) noexcept; // (3) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< std::size_t I, class... Types > const typename std::tuple_element< I, std::tuple< Types... > >::type&& get( const std::tuple< Types... >&& t ) noexcept; // (4) (since C++11) // Its declaration syntax. ( constexpr since C++ 14 ) template< class T, class... Types > constexpr T& get( std::tuple< Types... >& t ) noexcept; // (5) (since C++14) // Its declaration syntax. template< class T, class... Types > constexpr T&& get( std::tuple< Types... >&& t ) noexcept; // (6) (since C++14) // Its declaration syntax. template< class T, class... Types > constexpr const T& get( const std::tuple< Types... >& t ) noexcept; // (7) (since C++14) // Its declaration syntax. template< class T, class... Types > constexpr const T&& get( const std::tuple< Types... >&& t ) noexcept; // (8) (since C++14) // Its usage syntax. std::cout << std::get< Index > << std::endl; std::cout << std::get< Type > << std::endl;","title":"Syntax"},{"location":"PairsAndTuples/#links_4","text":"std::get in cplusplus . std::get in cppreference .","title":"Links"},{"location":"PairsAndTuples/#template-parameters_1","text":"Types... : The types of the elements that the tuple stores. Empty list is supported.","title":"Template Parameters"},{"location":"PairsAndTuples/#member-functions_1","text":"(constructor): Constructs a new tuple (public member function). operator= : Assigns the contents of one tuple to another (public member function). swap : Swaps the contents of two tuples (public member function).","title":"Member Functions"},{"location":"PairsAndTuples/#non-member-functions_1","text":"make_tuple : Creates a tuple object of the type defined by the argument types (function template). tie : Creates a tuple of lvalue references or unpacks a tuple into individual objects (function template). forward_as_tuple : Creates a tuple of forwarding references (function template). tuple_cat : Creates a tuple by concatenating any number of tuples (function template). get( std::tuple ) : Tuple accesses specified element (function template). operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values in the tuple (function template). std::swap( std::tuple ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"PairsAndTuples/#helper-concepts","text":"tuple-like (C++23), pair-like (C++23): Specifies that a type implemented the tuple protocol ( std::get , std::tuple_element , std::tuple_size ). (exposition-only concept * )","title":"Helper Concepts"},{"location":"PairsAndTuples/#helper-classes_1","text":"std::tuple_size< std::tuple > : Obtains the size of a tuple (class template specialization). std::tuple_element< std::tuple > : Obtains the type of the specified element (class template specialization). std::uses_allocator< std::tuple > : Specializes the std::uses_allocator type trait (class template specialization). std::basic_common_reference< tuple-like > (C++23): Determines the common reference type of a tuple and a tuple-like type (class template specialization). std::common_type< tuple-like > (C++23): Determines the common type of a tuple and a tuple-like type (class template specialization). std::formatter< std::tuple > (C++23): Formatting support for tuple (class template specialization). ignore : Placeholder to skip an element when unpacking a tuple using tie (constant).","title":"Helper Classes"},{"location":"PairsAndTuples/#helper-specializations_1","text":"template< class... Ts > constexpr bool enable_nonlocking_formatter_optimization< std::tuple< Ts... > > = ( enable_nonlocking_formatter_optimization< Ts > && ... ); (since C++23): This specialization of std::enable_nonlocking_formatter_optimization enables efficient implementation of std::print and std::println for printing a tuple object when each element type enables it.","title":"Helper Specializations"},{"location":"SetsUnorderedSetsAndFlatSets/","text":"Sets Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::set Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Multisets Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::multiset Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Unordered Sets Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::unordered_set Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Unordered Multisets Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::unordered_multiset Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Flat Sets Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::flat_set Pointers Members and Related Stuffs Links Template Parameters Member Types Member Objects Member Functions Non-member Functions Helper classes Tags Flat Multisets Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::flat_multiset Pointers Members and Related Stuffs Links Template Parameters Member Types Member Objects Member Functions Non-member Functions Helper classes Tags Sets Explanation Sets are containers (template classes) that store unique elements following a specific order . In a set, the value of an element also identifies it ( the value is itself the key , of type Key ), and each value must be unique . The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a set are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare ). Set containers are generally slower than unordered_set containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. Sets are typically implemented as red\u2013black trees . Their header files is <set> . Declaration Syntax std::set< Type > set_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::set< Type, Compare > set_name; std::set< Type >* set_ptr; Initialization Syntax // Initializer list constructor. std::set< Type > set_name = { ... }; // Initializer list constructor. std::set< Type > set_name{ ... }; // Default constructor. Constructs an empty container. std::set< Type > set_name; // Default constructor. Constructs an empty container. std::set< Type, Compare > set_name; // Default constructor. Constructs an empty container. std::set< Type, Compare > set_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::set< Type, Compare > rset_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::set< Type, Compare > set_name( comp ); // Default constructor. Constructs an empty container. std::set< Type > set_name1; // Copy constructor. std::set< Type > set_name2( set_name1 ); // Default constructor. Constructs an empty container. std::set< Type > set_name1; // Copy constructor. std::set< Type > set_name2 = set_name1; // Default constructor. Constructs an empty container. std::set< Type > set_name1; // Move constructor. std::set< Type > set_name2( std::move( set_name1 ) ); // Initializer list constructor. std::set< Type > set_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Compare comp; std::set< Type > set_name2( set_name1.begin(), set_name1.end(), comp /* optional */ ); std::set< Type >* set_ptr = new std::set< Type >; // Default constructor. Constructs an empty container. std::set< Type > set_name; std::set< Type >* set_ptr = new std::set< Type >( set_name ); Syntax for Deleting std::set Pointers delete set_ptr; Members and Related Stuffs Links std::set in cplusplus . std::set in cppreference . Template Parameters Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the set because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . value_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17) : Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type . Member Functions (constructor): Constructs the set (public member function). (destructor): Destructs the set (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two sets (function template). std::swap( std::set ) : Specializes the std::swap algorithm (function template). erase_if( std::set ) (C++20): Erases all elements satisfying specific criteria (function template). Multisets Explanation Multisets are containers (template classes) that store elements following a specific order , and where multiple elements can have equivalent values . In a multiset, the value of an element also identifies it ( the value is itself the key , of type Key ). The value of the elements in a multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a multiset are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare ). Multiset containers are generally slower than unordered_multiset containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. Multisets are typically implemented as red\u2013black trees . Their header files is <set> . Declaration Syntax std::multiset< Type > mset_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::multiset< Type, Compare > mset_name; std::multiset< Type >* mset_ptr; Initialization Syntax // Initializer list constructor. std::multiset< Type > mset_name = { ... }; // Initializer list constructor. std::multiset< Type > mset_name{ ... }; // Default constructor. Constructs an empty container. std::multiset< Type > mset_name; // Default constructor. Constructs an empty container. std::multiset< Type, Compare > mset_name; // Default constructor. Constructs an empty container. std::multiset< Type, Compare > mset_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::multiset< Type, Compare > rmset_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::multiset< Type, Compare > mset_name( comp ); // Default constructor. Constructs an empty container. std::multiset< Type > mset_name1; // Copy constructor. std::multiset< Type > mset_name2( mset_name1 ); // Default constructor. Constructs an empty container. std::multiset< Type > mset_name1; // Copy constructor. std::multiset< Type > mset_name2 = mset_name1; // Default constructor. Constructs an empty container. std::multiset< Type > mset_name1; // Move constructor. std::multiset< Type > mset_name2( std::move( mset_name1 ) ); // Initializer list constructor. std::set< Type, Compare > mset_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Compare comp; std::set< Type, Compare > mset_name2( mset_name1.begin(), mset_name1.end(), comp /* optional */ ); std::multiset< Type >* mset_ptr = new std::multiset< Type >; // Default constructor. Constructs an empty container. std::multiset< Type > mset_name; std::multiset< Type >* mset_ptr = new std::multiset< Type >( mset_name ); Syntax for Deleting std::multiset Pointers delete mset_ptr; Members and Related Stuffs Links std::multiset in cplusplus . std::multiset in cppreference . Template Parameters Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the multiset because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . value_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node. Member Functions (constructor): Constructs the multiset (public member function). (destructor): Destructs the multiset (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two multisets (function template). std::swap( std::multiset ) : Specializes the std::swap algorithm (function template). erase_if( std::multiset ) (C++20): Erases all elements satisfying specific criteria (function template). Unordered Sets Explanation Unordered sets are containers (template classes) that store unique elements in no particular order , and which allow for fast retrieval of individual elements based on their value. In an unordered_set , the value of an element is at the same time its key , that identifies it uniquely. Keys are immutable , therefore, the elements in an unordered_set cannot be modified once in the container - they can be inserted and removed , though. Internally, the elements in the unordered_set are not sorted in any particular order , but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average ). unordered_set containers are faster than set containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements. Iterators in the container are at least forward iterators . Their header files is <unordered_set> . Declaration Syntax std::unordered_set< Type > uset_name; // Not common, not recommend struct Hash { std::size_t operator()( const Type& obj ) const { // This is only an example. return std::hash< SubType1 >()( obj._mem1 ) ^ std::hash< SubType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const Type& lhs, const Type& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_set< Type, Hash, KeyEqual > uset_name; std::unordered_set< Type >* uset_ptr; Initialization Syntax // Initializer list constructor. std::unordered_set< Type > uset_name = { ... }; // Initializer list constructor. std::unordered_set< Type > uset_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name; // Default constructor. Constructs an empty container. std::unordered_set< Type, Hash, KeyEqual > uset_name; // Constructs an empty container. Hash hash; std::unordered_set< Type, Hash, KeyEqual > uset_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_set< Type, Hash, KeyEqual > uset_name( hash, key_equal ); // Constructs an empty container. std::unordered_set< Type > uset_name( size ); // Constructs an empty container. std::unordered_set< Type, Hash, KeyEqual > uset_name( size ); // Constructs an empty container. Hash hash; std::unordered_set< Type, Hash, KeyEqual > uset_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_set< Type, Hash, KeyEqual > uset_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name1; // Copy constructor. std::unordered_set< Type > uset_name2( uset_name1 ); // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name1; // Copy constructor. std::unordered_set< Type > uset_name2 = uset_name1; // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name1; // Move constructor. std::unordered_set< Type > uset_name2( std::move( uset_name1 ) ); // Initializer list constructor. std::set< Type, Hash, KeyEqual > uset_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::set< Type, Hash, KeyEqual > uset_name2( uset_name1.begin(), uset_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_set< Type >* uset_ptr = new std::unordered_set< Type >; // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name; std::unordered_set< Type >* uset_ptr = new std::unordered_set< Type >( uset_name ); Syntax for Deleting std::unordered_set Pointers delete uset_ptr; Members and Related Stuffs Links std::unordered_set in cplusplus . std::unordered_set in cppreference . Template Parameters Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17): Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type . Member Functions (constructor): Constructs the unordered set (public member function). (destructor): Destructs the unordered set (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function). Non-member Functions operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered sets (function template). std::swap( std::unordered_set ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_set ) (C++20): Erases all elements satisfying specific criteria (function template). Unordered Multisets Explanation Unordered multisets are containers (template classes) that store elements in no particular order , allowing fast retrieval of individual elements based on their value, much like unordered_set containers, but allowing different elements to have equivalent values . In an unordered_multiset , the value of an element is at the same time its key , used to identify it. Keys are immutable , therefore, the elements in an unordered_multiset cannot be modified once in the container - they can be inserted and removed , though. Internally, the elements in the unordered_multiset are not sorted in any particular , but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average ). Elements with equivalent values are grouped together in the same bucket and in such a way that an iterator (see equal_range ) can iterate through all of them. Iterators in the container are at least forward iterators . Their header files is <unordered_set> . Declaration Syntax std::unordered_multiset< Type > umset_name; // Not common, not recommend struct Hash { std::size_t operator()( const Type& obj ) const { // This is only an example. return std::hash< SubType1 >()( obj._mem1 ) ^ std::hash< SubType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const Type& lhs, const Type& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_multiset< Type, Hash, KeyEqual > umset_name; std::unordered_multiset< Type >* umset_ptr; Initialization Syntax // Initializer list constructor. std::unordered_multiset< Type > umset_name = { ... }; // Initializer list constructor. std::unordered_multiset< Type > umset_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name; // Default constructor. Constructs an empty container. std::unordered_multiset< Type, Hash, KeyEqual > umset_name; // Constructs an empty container. Hash hash; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( hash, key_equal ); // Constructs an empty container. std::unordered_multiset< Type > umset_name( size ); // Constructs an empty container. std::unordered_multiset< Type, Hash, KeyEqual > umset_name( size ); // Constructs an empty container. Hash hash; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name1; // Copy constructor. std::unordered_multiset< Type > umset_name2( umset_name1 ); // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name1; // Copy constructor. std::unordered_multiset< Type > umset_name2 = umset_name1; // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name1; // Move constructor. std::unordered_multiset< Type > umset_name2( std::move( umset_name1 ) ); // Initializer list constructor. std::set< Type, Hash, KeyEqual > umset_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::set< Type, Hash, KeyEqual > umset_name2( umset_name1.begin(), umset_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_multiset< Type >* umset_ptr = new std::unordered_multiset< Type >; // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name; std::unordered_multiset< Type >* umset_ptr = new std::unordered_multiset< Type >( umset_name ); Syntax for Deleting std::unordered_multiset Pointers delete umset_ptr; Members and Related Stuffs Links std::unordered_multiset in cplusplus . std::unordered_multiset in cppreference . Template Parameters Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. Member Functions (constructor): Constructs the unordered multiset (public member function). (destructor): Destructs the unordered multiset (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function). Non-member Functions operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered multisets (function template). std::swap( std::unordered_multiset ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_multiset ) (C++20): Erases all elements satisfying specific criteria (function template). Flat Sets Explanation Flat sets are a container adaptor that store unique elements following a specific order . In a flat set, the value of an element also identifies it ( the value is itself the key , of type Key ), and each value must be unique . The value of the elements in a flat set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a flat_set are stored in a sorted manner using a contiguous memory structure , which allows for efficient access and iteration . flat_set containers are generally faster than set containers for accessing individual elements by their key due to their underlying array structure, but they require that elements be kept sorted upon insertion . flat_set is typically implemented as a sorted vector , allowing for efficient searching and iteration . The class template flat_set acts as a wrapper to the underlying sorted container passed as object of type KeyContainer . The header file for flat_set is <experimental/flat_set> (or may be found in other namespaces in different implementations). Declaration Syntax std::flat_set< Type > fset_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_set< Type, Compare > fset_name; // Not common, not recommend std::flat_set< Type, Compare, KeyContainer< Type > > fset_name; std::flat_set< Type >* fset_ptr; Initialization Syntax // Initializer list constructor. std::flat_set< Type > fset_name = { ... }; // Initializer list constructor. std::flat_set< Type > fset_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_set< Type > fset_name; // Default constructor. Constructs an empty container adaptor. std::flat_set< Type, Compare, KeyContainer< Type > > fset_name; // Constructs the underlying container by copying the contents of the container `cont`. // Construct a default `comp` to sort all elements. KeyContainer< Type > cont = { ... }; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( cont ); // Constructs the underlying container by copying the contents of the container `cont`. // Copy the `comp` to sort all elements. KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( cont, comp ); // Specify that all elements are unique. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Construct a default `comp` to sort all elements. std::sorted_unique_t s; KeyContainer< Type > cont = { ... }; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( s, cont ); // Specify that all elements are unique. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( s, cont, comp ); // Specify that all elements are unique. Just a tag. // Move the content of the underlying container. // Copy the content of the `comp`. std::sorted_unique_t s; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( s, KeyContainer< Type >{ ... }, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name1; // Copy constructor. std::flat_set< Type > fset_name2( fset_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name1; // Copy constructor. std::flat_set< Type > fset_name2 = fset_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name1; // Move constructor. std::flat_set< Type > fset_name2( std::move( fset_name1 ) ); // Specify that all elements are unique. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name1( s, cont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_set< Type, Compare, KeyContainer< Type > > fset_name2( s /* optional */, fset_name1.begin(), fset_name1.end(), comp /* optional */ ); std::flat_set< Type >* fset_ptr = new std::flat_set< Type >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name; std::flat_set< Type >* fset_ptr = new std::flat_set< Type >( fset_name ); Syntax for Deleting std::flat_set Pointers delete fset_ptr; Members and Related Stuffs Links std::flat_set in cplusplus . std::flat_set in cppreference . Template Parameters Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat set because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements. Member Types containre_type : KeyContainer . key_type : Key . value_type : Key . key_compare : Compare . value_compare : Compare . reference : value_type& . const_reference : const value_type& . size_type : typename KeyContainer::size_type . difference_type : typename KeyContainer::difference_type . iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Objects c ( private ): The underlying container of container_type (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ). Member Functions (constructor): Constructs the flat set (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). extract : Extracts the underlying container (public member function). replace : Replaces the underlying container (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). Non-member Functions operator== , operator<=> : Lexicographically compares the values of two flat sets (function template). std::swap( std::flat_set ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_set ) : Erases all elements satisfying specific criteria (function template). Helper classes std::uses_allocator< std::flat_set > (C++23): Specializes the std::uses_allocat or type trait (class template specialization). Tags sorted_unique , sorted_unique_t (C++23): indicates that elements of a range are sorted and unique (tag). Flat Multisets Explanation Multilat sets are a container adaptor that store elements following a specific order . In a flat multiset, the value of an element also identifies it ( the value is itself the key , of type Key ), but each value does not need to be unique . The value of the elements in a flat multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a flat_multiset are stored in a sorted manner using a contiguous memory structure , which allows for efficient access and iteration . flat_multiset containers are generally faster than set containers for accessing individual elements by their key due to their underlying array structure, but they require that elements be kept sorted upon insertion . flat_multiset is typically implemented as a sorted vector , allowing for efficient searching and iteration . The class template flat_multiset acts as a wrapper to the underlying sorted container passed as object of type KeyContainer . The header file for flat_multiset is <experimental/flat_set> (or may be found in other namespaces in different implementations). Declaration Syntax std::flat_multiset< Type > fmset_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_multiset< Type, Compare > fmset_name; // Not common, not recommend std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name; std::flat_multiset< Type >* fmset_ptr; Initialization Syntax // Initializer list constructor. std::flat_multiset< Type > fmset_name = { ... }; // Initializer list constructor. std::flat_multiset< Type > fmset_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_multiset< Type > fmset_name; // Default constructor. Constructs an empty container adaptor. std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name; // Constructs the underlying container by copying the contents of the container `cont`. // Construct a default `comp` to sort all elements. KeyContainer< Type > cont = { ... }; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( cont ); // Constructs the underlying container by copying the contents of the container `cont`. // Copy the `comp` to sort all elements. KeyContainer< Type > cont = { ... }; Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( cont, comp ); // Allow different elements with the same value. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Construct a default `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< Type > cont = { ... }; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( s, cont ); // Allow different elements with the same value. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< Type > cont = { ... }; Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( s, cont, comp ); // Allow different elements with the same value. Just a tag. // Move the content of the underlying container. // Copy the content of the `comp`. std::sorted_equivalent_t s; Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( s, KeyContainer< Type >{ ... }, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name1; // Copy constructor. std::flat_multiset< Type > fmset_name2( fmset_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name1; // Copy constructor. std::flat_multiset< Type > fmset_name2 = fmset_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name1; // Move constructor. std::flat_multiset< Type > fmset_name2( std::move( fmset_name1 ) ); // Allow different elements with the same value. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fmset_name1( s, cont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_set< Type, Compare, KeyContainer< Type > > fmset_name2( s /* optional */, fmset_name1.begin(), fmset_name1.end(), comp /* optional */ ); std::flat_multiset< Type >* fmset_ptr = new std::flat_multiset< Type >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name; std::flat_multiset< Type >* fmset_ptr = new std::flat_multiset< Type >( fmset_name ); Syntax for Deleting std::flat_multiset Pointers delete fmset_ptr; Members and Related Stuffs Links std::flat_multiset in cplusplus . std::flat_multiset in cppreference . Template Parameters Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat multiset because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements. Member Types containre_type : KeyContainer . key_type : Key . value_type : Key . key_compare : Compare . value_compare : Compare . reference : value_type& . const_reference : const value_type& . size_type : typename KeyContainer::size_type . difference_type : typename KeyContainer::difference_type . iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Objects c ( private ): The underlying container of container_type (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ). Member Functions (constructor): Constructs the flat multiset (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). extract : Extracts the underlying container (public member function). replace : Replaces the underlying container (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function). Non-member Functions operator== , operator<=> : Lexicographically compares the values of two flat multisets (function template). std::swap( std::flat_multiset ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_multiset ) : Erases all elements satisfying specific criteria (function template). Helper classes std::uses_allocator< std::flat_multiset > (C++23): Specializes the std::uses_allocat or type trait (class template specialization). Tags sorted_equivalent , sorted_equivalent_t (C++23): indicates that elements of a range are sorted and unique (tag).","title":"Sets Unordered Sets and Flat Sets"},{"location":"SetsUnorderedSetsAndFlatSets/#sets","text":"","title":"Sets"},{"location":"SetsUnorderedSetsAndFlatSets/#explanation","text":"Sets are containers (template classes) that store unique elements following a specific order . In a set, the value of an element also identifies it ( the value is itself the key , of type Key ), and each value must be unique . The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a set are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare ). Set containers are generally slower than unordered_set containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. Sets are typically implemented as red\u2013black trees . Their header files is <set> .","title":"Explanation"},{"location":"SetsUnorderedSetsAndFlatSets/#declaration-syntax","text":"std::set< Type > set_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::set< Type, Compare > set_name; std::set< Type >* set_ptr;","title":"Declaration Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#initialization-syntax","text":"// Initializer list constructor. std::set< Type > set_name = { ... }; // Initializer list constructor. std::set< Type > set_name{ ... }; // Default constructor. Constructs an empty container. std::set< Type > set_name; // Default constructor. Constructs an empty container. std::set< Type, Compare > set_name; // Default constructor. Constructs an empty container. std::set< Type, Compare > set_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::set< Type, Compare > rset_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::set< Type, Compare > set_name( comp ); // Default constructor. Constructs an empty container. std::set< Type > set_name1; // Copy constructor. std::set< Type > set_name2( set_name1 ); // Default constructor. Constructs an empty container. std::set< Type > set_name1; // Copy constructor. std::set< Type > set_name2 = set_name1; // Default constructor. Constructs an empty container. std::set< Type > set_name1; // Move constructor. std::set< Type > set_name2( std::move( set_name1 ) ); // Initializer list constructor. std::set< Type > set_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Compare comp; std::set< Type > set_name2( set_name1.begin(), set_name1.end(), comp /* optional */ ); std::set< Type >* set_ptr = new std::set< Type >; // Default constructor. Constructs an empty container. std::set< Type > set_name; std::set< Type >* set_ptr = new std::set< Type >( set_name );","title":"Initialization Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#syntax-for-deleting-stdset-pointers","text":"delete set_ptr;","title":"Syntax for Deleting std::set Pointers"},{"location":"SetsUnorderedSetsAndFlatSets/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"SetsUnorderedSetsAndFlatSets/#links","text":"std::set in cplusplus . std::set in cppreference .","title":"Links"},{"location":"SetsUnorderedSetsAndFlatSets/#template-parameters","text":"Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the set because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"SetsUnorderedSetsAndFlatSets/#member-types","text":"key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . value_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17) : Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type .","title":"Member Types"},{"location":"SetsUnorderedSetsAndFlatSets/#member-functions","text":"(constructor): Constructs the set (public member function). (destructor): Destructs the set (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function).","title":"Member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#non-member-functions","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two sets (function template). std::swap( std::set ) : Specializes the std::swap algorithm (function template). erase_if( std::set ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#multisets","text":"","title":"Multisets"},{"location":"SetsUnorderedSetsAndFlatSets/#explanation_1","text":"Multisets are containers (template classes) that store elements following a specific order , and where multiple elements can have equivalent values . In a multiset, the value of an element also identifies it ( the value is itself the key , of type Key ). The value of the elements in a multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a multiset are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare ). Multiset containers are generally slower than unordered_multiset containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order. Multisets are typically implemented as red\u2013black trees . Their header files is <set> .","title":"Explanation"},{"location":"SetsUnorderedSetsAndFlatSets/#declaration-syntax_1","text":"std::multiset< Type > mset_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::multiset< Type, Compare > mset_name; std::multiset< Type >* mset_ptr;","title":"Declaration Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#initialization-syntax_1","text":"// Initializer list constructor. std::multiset< Type > mset_name = { ... }; // Initializer list constructor. std::multiset< Type > mset_name{ ... }; // Default constructor. Constructs an empty container. std::multiset< Type > mset_name; // Default constructor. Constructs an empty container. std::multiset< Type, Compare > mset_name; // Default constructor. Constructs an empty container. std::multiset< Type, Compare > mset_name; // Copy-constructs the temporary `Compare` class object. Constructs an empty container. std::multiset< Type, Compare > rmset_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Constructs an empty container. Compare comp; std::multiset< Type, Compare > mset_name( comp ); // Default constructor. Constructs an empty container. std::multiset< Type > mset_name1; // Copy constructor. std::multiset< Type > mset_name2( mset_name1 ); // Default constructor. Constructs an empty container. std::multiset< Type > mset_name1; // Copy constructor. std::multiset< Type > mset_name2 = mset_name1; // Default constructor. Constructs an empty container. std::multiset< Type > mset_name1; // Move constructor. std::multiset< Type > mset_name2( std::move( mset_name1 ) ); // Initializer list constructor. std::set< Type, Compare > mset_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Compare comp; std::set< Type, Compare > mset_name2( mset_name1.begin(), mset_name1.end(), comp /* optional */ ); std::multiset< Type >* mset_ptr = new std::multiset< Type >; // Default constructor. Constructs an empty container. std::multiset< Type > mset_name; std::multiset< Type >* mset_ptr = new std::multiset< Type >( mset_name );","title":"Initialization Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#syntax-for-deleting-stdmultiset-pointers","text":"delete mset_ptr;","title":"Syntax for Deleting std::multiset Pointers"},{"location":"SetsUnorderedSetsAndFlatSets/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"SetsUnorderedSetsAndFlatSets/#links_1","text":"std::multiset in cplusplus . std::multiset in cppreference .","title":"Links"},{"location":"SetsUnorderedSetsAndFlatSets/#template-parameters_1","text":"Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the multiset because its default Compare is std::less< Key > , which sorts the elements in ascending order. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"SetsUnorderedSetsAndFlatSets/#member-types_1","text":"key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). key_compare : Compare . value_compare : Compare . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : Constant LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . node_type (since C++17) : A specialization of node handle representing a container node.","title":"Member Types"},{"location":"SetsUnorderedSetsAndFlatSets/#member-functions_1","text":"(constructor): Constructs the multiset (public member function). (destructor): Destructs the multiset (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function).","title":"Member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#non-member-functions_1","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two multisets (function template). std::swap( std::multiset ) : Specializes the std::swap algorithm (function template). erase_if( std::multiset ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#unordered-sets","text":"","title":"Unordered Sets"},{"location":"SetsUnorderedSetsAndFlatSets/#explanation_2","text":"Unordered sets are containers (template classes) that store unique elements in no particular order , and which allow for fast retrieval of individual elements based on their value. In an unordered_set , the value of an element is at the same time its key , that identifies it uniquely. Keys are immutable , therefore, the elements in an unordered_set cannot be modified once in the container - they can be inserted and removed , though. Internally, the elements in the unordered_set are not sorted in any particular order , but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average ). unordered_set containers are faster than set containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements. Iterators in the container are at least forward iterators . Their header files is <unordered_set> .","title":"Explanation"},{"location":"SetsUnorderedSetsAndFlatSets/#declaration-syntax_2","text":"std::unordered_set< Type > uset_name; // Not common, not recommend struct Hash { std::size_t operator()( const Type& obj ) const { // This is only an example. return std::hash< SubType1 >()( obj._mem1 ) ^ std::hash< SubType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const Type& lhs, const Type& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_set< Type, Hash, KeyEqual > uset_name; std::unordered_set< Type >* uset_ptr;","title":"Declaration Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#initialization-syntax_2","text":"// Initializer list constructor. std::unordered_set< Type > uset_name = { ... }; // Initializer list constructor. std::unordered_set< Type > uset_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name; // Default constructor. Constructs an empty container. std::unordered_set< Type, Hash, KeyEqual > uset_name; // Constructs an empty container. Hash hash; std::unordered_set< Type, Hash, KeyEqual > uset_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_set< Type, Hash, KeyEqual > uset_name( hash, key_equal ); // Constructs an empty container. std::unordered_set< Type > uset_name( size ); // Constructs an empty container. std::unordered_set< Type, Hash, KeyEqual > uset_name( size ); // Constructs an empty container. Hash hash; std::unordered_set< Type, Hash, KeyEqual > uset_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_set< Type, Hash, KeyEqual > uset_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name1; // Copy constructor. std::unordered_set< Type > uset_name2( uset_name1 ); // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name1; // Copy constructor. std::unordered_set< Type > uset_name2 = uset_name1; // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name1; // Move constructor. std::unordered_set< Type > uset_name2( std::move( uset_name1 ) ); // Initializer list constructor. std::set< Type, Hash, KeyEqual > uset_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::set< Type, Hash, KeyEqual > uset_name2( uset_name1.begin(), uset_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_set< Type >* uset_ptr = new std::unordered_set< Type >; // Default constructor. Constructs an empty container. std::unordered_set< Type > uset_name; std::unordered_set< Type >* uset_ptr = new std::unordered_set< Type >( uset_name );","title":"Initialization Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#syntax-for-deleting-stdunordered_set-pointers","text":"delete uset_ptr;","title":"Syntax for Deleting std::unordered_set Pointers"},{"location":"SetsUnorderedSetsAndFlatSets/#members-and-related-stuffs_2","text":"","title":"Members and Related Stuffs"},{"location":"SetsUnorderedSetsAndFlatSets/#links_2","text":"std::unordered_set in cplusplus . std::unordered_set in cppreference .","title":"Links"},{"location":"SetsUnorderedSetsAndFlatSets/#template-parameters_2","text":"Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"SetsUnorderedSetsAndFlatSets/#member-types_2","text":"key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node. insert_return_type (since C++17): Type describing the result of inserting a node_type , a specialization of CPP template< class Iter, class NodeType > struct /* unspecified */ { Iter position; bool inserted; NodeType node; }; instantiated with template arguments iterator and node_type .","title":"Member Types"},{"location":"SetsUnorderedSetsAndFlatSets/#member-functions_2","text":"(constructor): Constructs the unordered set (public member function). (destructor): Destructs the unordered set (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function).","title":"Member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#non-member-functions_2","text":"operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered sets (function template). std::swap( std::unordered_set ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_set ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#unordered-multisets","text":"","title":"Unordered Multisets"},{"location":"SetsUnorderedSetsAndFlatSets/#explanation_3","text":"Unordered multisets are containers (template classes) that store elements in no particular order , allowing fast retrieval of individual elements based on their value, much like unordered_set containers, but allowing different elements to have equivalent values . In an unordered_multiset , the value of an element is at the same time its key , used to identify it. Keys are immutable , therefore, the elements in an unordered_multiset cannot be modified once in the container - they can be inserted and removed , though. Internally, the elements in the unordered_multiset are not sorted in any particular , but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average ). Elements with equivalent values are grouped together in the same bucket and in such a way that an iterator (see equal_range ) can iterate through all of them. Iterators in the container are at least forward iterators . Their header files is <unordered_set> .","title":"Explanation"},{"location":"SetsUnorderedSetsAndFlatSets/#declaration-syntax_3","text":"std::unordered_multiset< Type > umset_name; // Not common, not recommend struct Hash { std::size_t operator()( const Type& obj ) const { // This is only an example. return std::hash< SubType1 >()( obj._mem1 ) ^ std::hash< SubType2 >()( obj._mem2 ); }; }; struct KeyEqual { bool operator()( const Type& lhs, const Type& rhs ) const { // This is only an example. return lhs.id == rhs.id; // Custom equality based on id only }; }; std::unordered_multiset< Type, Hash, KeyEqual > umset_name; std::unordered_multiset< Type >* umset_ptr;","title":"Declaration Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#initialization-syntax_3","text":"// Initializer list constructor. std::unordered_multiset< Type > umset_name = { ... }; // Initializer list constructor. std::unordered_multiset< Type > umset_name{ ... }; // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name; // Default constructor. Constructs an empty container. std::unordered_multiset< Type, Hash, KeyEqual > umset_name; // Constructs an empty container. Hash hash; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( hash, key_equal ); // Constructs an empty container. std::unordered_multiset< Type > umset_name( size ); // Constructs an empty container. std::unordered_multiset< Type, Hash, KeyEqual > umset_name( size ); // Constructs an empty container. Hash hash; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( size, hash ); // Constructs an empty container. Hash hash; KeyEqual key_equal; std::unordered_multiset< Type, Hash, KeyEqual > umset_name( size, hash, key_equal ); // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name1; // Copy constructor. std::unordered_multiset< Type > umset_name2( umset_name1 ); // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name1; // Copy constructor. std::unordered_multiset< Type > umset_name2 = umset_name1; // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name1; // Move constructor. std::unordered_multiset< Type > umset_name2( std::move( umset_name1 ) ); // Initializer list constructor. std::set< Type, Hash, KeyEqual > umset_name1{ ... }; // Constructs the container with the contents of the range `[first, last)`. Hash hash; KeyEqual key_equal; std::set< Type, Hash, KeyEqual > umset_name2( umset_name1.begin(), umset_name1.end(), size /* optional */, hash /* optional */, key_equal /* optional */ ); std::unordered_multiset< Type >* umset_ptr = new std::unordered_multiset< Type >; // Default constructor. Constructs an empty container. std::unordered_multiset< Type > umset_name; std::unordered_multiset< Type >* umset_ptr = new std::unordered_multiset< Type >( umset_name );","title":"Initialization Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#syntax-for-deleting-stdunordered_multiset-pointers","text":"delete umset_ptr;","title":"Syntax for Deleting std::unordered_multiset Pointers"},{"location":"SetsUnorderedSetsAndFlatSets/#members-and-related-stuffs_3","text":"","title":"Members and Related Stuffs"},{"location":"SetsUnorderedSetsAndFlatSets/#links_3","text":"std::unordered_multiset in cplusplus . std::unordered_multiset in cppreference .","title":"Links"},{"location":"SetsUnorderedSetsAndFlatSets/#template-parameters_3","text":"Key : The type of the elements. Hash : A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to std::hash< Key > . KeyEqual : A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression KeyEqual( a,b ) , where KeyEqual is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b . Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"SetsUnorderedSetsAndFlatSets/#member-types_3","text":"key_type : Key . value_type : Key . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). hasher : Hash . key_equal : KeyEqual . allocator_type : Allocator . reference : value_type& . const_reference : const value_type& . pointer : std::allocator_traits< Allocator >::pointer . const_pointer : std::allocator_traits< Allocator >::const_pointer . iterator : Constant LegacyForwardIterator to value_type . const_iterator : LegacyForwardIterator to const value_type . local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as iterator. This iterator can be used to iterate through a single bucket but not across buckets const_local_iterator : An iterator type whose category, value, difference, pointer and reference types are the same as const_iterator . This iterator can be used to iterate through a single bucket but not across buckets node_type (since C++17) : A specialization of node handle representing a container node.","title":"Member Types"},{"location":"SetsUnorderedSetsAndFlatSets/#member-functions_3","text":"(constructor): Constructs the unordered multiset (public member function). (destructor): Destructs the unordered multiset (public member function). operator= : Assigns values to the container (public member function). get_allocator : Returns the associated allocator (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). clear : Clears the contents (public member function). insert : Inserts elements or nodes(since C++17) (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). extract (C++17): Extracts nodes from the container (public member function). merge (C++17): Splices nodes from another container (public member function). count : Returns the number of elements matching specific key (public member function). find : Finds an element with specific key (public member function). contains (C++20): Checks if the container contains an element with specific key (public member function). equal_range : Returns range of elements matching a specific key (public member function). begin( size_type ) , cbegin( size_type ) : Returns an iterator to the beginning of the specified bucket (public member function). end( size_type ) , cend( size_type ) : Returns an iterator to the end of the specified bucket (public member function). bucket_count : Returns the number of buckets (public member function). max_bucket_count : Returns the maximum number of buckets (public member function). bucket_size : Returns the number of elements in specific bucket (public member function). bucket : Returns the bucket for specific key (public member function). load_factor : Returns average number of elements per bucket (public member function). max_load_factor : Manages maximum average number of elements per bucket (public member function). rehash : Reserves at least the specified number of buckets and regenerates the hash table (public member function). reserve : Reserves space for at least the specified number of elements and regenerates the hash table (public member function). hash_function : Returns function used to hash the keys (public member function). key_eq : Returns the function used to compare keys for equality (public member function).","title":"Member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#non-member-functions_3","text":"operator== , operator!= (removed in C++20): Lexicographically compares the values of two unordered multisets (function template). std::swap( std::unordered_multiset ) : Specializes the std::swap algorithm (function template). erase_if( std::unordered_multiset ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#flat-sets","text":"","title":"Flat Sets"},{"location":"SetsUnorderedSetsAndFlatSets/#explanation_4","text":"Flat sets are a container adaptor that store unique elements following a specific order . In a flat set, the value of an element also identifies it ( the value is itself the key , of type Key ), and each value must be unique . The value of the elements in a flat set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a flat_set are stored in a sorted manner using a contiguous memory structure , which allows for efficient access and iteration . flat_set containers are generally faster than set containers for accessing individual elements by their key due to their underlying array structure, but they require that elements be kept sorted upon insertion . flat_set is typically implemented as a sorted vector , allowing for efficient searching and iteration . The class template flat_set acts as a wrapper to the underlying sorted container passed as object of type KeyContainer . The header file for flat_set is <experimental/flat_set> (or may be found in other namespaces in different implementations).","title":"Explanation"},{"location":"SetsUnorderedSetsAndFlatSets/#declaration-syntax_4","text":"std::flat_set< Type > fset_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_set< Type, Compare > fset_name; // Not common, not recommend std::flat_set< Type, Compare, KeyContainer< Type > > fset_name; std::flat_set< Type >* fset_ptr;","title":"Declaration Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#initialization-syntax_4","text":"// Initializer list constructor. std::flat_set< Type > fset_name = { ... }; // Initializer list constructor. std::flat_set< Type > fset_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_set< Type > fset_name; // Default constructor. Constructs an empty container adaptor. std::flat_set< Type, Compare, KeyContainer< Type > > fset_name; // Constructs the underlying container by copying the contents of the container `cont`. // Construct a default `comp` to sort all elements. KeyContainer< Type > cont = { ... }; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( cont ); // Constructs the underlying container by copying the contents of the container `cont`. // Copy the `comp` to sort all elements. KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( cont, comp ); // Specify that all elements are unique. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Construct a default `comp` to sort all elements. std::sorted_unique_t s; KeyContainer< Type > cont = { ... }; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( s, cont ); // Specify that all elements are unique. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( s, cont, comp ); // Specify that all elements are unique. Just a tag. // Move the content of the underlying container. // Copy the content of the `comp`. std::sorted_unique_t s; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( s, KeyContainer< Type >{ ... }, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name1; // Copy constructor. std::flat_set< Type > fset_name2( fset_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name1; // Copy constructor. std::flat_set< Type > fset_name2 = fset_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name1; // Move constructor. std::flat_set< Type > fset_name2( std::move( fset_name1 ) ); // Specify that all elements are unique. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_unique_t s: KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fset_name1( s, cont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_set< Type, Compare, KeyContainer< Type > > fset_name2( s /* optional */, fset_name1.begin(), fset_name1.end(), comp /* optional */ ); std::flat_set< Type >* fset_ptr = new std::flat_set< Type >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_set< Type > fset_name; std::flat_set< Type >* fset_ptr = new std::flat_set< Type >( fset_name );","title":"Initialization Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#syntax-for-deleting-stdflat_set-pointers","text":"delete fset_ptr;","title":"Syntax for Deleting std::flat_set Pointers"},{"location":"SetsUnorderedSetsAndFlatSets/#members-and-related-stuffs_4","text":"","title":"Members and Related Stuffs"},{"location":"SetsUnorderedSetsAndFlatSets/#links_4","text":"std::flat_set in cplusplus . std::flat_set in cppreference .","title":"Links"},{"location":"SetsUnorderedSetsAndFlatSets/#template-parameters_4","text":"Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat set because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements.","title":"Template Parameters"},{"location":"SetsUnorderedSetsAndFlatSets/#member-types_4","text":"containre_type : KeyContainer . key_type : Key . value_type : Key . key_compare : Compare . value_compare : Compare . reference : value_type& . const_reference : const value_type& . size_type : typename KeyContainer::size_type . difference_type : typename KeyContainer::difference_type . iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"SetsUnorderedSetsAndFlatSets/#member-objects","text":"c ( private ): The underlying container of container_type (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ).","title":"Member Objects"},{"location":"SetsUnorderedSetsAndFlatSets/#member-functions_4","text":"(constructor): Constructs the flat set (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). extract : Extracts the underlying container (public member function). replace : Replaces the underlying container (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function).","title":"Member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#non-member-functions_4","text":"operator== , operator<=> : Lexicographically compares the values of two flat sets (function template). std::swap( std::flat_set ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_set ) : Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#helper-classes","text":"std::uses_allocator< std::flat_set > (C++23): Specializes the std::uses_allocat or type trait (class template specialization).","title":"Helper classes"},{"location":"SetsUnorderedSetsAndFlatSets/#tags","text":"sorted_unique , sorted_unique_t (C++23): indicates that elements of a range are sorted and unique (tag).","title":"Tags"},{"location":"SetsUnorderedSetsAndFlatSets/#flat-multisets","text":"","title":"Flat Multisets"},{"location":"SetsUnorderedSetsAndFlatSets/#explanation_5","text":"Multilat sets are a container adaptor that store elements following a specific order . In a flat multiset, the value of an element also identifies it ( the value is itself the key , of type Key ), but each value does not need to be unique . The value of the elements in a flat multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container. Internally, the elements in a flat_multiset are stored in a sorted manner using a contiguous memory structure , which allows for efficient access and iteration . flat_multiset containers are generally faster than set containers for accessing individual elements by their key due to their underlying array structure, but they require that elements be kept sorted upon insertion . flat_multiset is typically implemented as a sorted vector , allowing for efficient searching and iteration . The class template flat_multiset acts as a wrapper to the underlying sorted container passed as object of type KeyContainer . The header file for flat_multiset is <experimental/flat_set> (or may be found in other namespaces in different implementations).","title":"Explanation"},{"location":"SetsUnorderedSetsAndFlatSets/#declaration-syntax_5","text":"std::flat_multiset< Type > fmset_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::flat_multiset< Type, Compare > fmset_name; // Not common, not recommend std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name; std::flat_multiset< Type >* fmset_ptr;","title":"Declaration Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#initialization-syntax_5","text":"// Initializer list constructor. std::flat_multiset< Type > fmset_name = { ... }; // Initializer list constructor. std::flat_multiset< Type > fmset_name{ ... }; // Default constructor. Constructs an empty container adaptor. std::flat_multiset< Type > fmset_name; // Default constructor. Constructs an empty container adaptor. std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name; // Constructs the underlying container by copying the contents of the container `cont`. // Construct a default `comp` to sort all elements. KeyContainer< Type > cont = { ... }; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( cont ); // Constructs the underlying container by copying the contents of the container `cont`. // Copy the `comp` to sort all elements. KeyContainer< Type > cont = { ... }; Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( cont, comp ); // Allow different elements with the same value. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Construct a default `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< Type > cont = { ... }; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( s, cont ); // Allow different elements with the same value. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< Type > cont = { ... }; Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( s, cont, comp ); // Allow different elements with the same value. Just a tag. // Move the content of the underlying container. // Copy the content of the `comp`. std::sorted_equivalent_t s; Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( s, KeyContainer< Type >{ ... }, comp ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::flat_multiset< Type, Compare, KeyContainer< Type > > fmset_name( comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name1; // Copy constructor. std::flat_multiset< Type > fmset_name2( fmset_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name1; // Copy constructor. std::flat_multiset< Type > fmset_name2 = fmset_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name1; // Move constructor. std::flat_multiset< Type > fmset_name2( std::move( fmset_name1 ) ); // Allow different elements with the same value. Just a tag. // Constructs the underlying container by `std::move( cont )`. // Copy the `comp` to sort all elements. std::sorted_equivalent_t s; KeyContainer< Type > cont = { ... }; Compare comp; std::flat_set< Type, Compare, KeyContainer< Type > > fmset_name1( s, cont, comp ); // Constructs the container with the contents of the range `[first, last)`. std::flat_set< Type, Compare, KeyContainer< Type > > fmset_name2( s /* optional */, fmset_name1.begin(), fmset_name1.end(), comp /* optional */ ); std::flat_multiset< Type >* fmset_ptr = new std::flat_multiset< Type >; // Default constructor. Value-initializes the comparator and the underlying container. std::flat_multiset< Type > fmset_name; std::flat_multiset< Type >* fmset_ptr = new std::flat_multiset< Type >( fmset_name );","title":"Initialization Syntax"},{"location":"SetsUnorderedSetsAndFlatSets/#syntax-for-deleting-stdflat_multiset-pointers","text":"delete fmset_ptr;","title":"Syntax for Deleting std::flat_multiset Pointers"},{"location":"SetsUnorderedSetsAndFlatSets/#members-and-related-stuffs_5","text":"","title":"Members and Related Stuffs"},{"location":"SetsUnorderedSetsAndFlatSets/#links_5","text":"std::flat_multiset in cplusplus . std::flat_multiset in cppreference .","title":"Links"},{"location":"SetsUnorderedSetsAndFlatSets/#template-parameters_5","text":"Key : The type of the elements. Compare : A Compare type providing a strict weak ordering. By default, the first key (smallest key) is at the beginning of the flat multiset because its default Compare is std::less< Key > , which sorts the elements in ascending order. KeyContainer : The type of the underlying SequenceContainer to store the elements. The iterators of such container should satisfy LegacyRandomAccessIterator or model random_access_iterator . The standard containers std::vector and std::deque satisfy these requirements.","title":"Template Parameters"},{"location":"SetsUnorderedSetsAndFlatSets/#member-types_5","text":"containre_type : KeyContainer . key_type : Key . value_type : Key . key_compare : Compare . value_compare : Compare . reference : value_type& . const_reference : const value_type& . size_type : typename KeyContainer::size_type . difference_type : typename KeyContainer::difference_type . iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to value_type . const_iterator : Implementation-defined LegacyRandomAccessIterator and random_access_iterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"SetsUnorderedSetsAndFlatSets/#member-objects_1","text":"c ( private ): The underlying container of container_type (exposition-only member object * ). compare ( private ): The comparison function object of type key_compare (exposition-only member object * ).","title":"Member Objects"},{"location":"SetsUnorderedSetsAndFlatSets/#member-functions_5","text":"(constructor): Constructs the flat multiset (public member function). (destructor) (implicitly declared): Destroys every element of the container adaptor (public member function). operator= : Assigns values to the container adaptor (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). emplace : Constructs elements in-place (public member function). emplace_hint : Constructs elements in-place using a hint (public member function). insert : Inserts elements (public member function). insert_range : Inserts a range of elements (public member function). extract : Extracts the underlying container (public member function). replace : Replaces the underlying container (public member function). erase : Erases elements and returns a valid iterator (public member function). swap : Swaps the contents (public member function). clear : Clears the contents (public member function). find : Finds an element with specific key (public member function). count : Returns the number of elements matching specific key (public member function). contains : Checks if the container contains an element with specific key (public member function). lower_bound : Returns an iterator to the first element not less than the given key (public member function). upper_bound : Returns an iterator to the first element greater than the given key (public member function). equal_range : Returns range of elements matching a specific key (public member function). key_comp : Returns the function that compares keys (public member function). value_comp : Returns the function that compares keys in objects of type value_type (public member function).","title":"Member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#non-member-functions_5","text":"operator== , operator<=> : Lexicographically compares the values of two flat multisets (function template). std::swap( std::flat_multiset ) : Specializes the std::swap algorithm (function template). erase_if( std::flat_multiset ) : Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"SetsUnorderedSetsAndFlatSets/#helper-classes_1","text":"std::uses_allocator< std::flat_multiset > (C++23): Specializes the std::uses_allocat or type trait (class template specialization).","title":"Helper classes"},{"location":"SetsUnorderedSetsAndFlatSets/#tags_1","text":"sorted_equivalent , sorted_equivalent_t (C++23): indicates that elements of a range are sorted and unique (tag).","title":"Tags"},{"location":"SmartPointers/","text":"Smart Pointers (Scoped Pointers) Explanation Unique Pointers ( std::unique_ptr ) Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links Member Types Member Functions Non-member Functions Helper Classes Shared Pointers ( std::shared_ptr ) Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links Member Types Member Functions Non-member Functions Helper Classes Weak Pointers ( std::weak_ptr ) Explanation Declaration Syntax Initialization Syntax Circular References Explanation Examples Members and Related Stuffs Links Member Types Member Functions Non-member Functions Helper Classes Smart Pointers (Scoped Pointers) Explanation Smart pointers are wrapper classes (template classes) about a real raw pointer that manage dynamically allocated memory , ensuring that resources are properly released when no longer needed. They provide automatic memory management , reducing the risk of memory leaks and dangling pointers . The C++ Standard Library provides three primary types of smart pointers : std::unique_ptr , std::shared_ptr , and std::weak_ptr . All smart pointers are scoped pointers . When they leave their scope , they either cease to exist or decrease their reference count . When designing our own data structure , useing a raw pointer instead . In smart pointers, the pointer operator (or arrow operator, -> ) has been overloaded. Since the compiler optimizes pointer operator overloading, obj_ptr->_mem and (*obj_ptr)._mem are equivalent to (obj_ptr)->->_mem and (*obj_ptr)->_mem . Additionally, the pointer operator can be overloaded to obtain the memory offsets of an object's members . Their header file is <memory> . Unique Pointers ( std::unique_ptr ) Explanation std::unique_ptr is a smart pointer that provides exclusive ownership of a resource . Only one std::unique_ptr can own a resource at a time, and its copy-assignment operator is deleted to avoid mistakes, so it cannot be copied . However, it can be moved to transfer ownership . When a std::unique_ptr goes out of scope , the resource is automatically deleted . It creates an object on the heap and automatically deletes it when it goes out of scope, without needing to use delete . Since it is created on the stack , there is no overhead. Declaration Syntax std::unique_ptr< Type > uptr; Initialization Syntax std::unique_ptr< Type > uptr( new Type( ... ) ); // Common. Recommend. std::unique_ptr< Type > uptr = std::make_unique< Type >( /* constructor arguments */ ); std::unique_ptr< Type > uptr1 = std::make_unique< Type >( /* constructor arguments */ ); // Move constructor. std::unique_ptr< Type > uptr2( std::move( uptr1 ) ); // Optionally set uptr1 to nullptr for clarity. uptr1 = nullptr; // Constructs a `std::unique_ptr` which owns `rptr`, initializing the stored pointer with `rptr`. Type* rptr = new Type( ... ); std::unique_ptr< Type > uptr( rptr ); // Optionall set rptr to nullptr to indicate it no longer points to a valid object. rptr = nullptr; Members and Related Stuffs Links std::unique_ptr in cplusplus . std::unique_ptr in cppreference . Member Types pointer : std::remove_reference< Deleter >::type::pointer if that type exists, otherwise T* . Must satisfy NullablePointer . element_type : T , the type of the object managed by this unique_ptr . deleter_type : Deleter , the function object or lvalue reference to function or to function object, to be called from the destructor. Member Functions (constructor): Constructs a new unique_ptr (public member function). (destructor): Destructs the managed object if such is present (public member function). operator= : Assigns the unique_ptr (public member function). release : Returns a pointer to the managed object and releases the ownership (public member function). reset : Replaces the managed object (public member function). swap : Swaps the managed objects (public member function). get : Returns a pointer to the managed object (public member function). get_deleter : Returns the deleter that is used for destruction of the managed object (public member function). operator bool : Checks if there is an associated managed object (public member function). operator* , operator-> : Dereferences pointer to the managed object (public member function). operator[] : Provides indexed access to the managed array (public member function). Non-member Functions make_unique (C++14), make_unique_for_overwrite (C++20): Creates a unique pointer that manages a new object (function template). operator!= (removed in C++20), operator==/<!--<=/-->/>=/<=> (C++20): Compares to another unique_ptr or with nullptr (function template). operator<<( std::unique_ptr ) (C++20): Outputs the value of the managed pointer to an output stream (function template). std::swap( std::unique_ptr ) : Specializes the std::swap algorithm (function template). Helper Classes std::hash< std::unique_ptr > : Hash support for std::unique_ptr (class template specialization). Shared Pointers ( std::shared_ptr ) Explanation std::shared_ptr is a type of smart pointer that enables multiple instances of std::shared_ptr to collectively manage the ownership of a resource. The implementation of std::shared_ptr is contingent upon the specific compiler and standard library employed. Most systems implement this functionality using reference counting. Reference counting maintains a record of the number of references pointing to a shared pointer: Each time a new reference is established, the reference count is incremented by one . ( Constructors ) Conversely, each time a reference is removed , the count is decremented by one . When the reference count is reduced to zero , the associated shared pointer is automatically deallocated . ( Destructors ) This reference counting mechanism introduces a degree of overhead . Notably, assigning one std::shared_ptr to another results in an increase in the reference count, while assigning a std::shared_ptr to a std::weak_ptr does not affect the reference count . Declaration Syntax std::shared_ptr< Type > sptr; Initialization Syntax // Not recommended. The reference count and the object will be constructed separately. std::shared_ptr< Type > sptr( new Type( ... ) ); // Recommended. The reference count and the object will be constructed together, which is more efficient. std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); // Recommended. The reference count and the object will be constructed together, which is more efficient. std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); // Copy constructor, the reference count is increased by one. std::shared_ptr< Type > sptr2 = sptr1; // Recommended. The reference count and the object will be constructed together, which is more efficient. std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); // Move constructors. std::shared_ptr< Type > sptr2 = std::move( sptr1 ); // Optionally set sptr1 to nullptr for clarity. sptr1 = nullptr; // Constructs a `std::shared_ptr` which owns `rptr`, initializing the stored pointer with `rptr`. Type* rptr = new Type( ... ); std::shared_ptr< Type > sptr( rptr ); // Optionall set rptr to nullptr to indicate it no longer points to a valid object. rptr = nullptr; // Constructs a `std::shared_ptr` which owns `uptr`, initializing the stored pointer with `uptr`. std::unique_ptr< Type > uptr = std::make_unique< Type >( /* constructor arguments */ ); std::shared_ptr< Type > sptr = std::move( uptr ); // Optionally set uptr to nullptr for clarity. uptr = nullptr; Members and Related Stuffs Links std::shared_ptr in cplusplus . std::shared_ptr in cppreference . Member Types element_type : T (until C++17), std::remove_extent_t< T > . (since C++17) weak_type (since C++17): std::weak_ptr< T > . Member Functions (constructor): Constructs new shared_ptr (public member function). (destructor): Destructs the owned object if no more shared_ptrs link to it (public member function). operator= : Assigns the shared_ptr (public member function). reset : Replaces the managed object (public member function). swap : Swaps the managed objects (public member function). get : Returns the stored pointer (public member function). operator* , operator-> : Dereferences the stored pointer (public member function). operator[] (C++17): Provides indexed access to the stored array (public member function). use_count : Returns the number of shared_ptr objects referring to the same managed object (public member function). unique (until C++20): Checks whether the managed object is managed only by the current shared_ptr object (public member function). operator bool : Checks if the stored pointer is not null (public member function). owner_before : Provides owner-based ordering of shared pointers (public member function). owner_hash (C++26): Provides owner-based hashing of shared pointers (public member function). owner_equal (C++26): provides owner-based equal comparison of shared pointers (public member function). Non-member Functions make_shared (C++20), make_shared_for_overwrite (C++20): Creates a shared pointer that manages a new object (function template). allocate_shared (C++20), allocate_shared_for_overwrite (C++20): Creates a shared pointer that manages a new object allocated using an allocator (function template). static_pointer_cast (C++17), dynamic_pointer_cast (C++17), const_pointer_cast (C++17), reinterpret_pointer_cast (C++17): Applies static_cast , dynamic_cast , const_cast , or reinterpret_cast to the stored pointer (function template). get_deleter : returns the deleter of specified type, if owned (function template). operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Compares with another shared_ptr or with nullptr (function template). operator<<( std::shared_ptr ) : Outputs the value of the stored pointer to an output stream (function template). std::swap( std::shared_ptr ) : Specializes the std::swap algorithm (function template). std::atomic_is_lock_free( std::shared_ptr ) , std::atomic_load( std::shared_ptr ) , std::atomic_load_explicit( std::shared_ptr ) , std::atomic_store( std::shared_ptr ) , std::atomic_store_explicit( std::shared_ptr ) , std::atomic_exchange( std::shared_ptr ) , std::atomic_exchange_explicit( std::shared_ptr ) , std::atomic_compare_exchange_weak( std::shared_ptr ) , std::atomic_compare_exchange_strong( std::shared_ptr ) , std::atomic_compare_exchange_weak_explicit( std::shared_ptr ) , std::atomic_compare_exchange_strong_explicit( std::shared_ptr ) : (deprecated in C++20) (removed in C++26) Specializes atomic operations for std::shared_ptr (function template). Helper Classes std::atomic< std::shared_ptr > (C++20): Atomic shared pointer (class template specialization). std::hash< std::shared_ptr > : Hash support for std::shared_ptr (class template specialization). Weak Pointers ( std::weak_ptr ) Explanation std::weak_ptr is a variant of shared pointer that does not maintain a reference count . It does not take ownership of the managed object but allows tracking of an object managed by std::shared_ptr without affecting the reference count. This feature is particularly useful for avoiding circular references and ensuring that memory is not deallocated . Since std::weak_ptr does not increment the reference count of the resource, it does not influence the resource's lifetime . To access the managed resource , a std::weak_ptr must be converted to a std::shared_ptr using the lock() method . Assigning a shared pointer to a raw pointer can lead to several issues after the shared pointer has been released, particularly in a multithreaded context where a raw pointer may be deleted multiple times . In contrast, std::weak_ptr provides a solution to these problems. If two objects reference one another , at least one of the references must be a weak pointer to prevent circular dependencies . Although std::weak_ptr does not maintain the resources's lifetime, the best practice is calling reset() if we do not need a std::weak_ptr . Declaration Syntax std::weak_ptr< Type > wptr; Initialization Syntax std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr; std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr1 = sptr; // Copy constructor. std::weak_ptr< Type > wptr2 = wptr1; std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr1 = sptr; // Move constructor. std::weak_ptr< Type > wptr2 = std::move( wptr1 ); std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr; wptr.reset(); std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr1; auto sptr2 = wptr.lock(); if( sptr2 ) { ...; } else { ...; }; std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr1; // C++17. if( auto sptr2 = wptr.lock(); ) { ...; } else { ...; }; Circular References Explanation A circular reference occurs when two or more objects reference each other in a way that creates a cycle . This happens when Object A holds a reference to Object B, and Object B holds a reference back to Object A (or when a longer chain of objects reference each other in a loop). This can cause memory leaks or infinite loops . The best approach is to use a weak_ptr for references between objects. Examples // Circular references occur. #include <iostream> #include <memory> struct Node { std::shared_ptr< Node > next; ~Node() { std::cout << \"Node destroyed\\n\"; }; }; int main() { auto nodeA = std::make_shared< Node >(); auto nodeB = std::make_shared< Node >(); std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; nodeA->next = nodeB; // nodeB.use_count() + 1; nodeB->next = nodeA; // nodeA.use_count() + 1; Creates a circular reference std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; // Both nodes will never be deleted due to circular reference return 0; }; // Circular references do not occur. #include <iostream> #include <memory> struct Node { std::weak_ptr< Node > next; ~Node() { std::cout << \"Node destroyed\\n\"; }; }; int main() { auto nodeA = std::make_shared< Node >(); auto nodeB = std::make_shared< Node >(); std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; nodeA->next = nodeB; nodeB->next = nodeA; std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; // Both nodes will be deleted. return 0; }; Members and Related Stuffs Links std::weak_ptr in cplusplus . std::weak_ptr in cppreference . Member Types element_type : T (until C++17), std::remove_extent_t< T > (since C++17). Member Functions (constructor): Creates a new weak_ptr (public member function). (destructor): Destroys a weak_ptr (public member function). operator= : Assigns the weak_ptr (public member function). reset : Releases the ownership of the managed object (public member function). swap : Swaps the managed objects (public member function). use_count : Returns the number of shared_ptr objects that manage the object (public member function). expired : Checks whether the referenced object was already deleted (public member function). lock : Creates a shared_ptr that manages the referenced object (public member function). owner_before : Provides owner-based ordering of weak pointers (public member function). owner_hash (C++26): Provides owner-based hashing of weak pointers (public member function). owner_equal (C++26): Provides owner-based equal comparison of weak pointers (public member function). Non-member Functions std::swap( std::weak_ptr ) : Specializes the std::swap algorithm (function template). Helper Classes std::atomic< std::weak_ptr > (C++20): Atomic weak pointer(class template specialization).","title":"Smart Pointers"},{"location":"SmartPointers/#smart-pointers-scoped-pointers","text":"","title":"Smart Pointers (Scoped Pointers)"},{"location":"SmartPointers/#explanation","text":"Smart pointers are wrapper classes (template classes) about a real raw pointer that manage dynamically allocated memory , ensuring that resources are properly released when no longer needed. They provide automatic memory management , reducing the risk of memory leaks and dangling pointers . The C++ Standard Library provides three primary types of smart pointers : std::unique_ptr , std::shared_ptr , and std::weak_ptr . All smart pointers are scoped pointers . When they leave their scope , they either cease to exist or decrease their reference count . When designing our own data structure , useing a raw pointer instead . In smart pointers, the pointer operator (or arrow operator, -> ) has been overloaded. Since the compiler optimizes pointer operator overloading, obj_ptr->_mem and (*obj_ptr)._mem are equivalent to (obj_ptr)->->_mem and (*obj_ptr)->_mem . Additionally, the pointer operator can be overloaded to obtain the memory offsets of an object's members . Their header file is <memory> .","title":"Explanation"},{"location":"SmartPointers/#unique-pointers-stdunique_ptr","text":"","title":"Unique Pointers (std::unique_ptr)"},{"location":"SmartPointers/#explanation_1","text":"std::unique_ptr is a smart pointer that provides exclusive ownership of a resource . Only one std::unique_ptr can own a resource at a time, and its copy-assignment operator is deleted to avoid mistakes, so it cannot be copied . However, it can be moved to transfer ownership . When a std::unique_ptr goes out of scope , the resource is automatically deleted . It creates an object on the heap and automatically deletes it when it goes out of scope, without needing to use delete . Since it is created on the stack , there is no overhead.","title":"Explanation"},{"location":"SmartPointers/#declaration-syntax","text":"std::unique_ptr< Type > uptr;","title":"Declaration Syntax"},{"location":"SmartPointers/#initialization-syntax","text":"std::unique_ptr< Type > uptr( new Type( ... ) ); // Common. Recommend. std::unique_ptr< Type > uptr = std::make_unique< Type >( /* constructor arguments */ ); std::unique_ptr< Type > uptr1 = std::make_unique< Type >( /* constructor arguments */ ); // Move constructor. std::unique_ptr< Type > uptr2( std::move( uptr1 ) ); // Optionally set uptr1 to nullptr for clarity. uptr1 = nullptr; // Constructs a `std::unique_ptr` which owns `rptr`, initializing the stored pointer with `rptr`. Type* rptr = new Type( ... ); std::unique_ptr< Type > uptr( rptr ); // Optionall set rptr to nullptr to indicate it no longer points to a valid object. rptr = nullptr;","title":"Initialization Syntax"},{"location":"SmartPointers/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"SmartPointers/#links","text":"std::unique_ptr in cplusplus . std::unique_ptr in cppreference .","title":"Links"},{"location":"SmartPointers/#member-types","text":"pointer : std::remove_reference< Deleter >::type::pointer if that type exists, otherwise T* . Must satisfy NullablePointer . element_type : T , the type of the object managed by this unique_ptr . deleter_type : Deleter , the function object or lvalue reference to function or to function object, to be called from the destructor.","title":"Member Types"},{"location":"SmartPointers/#member-functions","text":"(constructor): Constructs a new unique_ptr (public member function). (destructor): Destructs the managed object if such is present (public member function). operator= : Assigns the unique_ptr (public member function). release : Returns a pointer to the managed object and releases the ownership (public member function). reset : Replaces the managed object (public member function). swap : Swaps the managed objects (public member function). get : Returns a pointer to the managed object (public member function). get_deleter : Returns the deleter that is used for destruction of the managed object (public member function). operator bool : Checks if there is an associated managed object (public member function). operator* , operator-> : Dereferences pointer to the managed object (public member function). operator[] : Provides indexed access to the managed array (public member function).","title":"Member Functions"},{"location":"SmartPointers/#non-member-functions","text":"make_unique (C++14), make_unique_for_overwrite (C++20): Creates a unique pointer that manages a new object (function template). operator!= (removed in C++20), operator==/<!--<=/-->/>=/<=> (C++20): Compares to another unique_ptr or with nullptr (function template). operator<<( std::unique_ptr ) (C++20): Outputs the value of the managed pointer to an output stream (function template). std::swap( std::unique_ptr ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"SmartPointers/#helper-classes","text":"std::hash< std::unique_ptr > : Hash support for std::unique_ptr (class template specialization).","title":"Helper Classes"},{"location":"SmartPointers/#shared-pointers-stdshared_ptr","text":"","title":"Shared Pointers (std::shared_ptr)"},{"location":"SmartPointers/#explanation_2","text":"std::shared_ptr is a type of smart pointer that enables multiple instances of std::shared_ptr to collectively manage the ownership of a resource. The implementation of std::shared_ptr is contingent upon the specific compiler and standard library employed. Most systems implement this functionality using reference counting. Reference counting maintains a record of the number of references pointing to a shared pointer: Each time a new reference is established, the reference count is incremented by one . ( Constructors ) Conversely, each time a reference is removed , the count is decremented by one . When the reference count is reduced to zero , the associated shared pointer is automatically deallocated . ( Destructors ) This reference counting mechanism introduces a degree of overhead . Notably, assigning one std::shared_ptr to another results in an increase in the reference count, while assigning a std::shared_ptr to a std::weak_ptr does not affect the reference count .","title":"Explanation"},{"location":"SmartPointers/#declaration-syntax_1","text":"std::shared_ptr< Type > sptr;","title":"Declaration Syntax"},{"location":"SmartPointers/#initialization-syntax_1","text":"// Not recommended. The reference count and the object will be constructed separately. std::shared_ptr< Type > sptr( new Type( ... ) ); // Recommended. The reference count and the object will be constructed together, which is more efficient. std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); // Recommended. The reference count and the object will be constructed together, which is more efficient. std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); // Copy constructor, the reference count is increased by one. std::shared_ptr< Type > sptr2 = sptr1; // Recommended. The reference count and the object will be constructed together, which is more efficient. std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); // Move constructors. std::shared_ptr< Type > sptr2 = std::move( sptr1 ); // Optionally set sptr1 to nullptr for clarity. sptr1 = nullptr; // Constructs a `std::shared_ptr` which owns `rptr`, initializing the stored pointer with `rptr`. Type* rptr = new Type( ... ); std::shared_ptr< Type > sptr( rptr ); // Optionall set rptr to nullptr to indicate it no longer points to a valid object. rptr = nullptr; // Constructs a `std::shared_ptr` which owns `uptr`, initializing the stored pointer with `uptr`. std::unique_ptr< Type > uptr = std::make_unique< Type >( /* constructor arguments */ ); std::shared_ptr< Type > sptr = std::move( uptr ); // Optionally set uptr to nullptr for clarity. uptr = nullptr;","title":"Initialization Syntax"},{"location":"SmartPointers/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"SmartPointers/#links_1","text":"std::shared_ptr in cplusplus . std::shared_ptr in cppreference .","title":"Links"},{"location":"SmartPointers/#member-types_1","text":"element_type : T (until C++17), std::remove_extent_t< T > . (since C++17) weak_type (since C++17): std::weak_ptr< T > .","title":"Member Types"},{"location":"SmartPointers/#member-functions_1","text":"(constructor): Constructs new shared_ptr (public member function). (destructor): Destructs the owned object if no more shared_ptrs link to it (public member function). operator= : Assigns the shared_ptr (public member function). reset : Replaces the managed object (public member function). swap : Swaps the managed objects (public member function). get : Returns the stored pointer (public member function). operator* , operator-> : Dereferences the stored pointer (public member function). operator[] (C++17): Provides indexed access to the stored array (public member function). use_count : Returns the number of shared_ptr objects referring to the same managed object (public member function). unique (until C++20): Checks whether the managed object is managed only by the current shared_ptr object (public member function). operator bool : Checks if the stored pointer is not null (public member function). owner_before : Provides owner-based ordering of shared pointers (public member function). owner_hash (C++26): Provides owner-based hashing of shared pointers (public member function). owner_equal (C++26): provides owner-based equal comparison of shared pointers (public member function).","title":"Member Functions"},{"location":"SmartPointers/#non-member-functions_1","text":"make_shared (C++20), make_shared_for_overwrite (C++20): Creates a shared pointer that manages a new object (function template). allocate_shared (C++20), allocate_shared_for_overwrite (C++20): Creates a shared pointer that manages a new object allocated using an allocator (function template). static_pointer_cast (C++17), dynamic_pointer_cast (C++17), const_pointer_cast (C++17), reinterpret_pointer_cast (C++17): Applies static_cast , dynamic_cast , const_cast , or reinterpret_cast to the stored pointer (function template). get_deleter : returns the deleter of specified type, if owned (function template). operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Compares with another shared_ptr or with nullptr (function template). operator<<( std::shared_ptr ) : Outputs the value of the stored pointer to an output stream (function template). std::swap( std::shared_ptr ) : Specializes the std::swap algorithm (function template). std::atomic_is_lock_free( std::shared_ptr ) , std::atomic_load( std::shared_ptr ) , std::atomic_load_explicit( std::shared_ptr ) , std::atomic_store( std::shared_ptr ) , std::atomic_store_explicit( std::shared_ptr ) , std::atomic_exchange( std::shared_ptr ) , std::atomic_exchange_explicit( std::shared_ptr ) , std::atomic_compare_exchange_weak( std::shared_ptr ) , std::atomic_compare_exchange_strong( std::shared_ptr ) , std::atomic_compare_exchange_weak_explicit( std::shared_ptr ) , std::atomic_compare_exchange_strong_explicit( std::shared_ptr ) : (deprecated in C++20) (removed in C++26) Specializes atomic operations for std::shared_ptr (function template).","title":"Non-member Functions"},{"location":"SmartPointers/#helper-classes_1","text":"std::atomic< std::shared_ptr > (C++20): Atomic shared pointer (class template specialization). std::hash< std::shared_ptr > : Hash support for std::shared_ptr (class template specialization).","title":"Helper Classes"},{"location":"SmartPointers/#weak-pointers-stdweak_ptr","text":"","title":"Weak Pointers (std::weak_ptr)"},{"location":"SmartPointers/#explanation_3","text":"std::weak_ptr is a variant of shared pointer that does not maintain a reference count . It does not take ownership of the managed object but allows tracking of an object managed by std::shared_ptr without affecting the reference count. This feature is particularly useful for avoiding circular references and ensuring that memory is not deallocated . Since std::weak_ptr does not increment the reference count of the resource, it does not influence the resource's lifetime . To access the managed resource , a std::weak_ptr must be converted to a std::shared_ptr using the lock() method . Assigning a shared pointer to a raw pointer can lead to several issues after the shared pointer has been released, particularly in a multithreaded context where a raw pointer may be deleted multiple times . In contrast, std::weak_ptr provides a solution to these problems. If two objects reference one another , at least one of the references must be a weak pointer to prevent circular dependencies . Although std::weak_ptr does not maintain the resources's lifetime, the best practice is calling reset() if we do not need a std::weak_ptr .","title":"Explanation"},{"location":"SmartPointers/#declaration-syntax_2","text":"std::weak_ptr< Type > wptr;","title":"Declaration Syntax"},{"location":"SmartPointers/#initialization-syntax_2","text":"std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr; std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr1 = sptr; // Copy constructor. std::weak_ptr< Type > wptr2 = wptr1; std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr1 = sptr; // Move constructor. std::weak_ptr< Type > wptr2 = std::move( wptr1 ); std::shared_ptr< Type > sptr = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr; wptr.reset(); std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr1; auto sptr2 = wptr.lock(); if( sptr2 ) { ...; } else { ...; }; std::shared_ptr< Type > sptr1 = std::make_shared< Type >( /* constructor arguments */ ); std::weak_ptr< Type > wptr = sptr1; // C++17. if( auto sptr2 = wptr.lock(); ) { ...; } else { ...; };","title":"Initialization Syntax"},{"location":"SmartPointers/#circular-references","text":"","title":"Circular References"},{"location":"SmartPointers/#explanation_4","text":"A circular reference occurs when two or more objects reference each other in a way that creates a cycle . This happens when Object A holds a reference to Object B, and Object B holds a reference back to Object A (or when a longer chain of objects reference each other in a loop). This can cause memory leaks or infinite loops . The best approach is to use a weak_ptr for references between objects.","title":"Explanation"},{"location":"SmartPointers/#examples","text":"// Circular references occur. #include <iostream> #include <memory> struct Node { std::shared_ptr< Node > next; ~Node() { std::cout << \"Node destroyed\\n\"; }; }; int main() { auto nodeA = std::make_shared< Node >(); auto nodeB = std::make_shared< Node >(); std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; nodeA->next = nodeB; // nodeB.use_count() + 1; nodeB->next = nodeA; // nodeA.use_count() + 1; Creates a circular reference std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; // Both nodes will never be deleted due to circular reference return 0; }; // Circular references do not occur. #include <iostream> #include <memory> struct Node { std::weak_ptr< Node > next; ~Node() { std::cout << \"Node destroyed\\n\"; }; }; int main() { auto nodeA = std::make_shared< Node >(); auto nodeB = std::make_shared< Node >(); std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; nodeA->next = nodeB; nodeB->next = nodeA; std::cout << nodeA.use_count() << std::endl; std::cout << nodeB.use_count() << std::endl; // Both nodes will be deleted. return 0; };","title":"Examples"},{"location":"SmartPointers/#members-and-related-stuffs_2","text":"","title":"Members and Related Stuffs"},{"location":"SmartPointers/#links_2","text":"std::weak_ptr in cplusplus . std::weak_ptr in cppreference .","title":"Links"},{"location":"SmartPointers/#member-types_2","text":"element_type : T (until C++17), std::remove_extent_t< T > (since C++17).","title":"Member Types"},{"location":"SmartPointers/#member-functions_2","text":"(constructor): Creates a new weak_ptr (public member function). (destructor): Destroys a weak_ptr (public member function). operator= : Assigns the weak_ptr (public member function). reset : Releases the ownership of the managed object (public member function). swap : Swaps the managed objects (public member function). use_count : Returns the number of shared_ptr objects that manage the object (public member function). expired : Checks whether the referenced object was already deleted (public member function). lock : Creates a shared_ptr that manages the referenced object (public member function). owner_before : Provides owner-based ordering of weak pointers (public member function). owner_hash (C++26): Provides owner-based hashing of weak pointers (public member function). owner_equal (C++26): Provides owner-based equal comparison of weak pointers (public member function).","title":"Member Functions"},{"location":"SmartPointers/#non-member-functions_2","text":"std::swap( std::weak_ptr ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"SmartPointers/#helper-classes_2","text":"std::atomic< std::weak_ptr > (C++20): Atomic weak pointer(class template specialization).","title":"Helper Classes"},{"location":"SomeCFunctionsAndOperators/","text":"Some C Functions and Operators sizeof Explanation Syntax strlen Explanation Syntax malloc Explanation Syntax calloc Explanation Syntax realloc Explanation Syntax free Explanation Syntax strcpy Explanation Syntax memcpy (Shallow Copy) Explanation Syntax memset Explanation Syntax Some C Functions and Operators sizeof Explanation sizeof is a compile-time operator that returns the size , in bytes, of a type or object . It can be used with types, variables, or expressions. The result is of type size_t , which is an unsigned integral type. Syntax sizeof( type ) sizeof variable sizeof( expression ) strlen Explanation strlen is a function that returns the length of a C-style string (a null-terminated array of characters). It counts the number of characters in the string, excluding the null terminator. Syntax // Its declaration syntax. size_t strlen( const char *str ); // Its usage syntax. size_t len = strlen( str ); malloc Explanation malloc (memory allocation) is a function that allocates a specified number of bytes of memory without initializing it. It returns a void pointer to the allocated memory. When using malloc to allocate memory for an object, no constructor function will be called . free should be used to deallocate memory allocated with malloc . Syntax // Its declaration syntax. void* ptr = malloc( size_t size ); // Its usage syntax. Type* ptr = (Type*)malloc( num * sizeof( Type ) ); calloc Explanation calloc (contiguous allocation) is a function that allocates a specified number of bytes of memory and initializes all bits to zero . It returns a void pointer to the allocated memory. When using calloc to allocate memory for an object, no constructor function will be called . free should be used to deallocate memory allocated with calloc . Syntax // Its declaration syntax. void* ptr = calloc( size_t num, size_t size ); // Its usage syntax. Type* ptr = (Type*)calloc( num, sizeof( Type ) ); realloc Explanation The realloc function is used to resize a previously allocated memory block . It can either expand or shrink the size of the memory block. If the block is expanded , realloc may move the block to a new location in memory, and it preserves the contents of the original memory up to the lesser of the new or old size. It returns a void pointer to the resized memory. free should be used to deallocate memory resized with calloc . Syntax // Its declaration syntax. void* realloc( void* ptr, size_t new_size ); // Its usage syntax. Type* ptr = (Type*)malloc( num1 * sizeof( Type ) ); Type* new_ptr = (Type*)realloc( ptr, num2 * sizeof( Type ) ); free Explanation The free function is used to deallocate memory that was previously allocated with malloc , calloc , or realloc . It releases the memory back to the system , allowing it to be reused. When using free to deallocate memory for an object, no destructor function will be called After calling free , it's a good practice to set the pointer to NULL to avoid dangling pointers. Syntax // Its declaration syntax. void free( void* ptr ); // Its usage syntax. // Free the allocated memory. free( ptr ); ptr = NULL; // Good practice to avoid dangling pointers strcpy Explanation The strcpy function copies the C-string pointed to by source ( including the null terminator) to the array pointed to by destination. The destination array must be large enough to hold the copied string. If the destination is not large enough, it can lead to buffer overflow, resulting in undefined behavior. Syntax // Its declaration syntax. char* strcpy( char* destination, const char* source ); // Its usage syntax. strcpy( dest, sour_str ); memcpy (Shallow Copy) Explanation The memcpy function copies num bytes from the memory area pointed to by source to the memory area pointed to by destination . It's important to ensure that the destination has enough space to accommodate the copied bytes. Unlike strcpy , memcpy does not stop at a null terminator , making it suitable for raw memory copying. Syntax // Its declaration syntax. void* memcpy( void* destination, const void* source, size_t num ); // Its usage syntax, for a string. // +1 to include null terminator memcpy( dest, sour, strlen( sour ) + 1 ); // Its usage syntax, for a array (including char array). memcpy( dest, sour, sizeof( sour ) ); memset Explanation The memset function sets the first num bytes of the memory area pointed to by ptr to the specified value . This is commonly used to initialize or reset a block of memory , such as clearing an array or setting a structure to zero. The parameter int value in memset is treated as an unsigned char when setting the bytes in memory Syntax // Its declaration syntax. void* memset( void* ptr, int value, size_t num ); // Its usage syntax. memcpy( ptr, val, num );","title":"Some C Functions and Operators"},{"location":"SomeCFunctionsAndOperators/#some-c-functions-and-operators","text":"","title":"Some C Functions and Operators"},{"location":"SomeCFunctionsAndOperators/#sizeof","text":"","title":"sizeof"},{"location":"SomeCFunctionsAndOperators/#explanation","text":"sizeof is a compile-time operator that returns the size , in bytes, of a type or object . It can be used with types, variables, or expressions. The result is of type size_t , which is an unsigned integral type.","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax","text":"sizeof( type ) sizeof variable sizeof( expression )","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#strlen","text":"","title":"strlen"},{"location":"SomeCFunctionsAndOperators/#explanation_1","text":"strlen is a function that returns the length of a C-style string (a null-terminated array of characters). It counts the number of characters in the string, excluding the null terminator.","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_1","text":"// Its declaration syntax. size_t strlen( const char *str ); // Its usage syntax. size_t len = strlen( str );","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#malloc","text":"","title":"malloc"},{"location":"SomeCFunctionsAndOperators/#explanation_2","text":"malloc (memory allocation) is a function that allocates a specified number of bytes of memory without initializing it. It returns a void pointer to the allocated memory. When using malloc to allocate memory for an object, no constructor function will be called . free should be used to deallocate memory allocated with malloc .","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_2","text":"// Its declaration syntax. void* ptr = malloc( size_t size ); // Its usage syntax. Type* ptr = (Type*)malloc( num * sizeof( Type ) );","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#calloc","text":"","title":"calloc"},{"location":"SomeCFunctionsAndOperators/#explanation_3","text":"calloc (contiguous allocation) is a function that allocates a specified number of bytes of memory and initializes all bits to zero . It returns a void pointer to the allocated memory. When using calloc to allocate memory for an object, no constructor function will be called . free should be used to deallocate memory allocated with calloc .","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_3","text":"// Its declaration syntax. void* ptr = calloc( size_t num, size_t size ); // Its usage syntax. Type* ptr = (Type*)calloc( num, sizeof( Type ) );","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#realloc","text":"","title":"realloc"},{"location":"SomeCFunctionsAndOperators/#explanation_4","text":"The realloc function is used to resize a previously allocated memory block . It can either expand or shrink the size of the memory block. If the block is expanded , realloc may move the block to a new location in memory, and it preserves the contents of the original memory up to the lesser of the new or old size. It returns a void pointer to the resized memory. free should be used to deallocate memory resized with calloc .","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_4","text":"// Its declaration syntax. void* realloc( void* ptr, size_t new_size ); // Its usage syntax. Type* ptr = (Type*)malloc( num1 * sizeof( Type ) ); Type* new_ptr = (Type*)realloc( ptr, num2 * sizeof( Type ) );","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#free","text":"","title":"free"},{"location":"SomeCFunctionsAndOperators/#explanation_5","text":"The free function is used to deallocate memory that was previously allocated with malloc , calloc , or realloc . It releases the memory back to the system , allowing it to be reused. When using free to deallocate memory for an object, no destructor function will be called After calling free , it's a good practice to set the pointer to NULL to avoid dangling pointers.","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_5","text":"// Its declaration syntax. void free( void* ptr ); // Its usage syntax. // Free the allocated memory. free( ptr ); ptr = NULL; // Good practice to avoid dangling pointers","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#strcpy","text":"","title":"strcpy"},{"location":"SomeCFunctionsAndOperators/#explanation_6","text":"The strcpy function copies the C-string pointed to by source ( including the null terminator) to the array pointed to by destination. The destination array must be large enough to hold the copied string. If the destination is not large enough, it can lead to buffer overflow, resulting in undefined behavior.","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_6","text":"// Its declaration syntax. char* strcpy( char* destination, const char* source ); // Its usage syntax. strcpy( dest, sour_str );","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#memcpy-shallow-copy","text":"","title":"memcpy (Shallow Copy)"},{"location":"SomeCFunctionsAndOperators/#explanation_7","text":"The memcpy function copies num bytes from the memory area pointed to by source to the memory area pointed to by destination . It's important to ensure that the destination has enough space to accommodate the copied bytes. Unlike strcpy , memcpy does not stop at a null terminator , making it suitable for raw memory copying.","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_7","text":"// Its declaration syntax. void* memcpy( void* destination, const void* source, size_t num ); // Its usage syntax, for a string. // +1 to include null terminator memcpy( dest, sour, strlen( sour ) + 1 ); // Its usage syntax, for a array (including char array). memcpy( dest, sour, sizeof( sour ) );","title":"Syntax"},{"location":"SomeCFunctionsAndOperators/#memset","text":"","title":"memset"},{"location":"SomeCFunctionsAndOperators/#explanation_8","text":"The memset function sets the first num bytes of the memory area pointed to by ptr to the specified value . This is commonly used to initialize or reset a block of memory , such as clearing an array or setting a structure to zero. The parameter int value in memset is treated as an unsigned char when setting the bytes in memory","title":"Explanation"},{"location":"SomeCFunctionsAndOperators/#syntax_8","text":"// Its declaration syntax. void* memset( void* ptr, int value, size_t num ); // Its usage syntax. memcpy( ptr, val, num );","title":"Syntax"},{"location":"SomeProgrammingTechniques/","text":"Some Small Knowledge Type Puning Explanation Common Methods of Type Punning Using Unions Using Casting Using std::variant Using std::any The Usage of Automatic Scope-based Destruction How to Return Multiple Values Breakpoints Precompiled Headers (PCH) How to Measure How Many Memory Allocations Ocur or Track Memory Allocations Benchmark and How to Visualize Benchmark Results Singleton Continuous Integration (CI) in C++ Explanation Why CI is important for C++ CI Workflow for C++ Tools for CI in C++ CI Platforms Build Tools Code Quality and Static Analysis Tools Best Practices for C++ CI What We Can Do in Our Project RAII (Resource Acquisition Is Initialization) Explanation Usage Advantages Disadvantages Some Small Knowledge The performance of < is better than <= . std::endl is a little slower than \"\\n\" in debug mode . Otherwise, std::endl is faster . Function argument evaluation order is undefined in C++. Differenct compilers with different flags have different evaluation orders, until C++17, an uncomplete definiton of the function argument evaluation order comes. All variables, objects, references, and pointers should be **initialized explicitly and Float: Be very careful. Both float and double type variables have precision limitations . You should never use == or != to compare them with any number. Instead, you should try to convert the comparison into >= or <= forms . Type Puning Explanation It is a programming technique used to treat a data type as if it were a different data type , usually without explicit type conversion. This often involves using pointers, unions, or other low-level mechanisms to reinterpret the bits of a value as a different type . It is often recommended to avoid type punning unless absolutely necessary, and to use safer alternatives like: standard conversions, std::bit_cast and serialization. It can achieve specific goals like low-level optimization , treating a struct or a class as an array, treating Type1 memory as Type2 memory at the same memory address or interfacing with hardware. However, developers must be aware of the risks , including undefined behavior and portability issues , and use safer alternatives whenever possible . Common Methods of Type Punning Using Unions struct Vector2 { float x, y; }; struct Vector4 { union { struct { float x, y, z, w; }; struct { Vector2 a, b; }; }; }; struct Vector3 { union { struct { float x, y, z; }; struct { float r, g, b; }; }; }; Using Casting Conversion And Casting Using std::variant std::variant Using std::any std:any The Usage of Automatic Scope-based Destruction Smart pointers or scope pointers : Create an object on the heap, and automatically destroy it without using delete when it goes out of scope or when certain conditions are met. A smart pointer is a wrapper around a real raw pointer. Timer : Measure the execution time of a scope, print the result, and automatically destroy the timer object when it goes out of scope. Lock : Lock a function so that multiple threads cannot access it simultaneously , and automatically unlock it at the end of the function. How to Return Multiple Values A structure: Recommend , know the information about the internal variables or objects of the structure. Multiple references. Multiple pointers. An array. A std::array : Faster than a std::vector because it can be stored on the stack, while the std::vector is stored on the heap. A std::vector : A std::tuple , std::make_pair and std::get : Not recommend , can't know the information about the internal variables or objects of the std::tuple , like their names. A std::pair , std::make_pair : Not recommend , can't know the information about the internal variables or objects of the std::pair , like their names. Breakpoints Normal breakpoints: A normal breakpoint is a point in the code where the execution will pause when the debugger reaches it. This allows you to inspect the current state of the program, including variable values, the call stack, and other context. Conditional breakpoints: A conditional breakpoint is similar to a normal breakpoint but includes a condition that must be met for the breakpoint to trigger. This allows you to pause execution only when certain criteria are satisfied. Action breakpoints: An action breakpoint (sometimes called a \"tracepoint\" or \"logging breakpoint\") allows you to specify actions that occur when the breakpoint is hit , without necessarily pausing the execution of the program . This can include logging messages or modifying variables . Precompiled Headers (PCH) Precompiled headers (PCH) are a feature designed to accelerate the compilation process, particularly in large projects . By precompiling frequently used header files , PCHs eliminate the need to recompile these files every time a source file is processed. While precompiled headers can significantly reduce compilation times, they require careful setup and management to be effective. It's vitally used for code that isn't yours, for example, STL library and OpenCL library. However, it may make your code harder to read. How to Measure How Many Memory Allocations Ocur or Track Memory Allocations Overload the new operator to print some information: CPP void* operator new( size_t size ) { // Do something return malloc( size ); }; Benchmark and How to Visualize Benchmark Results There is no universally accepted method for measuring performance . Different techniques have their own drawbacks, resulting in less than 100% accurate outcomes. Cheron, a game developer, utilizes std::chrono to implement a scoped timer for assessing the performance of their game engine. Use macros to wrap our print functions and timer objcets so that we can determine whether we should compile them. Use __FUNCTION__ or __FUNSIG__ instead of using a string to print a function name. Visualization Method One: Store all result into a txt file. Use perl to extract all data from the txt files and store them into a excel file. Use Excel to visualize all data. Visualization Method Two: Store all data into a json file in the format that the tracing tool expects. Open your chrome kernel browser. Type chrome://tracing or edge://tracing or ... depending on your which browser you use into the URL line of the browser and press the enter key to open the tracing tool. Drop the json file into the tracing tool or use the tracing tool to load the json file. V Visulaize data and the relationship among different functions like on a stack. Singleton It's a strategy used to organize a bunch of global variables and static functions in C++. To avoid copying the signleton , adding the delete keyword to the copy constructor . We can use multiple static functions to return a non-static member by calling a non-static function . Because these functions are simple enough, the inline operation will expand them and no performance is wasted . Also, initializing the singleton in a static function which returns this signleton can make our code cleaner. It exists until the application is closed. Using namespace instead of a class or a structure to implement the singleton is also ok. Continuous Integration (CI) in C++ Explanation Continuous Integration (CI) is a software development practice that ensures code changes are integrated frequently , with each integration verified through automated builds and tests . In C++ projects, CI helps maintain code quality and detect issues early by automating compilation, linking, and testing across multiple platforms and environments. Why CI is important for C++ Frequent integration : Ensures new code integrates seamlessly with the existing codebase, preventing compatibility and integration issues. Early bug detection : Automated tests detect issues early in the development cycle. Multi-platform support : C++ applications often target multiple platforms (e.g., Windows, Linux, macOS), and CI ensures builds succeed across all. Performance testing : CI can run benchmarks to track performance regressions. Consistency : Enforces coding standards and ensures dependencies are properly managed. CI Workflow for C++ Code changes : Developers push changes to a repository (e.g., GitHub, GitLab). CI pipeline trigger : Each commit triggers the CI pipeline. Build : The code is compiled and linked for different target platforms. Testing : Automated unit tests, integration tests, and performance tests run. Code quality checks: Tools like clang-tidy and cppcheck ensure the code follows best practices. Deployment (Optional) : The CI system can deploy artifacts if required. Reporting : Results are reported back to developers, and any issues are highlighted for resolution. Tools for CI in C++ CI Platforms GitHub actions. GitLab CI/CD. Jenkins: Provides custom pipelines using Groovy. Suitable for complex CI needs and large projects. Build Tools CMake: A cross-platform tool to manage the build process. Make: Automates the compilation and linking process using a Makefile. Code Quality and Static Analysis Tools clang-tidy: Checks code style and detects potential bugs. It's a static analysis tool that helps you analyze your code to find some issues that compiler can't detect, for example inifinite loops, name style and some undefined behaviors. It requires a compile_commands.json file compilation options. Therefore, if there is no compile_commands.json in your project, it may not function. If you want to disable clang-tidy check for some code, you can know more about NOLINT , NOLINTNEXTLINE , and NOLINTBEGIN \u2026 NOLINTEND comments. Gcc/G++ also provides static analysis. However, few tools use it to detect code when programmers are writing code. It's only used during compiling code. In addition, there are other static analysis tools, for example, cppcheck , coverit and PVS studio . We can ask chatgpt to know more about their difference. Valgrind: Detects memory leaks and profiling issues Best Practices for C++ CI Use CMake for cross-platform builds: Ensure the project builds across all targeted operating systems. Run static analysis as part of the pipeline: Identify code quality issues early. Parallel testing: Use tools like GoogleTest and catch2 to run unit tests efficiently. Dockerize builds: For consistent build environments, use Docker images with all dependencies pre-installed. Monitor performance metrics: Integrate performance benchmarks into the pipeline to detect regressions. What We Can Do in Our Project Write some perl scripts to extract data. Write some make/cmake scripts to build your project. Write some shell scripts to test your project. Write some shell scripts to manage your project and execute these scripts you write on previous three steps. Use some tools to visualize these steps, for example, Jenkins. ( Optional ) RAII (Resource Acquisition Is Initialization) Explanation RAII ties resource management (acquisition and release) to object lifetime . Resources are acquired during object construction and automatically released during destruction. Guarantees resource cleanup even in the face of exceptions or complex control flows. Usage Dynamic memory Managed via smart pointers like std::unique_ptr or std::shared_ptr . File handles: Managed by RAII-style classes to open and close files automatically. Mutex locks: Managed with objects like std::lock_guard to handle locking and unlocking. Network connections: Managed through RAII for automatic connection and disconnection. Resource pooling: Ensures proper acquisition and release of resources like database connections. Advantages Automatic resource management: Reduces risk of resource leaks by ensuring cleanup. Exception safety: Ensures resources are released even if an exception is thrown. Simplified code: Minimizes explicit resource management code. Fewer bugs: Helps avoid common issues like dangling pointers and memory leaks. Scoped resource control: Clearly defines the scope and duration of resource usage. Disadvantages Limited flexibility: Resource lifetime is tied to object lifetime, which may not always align with program requirements. Complexity in destruction: Destructors may become complex if managing multiple resources. Increased memory usage: Smart pointers introduce slight memory and performance overhead. Potential for overhead: RAII can add overhead, especially with frequent acquisition/release. Not suitable for non-scope-based resources: Less effective for resources not naturally scoped to an object\u2019s lifetime (e.g., global or shared resources).","title":"Some Programming Techniques"},{"location":"SomeProgrammingTechniques/#some-small-knowledge","text":"The performance of < is better than <= . std::endl is a little slower than \"\\n\" in debug mode . Otherwise, std::endl is faster . Function argument evaluation order is undefined in C++. Differenct compilers with different flags have different evaluation orders, until C++17, an uncomplete definiton of the function argument evaluation order comes. All variables, objects, references, and pointers should be **initialized explicitly and Float: Be very careful. Both float and double type variables have precision limitations . You should never use == or != to compare them with any number. Instead, you should try to convert the comparison into >= or <= forms .","title":"Some Small Knowledge"},{"location":"SomeProgrammingTechniques/#type-puning","text":"","title":"Type Puning"},{"location":"SomeProgrammingTechniques/#explanation","text":"It is a programming technique used to treat a data type as if it were a different data type , usually without explicit type conversion. This often involves using pointers, unions, or other low-level mechanisms to reinterpret the bits of a value as a different type . It is often recommended to avoid type punning unless absolutely necessary, and to use safer alternatives like: standard conversions, std::bit_cast and serialization. It can achieve specific goals like low-level optimization , treating a struct or a class as an array, treating Type1 memory as Type2 memory at the same memory address or interfacing with hardware. However, developers must be aware of the risks , including undefined behavior and portability issues , and use safer alternatives whenever possible .","title":"Explanation"},{"location":"SomeProgrammingTechniques/#common-methods-of-type-punning","text":"","title":"Common Methods of Type Punning"},{"location":"SomeProgrammingTechniques/#using-unions","text":"struct Vector2 { float x, y; }; struct Vector4 { union { struct { float x, y, z, w; }; struct { Vector2 a, b; }; }; }; struct Vector3 { union { struct { float x, y, z; }; struct { float r, g, b; }; }; };","title":"Using Unions"},{"location":"SomeProgrammingTechniques/#using-casting","text":"Conversion And Casting","title":"Using Casting"},{"location":"SomeProgrammingTechniques/#using-stdvariant","text":"std::variant","title":"Using std::variant"},{"location":"SomeProgrammingTechniques/#using-stdany","text":"std:any","title":"Using std::any"},{"location":"SomeProgrammingTechniques/#the-usage-of-automatic-scope-based-destruction","text":"Smart pointers or scope pointers : Create an object on the heap, and automatically destroy it without using delete when it goes out of scope or when certain conditions are met. A smart pointer is a wrapper around a real raw pointer. Timer : Measure the execution time of a scope, print the result, and automatically destroy the timer object when it goes out of scope. Lock : Lock a function so that multiple threads cannot access it simultaneously , and automatically unlock it at the end of the function.","title":"The Usage of Automatic Scope-based Destruction"},{"location":"SomeProgrammingTechniques/#how-to-return-multiple-values","text":"A structure: Recommend , know the information about the internal variables or objects of the structure. Multiple references. Multiple pointers. An array. A std::array : Faster than a std::vector because it can be stored on the stack, while the std::vector is stored on the heap. A std::vector : A std::tuple , std::make_pair and std::get : Not recommend , can't know the information about the internal variables or objects of the std::tuple , like their names. A std::pair , std::make_pair : Not recommend , can't know the information about the internal variables or objects of the std::pair , like their names.","title":"How to Return Multiple Values"},{"location":"SomeProgrammingTechniques/#breakpoints","text":"Normal breakpoints: A normal breakpoint is a point in the code where the execution will pause when the debugger reaches it. This allows you to inspect the current state of the program, including variable values, the call stack, and other context. Conditional breakpoints: A conditional breakpoint is similar to a normal breakpoint but includes a condition that must be met for the breakpoint to trigger. This allows you to pause execution only when certain criteria are satisfied. Action breakpoints: An action breakpoint (sometimes called a \"tracepoint\" or \"logging breakpoint\") allows you to specify actions that occur when the breakpoint is hit , without necessarily pausing the execution of the program . This can include logging messages or modifying variables .","title":"Breakpoints"},{"location":"SomeProgrammingTechniques/#precompiled-headers-pch","text":"Precompiled headers (PCH) are a feature designed to accelerate the compilation process, particularly in large projects . By precompiling frequently used header files , PCHs eliminate the need to recompile these files every time a source file is processed. While precompiled headers can significantly reduce compilation times, they require careful setup and management to be effective. It's vitally used for code that isn't yours, for example, STL library and OpenCL library. However, it may make your code harder to read.","title":"Precompiled Headers (PCH)"},{"location":"SomeProgrammingTechniques/#how-to-measure-how-many-memory-allocations-ocur-or-track-memory-allocations","text":"Overload the new operator to print some information: CPP void* operator new( size_t size ) { // Do something return malloc( size ); };","title":"How to Measure How Many Memory Allocations Ocur or Track Memory Allocations"},{"location":"SomeProgrammingTechniques/#benchmark-and-how-to-visualize-benchmark-results","text":"There is no universally accepted method for measuring performance . Different techniques have their own drawbacks, resulting in less than 100% accurate outcomes. Cheron, a game developer, utilizes std::chrono to implement a scoped timer for assessing the performance of their game engine. Use macros to wrap our print functions and timer objcets so that we can determine whether we should compile them. Use __FUNCTION__ or __FUNSIG__ instead of using a string to print a function name. Visualization Method One: Store all result into a txt file. Use perl to extract all data from the txt files and store them into a excel file. Use Excel to visualize all data. Visualization Method Two: Store all data into a json file in the format that the tracing tool expects. Open your chrome kernel browser. Type chrome://tracing or edge://tracing or ... depending on your which browser you use into the URL line of the browser and press the enter key to open the tracing tool. Drop the json file into the tracing tool or use the tracing tool to load the json file. V Visulaize data and the relationship among different functions like on a stack.","title":"Benchmark and How to Visualize Benchmark Results"},{"location":"SomeProgrammingTechniques/#singleton","text":"It's a strategy used to organize a bunch of global variables and static functions in C++. To avoid copying the signleton , adding the delete keyword to the copy constructor . We can use multiple static functions to return a non-static member by calling a non-static function . Because these functions are simple enough, the inline operation will expand them and no performance is wasted . Also, initializing the singleton in a static function which returns this signleton can make our code cleaner. It exists until the application is closed. Using namespace instead of a class or a structure to implement the singleton is also ok.","title":"Singleton"},{"location":"SomeProgrammingTechniques/#continuous-integration-ci-in-c","text":"","title":"Continuous Integration (CI) in C++"},{"location":"SomeProgrammingTechniques/#explanation_1","text":"Continuous Integration (CI) is a software development practice that ensures code changes are integrated frequently , with each integration verified through automated builds and tests . In C++ projects, CI helps maintain code quality and detect issues early by automating compilation, linking, and testing across multiple platforms and environments.","title":"Explanation"},{"location":"SomeProgrammingTechniques/#why-ci-is-important-for-c","text":"Frequent integration : Ensures new code integrates seamlessly with the existing codebase, preventing compatibility and integration issues. Early bug detection : Automated tests detect issues early in the development cycle. Multi-platform support : C++ applications often target multiple platforms (e.g., Windows, Linux, macOS), and CI ensures builds succeed across all. Performance testing : CI can run benchmarks to track performance regressions. Consistency : Enforces coding standards and ensures dependencies are properly managed.","title":"Why CI is important for C++"},{"location":"SomeProgrammingTechniques/#ci-workflow-for-c","text":"Code changes : Developers push changes to a repository (e.g., GitHub, GitLab). CI pipeline trigger : Each commit triggers the CI pipeline. Build : The code is compiled and linked for different target platforms. Testing : Automated unit tests, integration tests, and performance tests run. Code quality checks: Tools like clang-tidy and cppcheck ensure the code follows best practices. Deployment (Optional) : The CI system can deploy artifacts if required. Reporting : Results are reported back to developers, and any issues are highlighted for resolution.","title":"CI Workflow for C++"},{"location":"SomeProgrammingTechniques/#tools-for-ci-in-c","text":"","title":"Tools for CI in C++"},{"location":"SomeProgrammingTechniques/#ci-platforms","text":"GitHub actions. GitLab CI/CD. Jenkins: Provides custom pipelines using Groovy. Suitable for complex CI needs and large projects.","title":"CI Platforms"},{"location":"SomeProgrammingTechniques/#build-tools","text":"CMake: A cross-platform tool to manage the build process. Make: Automates the compilation and linking process using a Makefile.","title":"Build Tools"},{"location":"SomeProgrammingTechniques/#code-quality-and-static-analysis-tools","text":"clang-tidy: Checks code style and detects potential bugs. It's a static analysis tool that helps you analyze your code to find some issues that compiler can't detect, for example inifinite loops, name style and some undefined behaviors. It requires a compile_commands.json file compilation options. Therefore, if there is no compile_commands.json in your project, it may not function. If you want to disable clang-tidy check for some code, you can know more about NOLINT , NOLINTNEXTLINE , and NOLINTBEGIN \u2026 NOLINTEND comments. Gcc/G++ also provides static analysis. However, few tools use it to detect code when programmers are writing code. It's only used during compiling code. In addition, there are other static analysis tools, for example, cppcheck , coverit and PVS studio . We can ask chatgpt to know more about their difference. Valgrind: Detects memory leaks and profiling issues","title":"Code Quality and Static Analysis Tools"},{"location":"SomeProgrammingTechniques/#best-practices-for-c-ci","text":"Use CMake for cross-platform builds: Ensure the project builds across all targeted operating systems. Run static analysis as part of the pipeline: Identify code quality issues early. Parallel testing: Use tools like GoogleTest and catch2 to run unit tests efficiently. Dockerize builds: For consistent build environments, use Docker images with all dependencies pre-installed. Monitor performance metrics: Integrate performance benchmarks into the pipeline to detect regressions.","title":"Best Practices for C++ CI"},{"location":"SomeProgrammingTechniques/#what-we-can-do-in-our-project","text":"Write some perl scripts to extract data. Write some make/cmake scripts to build your project. Write some shell scripts to test your project. Write some shell scripts to manage your project and execute these scripts you write on previous three steps. Use some tools to visualize these steps, for example, Jenkins. ( Optional )","title":"What We Can Do in Our Project"},{"location":"SomeProgrammingTechniques/#raii-resource-acquisition-is-initialization","text":"","title":"RAII (Resource Acquisition Is Initialization)"},{"location":"SomeProgrammingTechniques/#explanation_2","text":"RAII ties resource management (acquisition and release) to object lifetime . Resources are acquired during object construction and automatically released during destruction. Guarantees resource cleanup even in the face of exceptions or complex control flows.","title":"Explanation"},{"location":"SomeProgrammingTechniques/#usage","text":"Dynamic memory Managed via smart pointers like std::unique_ptr or std::shared_ptr . File handles: Managed by RAII-style classes to open and close files automatically. Mutex locks: Managed with objects like std::lock_guard to handle locking and unlocking. Network connections: Managed through RAII for automatic connection and disconnection. Resource pooling: Ensures proper acquisition and release of resources like database connections.","title":"Usage"},{"location":"SomeProgrammingTechniques/#advantages","text":"Automatic resource management: Reduces risk of resource leaks by ensuring cleanup. Exception safety: Ensures resources are released even if an exception is thrown. Simplified code: Minimizes explicit resource management code. Fewer bugs: Helps avoid common issues like dangling pointers and memory leaks. Scoped resource control: Clearly defines the scope and duration of resource usage.","title":"Advantages"},{"location":"SomeProgrammingTechniques/#disadvantages","text":"Limited flexibility: Resource lifetime is tied to object lifetime, which may not always align with program requirements. Complexity in destruction: Destructors may become complex if managing multiple resources. Increased memory usage: Smart pointers introduce slight memory and performance overhead. Potential for overhead: RAII can add overhead, especially with frequent acquisition/release. Not suitable for non-scope-based resources: Less effective for resources not naturally scoped to an object\u2019s lifetime (e.g., global or shared resources).","title":"Disadvantages"},{"location":"StacksAndQueues/","text":"Stacks Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::stack Pointers Members and Related Stuffs Links Template Parameters Member Types Member Objects Member Functions Non-member Functions Helper Classes Queues Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::queue Pointers Members and Related Stuffs Links Template Parameters Member Types Member Objects Member Functions Non-member Functions Helper Classes Priority Queues Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::priority_queue Pointers Members and Related Stuffs Links Template Parameters Member Types Member Objects Member Functions Non-member Functions Helper Classes Deques (Double-ended Queue) (Deck) Explanation Declaration Syntax Initialization Syntax Syntax for Deleting std::deque Pointers Members and Related Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Stacks Explanation Stacks are a type of container adaptor , specifically designed to operate in a LIFO context (last-in first-out) , where elements are inserted and extracted only from one end of the container. The stack class template acts as a wrapper to the underlying container - only a specific set of functions is provided . The stack pushes and pops the element from the back of the underlying container, known as the top of the stack. Their header file is <stack> . Declaration Syntax std::stack< Type > stack_name; // Not common, not recommend std::stack< Type, Container< Type > > stack_name; std::stack< Type >* stack_ptr; Initialization Syntax // Default constructor. Value-initializes the underlying container. std::stack< Type > stack_name; // Initializer list constructor. Container< Type > cont = { ... }; // Copy the content of the `cont`. std::stack< Type, Container< Type > > stack_name( cont ); // Move the content of the underlying container. std::stack< Type, Container< Type > > stack_name( Container< Type >{ ... } ); // Initializer list constructor. std::stack< Type > stack_name1( { ... } ); // Copy constructor. std::stack< Type > stack_name2( stack_name1 ); // Initializer list constructor. std::stack< Type > stack_name1( { ... } ); // Copy constructor. std::stack< Type > stack_name2 = stack_name1; // Initializer list constructor. std::stack< Type > stack_name1( { ... } ); // Move constructor. std::stack< Type > stack_name2( std::move( stack_name1 ) ); // Move the content of the underlying container. std::stack< Type, Container< Type > > stack_name1( Container< Type >{ ... } ); // Constructs the underlying container with the contents of the range `[first, last)`. std::stack< Type, Container< Type > > stack_name2( stack_name1.begin(), stack_name2.end() ); std::stack< Type >* stack_ptr = new std::stack< Type >; std::stack< Type, Container< Type > >* stack_ptr = new std::stack< Type >( Container< Type >{ ... } ); // Initializer list constructor. std::stack< Type > stack_name( { ... } ); std::stack< Type >* stack_ptr = new std::stack< Type >( stack_name ); std::stack< Type >* stack_ptr = new std::stack< Type >( { ... } ); Syntax for Deleting std::stack Pointers delete stack_ptr; Members and Related Stuffs Links std::stack in cplusplus . std::stack in cppreference . Template Parameters T : The type of the stored elements. The program is ill-formed if T is not the same type as Container::value_type . Container : The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer . Additionally, it must provide the following functions with the usual semantics: back() , e.g., std::vector::back() , push_back() , e.g., std::deque::push_back() , pop_back() , e.g., std::list::pop_back() . The standard containers std::vector (including std::vector< bool > ), std::deque and std::list satisfy these requirements. By default , if no container class is specified for a particular stack class instantiation, the standard container std::deque is used. Member Types container_type : Container . value_type : Container::value_type . size_type : Container::size_type . reference : Container::reference . const_reference : Container::const_reference . Member Objects Container c : The underlying container (protected member object). Member Functions (constructor): Constructs the stack (public member function). (destructor): Destructs the stack (public member function). operator= : Assigns values to the container adaptor (public member function). top : Accesses the top element (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). push : Inserts element at the top (public member function). push_range (C++23): Inserts a range of elements at the top (public member function). emplace : Constructs element in-place at the top (public member function). pop : Removes the top element (public member function). swap : Swaps the contents (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two stacks (function template). std::swap( std::stack ) : Specializes the std::swap algorithm (function template). Helper Classes std::uses_allocator< std::stack > : Specializes the std::uses_allocator type trait (class template specialization). std::formatter< std::stack > (C++23): Formatting support for std::stack (class template specialization). Queues Explanation Queues are a type of container adaptor , specifically designed to operate in a FIFO context (first-in first-out) , where elements are inserted into one end of the container and extracted from the other. The queue class template acts as a wrapper to the underlying container - only a specific set of functions is provided . The queue pushes the elements on the back of the underlying container and pops them from the front. Their header file is <queue> . Declaration Syntax std::queue< Type > queue_name; // Not common, not recommend std::queue< Type, Container< Type > > queue_name; std::queue< Type >* queue_ptr; Initialization Syntax // Default constructor. Value-initializes the underlying container. std::queue< Type > queue_name; Container< Type > cont = { ... }; // Copy the content of the `cont`. std::queue< Type, Container< Type > > queue_name( cont ); // Move the content of the underlying container. std::queue< Type, Container< Type > > queue_name( Container< Type >{ ... } ); // Initializer list constructor. std::queue< Type > queue_name1( { ... } ); // Copy constructor. std::queue< Type > queue_name2( queue_name1 ); // Initializer list constructor. std::queue< Type > queue_name1( { ... } ); // Copy constructor. std::queue< Type > queue_name2 = queue_name1; // Initializer list constructor. std::queue< Type > queue_name1( { ... } ); // Move constructor. std::queue< Type > queue_name1( std::move( queue_name1 ) ); // Move the content of the underlying container. std::queue< Type, Container< Type > > queue_name1( Container< Type >{ ... } ); // Constructs the underlying container with the contents of the range `[first, last)`. std::queue< Type, Container< Type > > queue_name2( queue_name1.begin(), queue_name2.end() ); std::queue< Type >* queue_ptr = new std::queue< Type >; std::queue< Type, Container< Type > >* queue_ptr = new std::queue< Type >( Container< Type >{ ... } ); // Initializer list constructor. std::queue< Type > queue_name( { ... } ); std::queue< Type >* queue_ptr = new std::queue< Type >( queue_name ); std::queue< Type >* queue_ptr = new std::queue< Type >( { ... } ); Syntax for Deleting std::queue Pointers delete queue_ptr; Members and Related Stuffs Links std::queue in cplusplus . std::queue in cppreference . Template Parameters T : The type of the stored elements. The program is ill-formed if T is not the same type as Container::value_type . Container : The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer . Additionally, it must provide the following functions with the usual semantics: back() , e.g., std::deque::back() , front() , e.g. std::list::front() , push_back() , e.g., std::deque::push_back() , pop_front() , e.g., std::list::pop_front() . The standard containers std::deque and std::list satisfy these requirements. Member Types container_type : Container . value_type : Container::value_type . size_type : Container::size_type . reference : Container::reference . const_reference : Container::const_reference . Member Objects Container c : The underlying container (protected member object). Member Functions (constructor): Constructs the queue (public member function). (destructor): Destructs the queue (public member function). operator= : Assigns values to the container adaptor (public member function). front : Access the first element (public member function). back : Access the last element (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). push : Inserts element at the end (public member function). push_range (C++23): Inserts a range of elements at the end (public member function). emplace : Constructs element in-place at the end (public member function). pop : Removes the first element (public member function). swap : Swaps the contents (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two queues (function template). std::swap( std::queue ) : Specializes the std::swap algorithm (function template). Helper Classes std::uses_allocator< std::queue > : Specializes the std::uses_allocator type trait (class template specialization). std::formatter< std::queue > (C++23): Formatting support for std::queue (class template specialization). Priority Queues Explanation Priority queues are a type of container adaptors , specifically designed such that its first element is always the largest of the elements it contains , according to some strict weak ordering criterion . A user-provided Compare can be supplied to change the ordering , e.g. using std::greater< T > would cause the smallest element to appear as the top() . This context is similar to a heap , where elements can be inserted at any moment , and only the max heap element can be retrieved (the one at the top in the priority queue). The priority queue class template acts as a wrapper to the underlying container - only a specific set of functions is provided . Their header file is <queue> . Declaration Syntax std::priority_queue< Type > pqueue_name; // Not common, not recommend std::priority_queue< Type, Container< Type > > pqueue_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::priority_queue< Type, Container< Type >, Compare > pqueue_name; std::priority_queue< Type, std::vector< Type >, Compare > pqueue_name; std::priority_queue< Type >* pri_queue_ptr; Initialization Syntax // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name; // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type, Container< Type >, Compare > pqueue_name; // Copy-constructs the temporary `Compare` class object. Value-initializes the underlying container. std::priority_queue< Type, Container< Type >, Compare > rpqueue_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::priority_queue< Type, Container< Type >, Compare > pqueue_name( comp ); Compare comp; Container< Type > cont = { ... }; // Copy the content of the `comp` and the `cont`. std::priority_queue< Type, Container< Type >, Compare > pqueue_name( cont, comp ); Compare comp; // Move the content of the underlying container. // Copy the content of the `comp`. std::priority_queue< Type, Container< Type >, Compare > pqueue_name( Container< Type >{ ... }, comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name1; // Copy constructor. std::priority_queue< Type > pqueue_name2( pqueue_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name1; // Copy constructor. std::priority_queue< Type > pqueue_name2 = pqueue_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name1; // Move constructor. std::priority_queue< Type > pqueue_name2( std::move( pqueue_name1 ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; Container< Type > cont = { ... }; std::priority_queue< Type, Container< Type >, Compare > pqueue_name1( comp, cont ); // Constructs the underlying container with the contents of the range `[first, last)`. std::priority_queue< Type, Container< Type >, Compare > pqueue_name2( pqueue_name1.begin(), pqueue_name1.end(), comp /* optional */, cont /* optional */ ); std::priority_queue< Type >* pri_queue_ptr = new std::priority_queue< Type >; // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name; std::priority_queue< Type >* pri_queue_ptr = new std::priority_queue< Type >( pqueue_name ); Syntax for Deleting std::priority_queue Pointers delete pri_queue_ptr; Members and Related Stuffs Links std::priority_queue in cplusplus . std::priority_queue in cppreference . Template Parameters T : The type of the stored elements. The program is ill-formed if T is not the same type as Container::value_type . Container : The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer , and its iterators must satisfy the requirements of LegacyRandomAccessIterator . Additionally, it must provide the following functions with the usual semantics: front() , e.g., std::vector::front() , push_back() , e.g., std::deque::push_back() , pop_back() , e.g., std::vector::pop_back() . The standard containers std::vector (including std::vector< bool > ) and std::deque satisfy these requirements. Compare : A Compare type providing a strict weak ordering. By default, the first key (largest key) is at the top of the queue because its underlying structure is a max-heap, which uses std::less< T > to maintain that structure, ensuring the largest element is accessible first. Member Types container_type : Container . value_compare : Compare . value_type : Container::value_type . size_type : Container::size_type . reference : Container::reference . const_reference : Container::const_reference . Member Objects Container c : The underlying container (protected member object). Compare comp : The comparison function object (protected member object). Member Functions (constructor): Constructs the priority_queue (public member function). (destructor): Destructs the priority_queue (public member function). operator= : Assigns values to the container adaptor (public member function). top : Accesses the top element (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). push : Inserts element and sorts the underlying container (public member function). push_range (C++23): Inserts a range of elements and sorts the underlying container (public member function). emplace : Constructs element in-place and sorts the underlying container (public member function). pop : Removes the top element (public member function). swap : Swaps the contents (public member function). Non-member Functions std::swap( std::priority_queue ) : Specializes the std::swap algorithm (function template). Helper Classes std::uses_allocator< std::priority_queue > : Specializes the std::uses_allocator type trait (class template specialization). std::formatter< std::priority_queue > (C++23): Formatting support for std::priority_queue (class template specialization). Deques (Double-ended Queue) (Deck) Explanation Deques are sequence containers (template classes) with dynamic sizes that can be expanded or contracted on both ends (either its front or its back). They allow for the individual elements to be accessed directly through random access iterators , with storage handled automatically by expanding and contracting the container as needed. They provide a functionality similar to vectors , but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end . But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations : accessing elements in a deque by offsetting a pointer to another element causes undefined behavior . Their header file is <deque> . Declaration Syntax std::deque< Type > deque_name; std::deque< Type >* deque_ptr; Initialization Syntax // Initializer deque constructor. std::deque< Type > deque_name = { ... }; // Initializer deque constructor. std::deque< Type > deque_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::deque< Type > deque_name; // No initialization, contain garbage values and behave unpredictably. std::deque< Type > deque_name( size ); // Initialization with the specific value. std::deque< Type > deque_name( size, value ); // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Copy constructor. std::deque< Type > deque_name2( deque_name1 ); // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Copy constructor. std::deque< Type > deque_name2 = deque_name1; // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Move constructor. std::deque< Type > deque_name2 = std::move( deque_name1 ); // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Constructs the underlying container with the contents of the range `[first, last)`. std::deque< Type, Container< Type > > deque_name2( deque_name1.begin(), deque_name2.end() ); std::deque< Type >* deque_ptr = new std::deque< Type >( size ); std::deque< Type >* deque_ptr = new std::deque< Type >( size, value ); // Initializer deque constructor. std::deque< Type > deque_name = { ... }; std::deque< Type >* deque_ptr = new std::deque< Type >( deque_name ); std::deque< Type >* deque_ptr = new std::deque< Type >{ ... }; Syntax for Deleting std::deque Pointers delete deque_ptr; Members and Related Stuffs Links std::deque in cplusplus . std::deque in cppreference . Template Parameters T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. Member Types value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > . Member Functions (constructor): Constructs the deque (public member function). (destructor): Destructs the deque (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access specified element (public member function). front : Access the first element (public member function). back : Access the last element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). shrink_to_fit ( DR* ): Reduces memory usage by freeing unused memory (public member function). clear : Clears the contents (public member function). insert : Inserts elements (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). erase : Erases elements and returns a valid iterator (public member function). push_back : Adds an element to the end (public member function). emplace_back : Constructs an element in-place at the end (public member function). append_range (C++23): Adds a range of elements to the end (public member function). pop_back : Removes the last element (public member function). push_front : Inserts an element to the beginning (public member function). emplace_front : Constructs an element in-place at the beginning (public member function). prepend_range (C++23): Adds a range of elements to the beginning (public member function). pop_front : Removes the first element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function). Non-member Functions operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two deques (function template). std::swap( std::deque ) : Specializes the std::swap algorithm (function template). erase( std::deque ) (C++20), erase_if( std::deque ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Stacks and Queues"},{"location":"StacksAndQueues/#stacks","text":"","title":"Stacks"},{"location":"StacksAndQueues/#explanation","text":"Stacks are a type of container adaptor , specifically designed to operate in a LIFO context (last-in first-out) , where elements are inserted and extracted only from one end of the container. The stack class template acts as a wrapper to the underlying container - only a specific set of functions is provided . The stack pushes and pops the element from the back of the underlying container, known as the top of the stack. Their header file is <stack> .","title":"Explanation"},{"location":"StacksAndQueues/#declaration-syntax","text":"std::stack< Type > stack_name; // Not common, not recommend std::stack< Type, Container< Type > > stack_name; std::stack< Type >* stack_ptr;","title":"Declaration Syntax"},{"location":"StacksAndQueues/#initialization-syntax","text":"// Default constructor. Value-initializes the underlying container. std::stack< Type > stack_name; // Initializer list constructor. Container< Type > cont = { ... }; // Copy the content of the `cont`. std::stack< Type, Container< Type > > stack_name( cont ); // Move the content of the underlying container. std::stack< Type, Container< Type > > stack_name( Container< Type >{ ... } ); // Initializer list constructor. std::stack< Type > stack_name1( { ... } ); // Copy constructor. std::stack< Type > stack_name2( stack_name1 ); // Initializer list constructor. std::stack< Type > stack_name1( { ... } ); // Copy constructor. std::stack< Type > stack_name2 = stack_name1; // Initializer list constructor. std::stack< Type > stack_name1( { ... } ); // Move constructor. std::stack< Type > stack_name2( std::move( stack_name1 ) ); // Move the content of the underlying container. std::stack< Type, Container< Type > > stack_name1( Container< Type >{ ... } ); // Constructs the underlying container with the contents of the range `[first, last)`. std::stack< Type, Container< Type > > stack_name2( stack_name1.begin(), stack_name2.end() ); std::stack< Type >* stack_ptr = new std::stack< Type >; std::stack< Type, Container< Type > >* stack_ptr = new std::stack< Type >( Container< Type >{ ... } ); // Initializer list constructor. std::stack< Type > stack_name( { ... } ); std::stack< Type >* stack_ptr = new std::stack< Type >( stack_name ); std::stack< Type >* stack_ptr = new std::stack< Type >( { ... } );","title":"Initialization Syntax"},{"location":"StacksAndQueues/#syntax-for-deleting-stdstack-pointers","text":"delete stack_ptr;","title":"Syntax for Deleting std::stack Pointers"},{"location":"StacksAndQueues/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"StacksAndQueues/#links","text":"std::stack in cplusplus . std::stack in cppreference .","title":"Links"},{"location":"StacksAndQueues/#template-parameters","text":"T : The type of the stored elements. The program is ill-formed if T is not the same type as Container::value_type . Container : The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer . Additionally, it must provide the following functions with the usual semantics: back() , e.g., std::vector::back() , push_back() , e.g., std::deque::push_back() , pop_back() , e.g., std::list::pop_back() . The standard containers std::vector (including std::vector< bool > ), std::deque and std::list satisfy these requirements. By default , if no container class is specified for a particular stack class instantiation, the standard container std::deque is used.","title":"Template Parameters"},{"location":"StacksAndQueues/#member-types","text":"container_type : Container . value_type : Container::value_type . size_type : Container::size_type . reference : Container::reference . const_reference : Container::const_reference .","title":"Member Types"},{"location":"StacksAndQueues/#member-objects","text":"Container c : The underlying container (protected member object).","title":"Member Objects"},{"location":"StacksAndQueues/#member-functions","text":"(constructor): Constructs the stack (public member function). (destructor): Destructs the stack (public member function). operator= : Assigns values to the container adaptor (public member function). top : Accesses the top element (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). push : Inserts element at the top (public member function). push_range (C++23): Inserts a range of elements at the top (public member function). emplace : Constructs element in-place at the top (public member function). pop : Removes the top element (public member function). swap : Swaps the contents (public member function).","title":"Member Functions"},{"location":"StacksAndQueues/#non-member-functions","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two stacks (function template). std::swap( std::stack ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"StacksAndQueues/#helper-classes","text":"std::uses_allocator< std::stack > : Specializes the std::uses_allocator type trait (class template specialization). std::formatter< std::stack > (C++23): Formatting support for std::stack (class template specialization).","title":"Helper Classes"},{"location":"StacksAndQueues/#queues","text":"","title":"Queues"},{"location":"StacksAndQueues/#explanation_1","text":"Queues are a type of container adaptor , specifically designed to operate in a FIFO context (first-in first-out) , where elements are inserted into one end of the container and extracted from the other. The queue class template acts as a wrapper to the underlying container - only a specific set of functions is provided . The queue pushes the elements on the back of the underlying container and pops them from the front. Their header file is <queue> .","title":"Explanation"},{"location":"StacksAndQueues/#declaration-syntax_1","text":"std::queue< Type > queue_name; // Not common, not recommend std::queue< Type, Container< Type > > queue_name; std::queue< Type >* queue_ptr;","title":"Declaration Syntax"},{"location":"StacksAndQueues/#initialization-syntax_1","text":"// Default constructor. Value-initializes the underlying container. std::queue< Type > queue_name; Container< Type > cont = { ... }; // Copy the content of the `cont`. std::queue< Type, Container< Type > > queue_name( cont ); // Move the content of the underlying container. std::queue< Type, Container< Type > > queue_name( Container< Type >{ ... } ); // Initializer list constructor. std::queue< Type > queue_name1( { ... } ); // Copy constructor. std::queue< Type > queue_name2( queue_name1 ); // Initializer list constructor. std::queue< Type > queue_name1( { ... } ); // Copy constructor. std::queue< Type > queue_name2 = queue_name1; // Initializer list constructor. std::queue< Type > queue_name1( { ... } ); // Move constructor. std::queue< Type > queue_name1( std::move( queue_name1 ) ); // Move the content of the underlying container. std::queue< Type, Container< Type > > queue_name1( Container< Type >{ ... } ); // Constructs the underlying container with the contents of the range `[first, last)`. std::queue< Type, Container< Type > > queue_name2( queue_name1.begin(), queue_name2.end() ); std::queue< Type >* queue_ptr = new std::queue< Type >; std::queue< Type, Container< Type > >* queue_ptr = new std::queue< Type >( Container< Type >{ ... } ); // Initializer list constructor. std::queue< Type > queue_name( { ... } ); std::queue< Type >* queue_ptr = new std::queue< Type >( queue_name ); std::queue< Type >* queue_ptr = new std::queue< Type >( { ... } );","title":"Initialization Syntax"},{"location":"StacksAndQueues/#syntax-for-deleting-stdqueue-pointers","text":"delete queue_ptr;","title":"Syntax for Deleting std::queue Pointers"},{"location":"StacksAndQueues/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"StacksAndQueues/#links_1","text":"std::queue in cplusplus . std::queue in cppreference .","title":"Links"},{"location":"StacksAndQueues/#template-parameters_1","text":"T : The type of the stored elements. The program is ill-formed if T is not the same type as Container::value_type . Container : The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer . Additionally, it must provide the following functions with the usual semantics: back() , e.g., std::deque::back() , front() , e.g. std::list::front() , push_back() , e.g., std::deque::push_back() , pop_front() , e.g., std::list::pop_front() . The standard containers std::deque and std::list satisfy these requirements.","title":"Template Parameters"},{"location":"StacksAndQueues/#member-types_1","text":"container_type : Container . value_type : Container::value_type . size_type : Container::size_type . reference : Container::reference . const_reference : Container::const_reference .","title":"Member Types"},{"location":"StacksAndQueues/#member-objects_1","text":"Container c : The underlying container (protected member object).","title":"Member Objects"},{"location":"StacksAndQueues/#member-functions_1","text":"(constructor): Constructs the queue (public member function). (destructor): Destructs the queue (public member function). operator= : Assigns values to the container adaptor (public member function). front : Access the first element (public member function). back : Access the last element (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). push : Inserts element at the end (public member function). push_range (C++23): Inserts a range of elements at the end (public member function). emplace : Constructs element in-place at the end (public member function). pop : Removes the first element (public member function). swap : Swaps the contents (public member function).","title":"Member Functions"},{"location":"StacksAndQueues/#non-member-functions_1","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two queues (function template). std::swap( std::queue ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"StacksAndQueues/#helper-classes_1","text":"std::uses_allocator< std::queue > : Specializes the std::uses_allocator type trait (class template specialization). std::formatter< std::queue > (C++23): Formatting support for std::queue (class template specialization).","title":"Helper Classes"},{"location":"StacksAndQueues/#priority-queues","text":"","title":"Priority Queues"},{"location":"StacksAndQueues/#explanation_2","text":"Priority queues are a type of container adaptors , specifically designed such that its first element is always the largest of the elements it contains , according to some strict weak ordering criterion . A user-provided Compare can be supplied to change the ordering , e.g. using std::greater< T > would cause the smallest element to appear as the top() . This context is similar to a heap , where elements can be inserted at any moment , and only the max heap element can be retrieved (the one at the top in the priority queue). The priority queue class template acts as a wrapper to the underlying container - only a specific set of functions is provided . Their header file is <queue> .","title":"Explanation"},{"location":"StacksAndQueues/#declaration-syntax_2","text":"std::priority_queue< Type > pqueue_name; // Not common, not recommend std::priority_queue< Type, Container< Type > > pqueue_name; // Not common, not recommend class Compare { bool _reverse; public: explicit Compare( const bool& rev_param = false ) { _reverse = rev_param; }; bool operator()( const Type& lhs, const Type& rhs ) const { if( _reverse ) { ...; } else { ...; }; }; }; std::priority_queue< Type, Container< Type >, Compare > pqueue_name; std::priority_queue< Type, std::vector< Type >, Compare > pqueue_name; std::priority_queue< Type >* pri_queue_ptr;","title":"Declaration Syntax"},{"location":"StacksAndQueues/#initialization-syntax_2","text":"// Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name; // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type, Container< Type >, Compare > pqueue_name; // Copy-constructs the temporary `Compare` class object. Value-initializes the underlying container. std::priority_queue< Type, Container< Type >, Compare > rpqueue_name( Compare( true ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; std::priority_queue< Type, Container< Type >, Compare > pqueue_name( comp ); Compare comp; Container< Type > cont = { ... }; // Copy the content of the `comp` and the `cont`. std::priority_queue< Type, Container< Type >, Compare > pqueue_name( cont, comp ); Compare comp; // Move the content of the underlying container. // Copy the content of the `comp`. std::priority_queue< Type, Container< Type >, Compare > pqueue_name( Container< Type >{ ... }, comp ); // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name1; // Copy constructor. std::priority_queue< Type > pqueue_name2( pqueue_name1 ); // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name1; // Copy constructor. std::priority_queue< Type > pqueue_name2 = pqueue_name1; // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name1; // Move constructor. std::priority_queue< Type > pqueue_name2( std::move( pqueue_name1 ) ); // Copy-constructs the comparison functor `comp` with the contents of compare. Value-initializes the underlying container. Compare comp; Container< Type > cont = { ... }; std::priority_queue< Type, Container< Type >, Compare > pqueue_name1( comp, cont ); // Constructs the underlying container with the contents of the range `[first, last)`. std::priority_queue< Type, Container< Type >, Compare > pqueue_name2( pqueue_name1.begin(), pqueue_name1.end(), comp /* optional */, cont /* optional */ ); std::priority_queue< Type >* pri_queue_ptr = new std::priority_queue< Type >; // Default constructor. Value-initializes the comparator and the underlying container. std::priority_queue< Type > pqueue_name; std::priority_queue< Type >* pri_queue_ptr = new std::priority_queue< Type >( pqueue_name );","title":"Initialization Syntax"},{"location":"StacksAndQueues/#syntax-for-deleting-stdpriority_queue-pointers","text":"delete pri_queue_ptr;","title":"Syntax for Deleting std::priority_queue Pointers"},{"location":"StacksAndQueues/#members-and-related-stuffs_2","text":"","title":"Members and Related Stuffs"},{"location":"StacksAndQueues/#links_2","text":"std::priority_queue in cplusplus . std::priority_queue in cppreference .","title":"Links"},{"location":"StacksAndQueues/#template-parameters_2","text":"T : The type of the stored elements. The program is ill-formed if T is not the same type as Container::value_type . Container : The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer , and its iterators must satisfy the requirements of LegacyRandomAccessIterator . Additionally, it must provide the following functions with the usual semantics: front() , e.g., std::vector::front() , push_back() , e.g., std::deque::push_back() , pop_back() , e.g., std::vector::pop_back() . The standard containers std::vector (including std::vector< bool > ) and std::deque satisfy these requirements. Compare : A Compare type providing a strict weak ordering. By default, the first key (largest key) is at the top of the queue because its underlying structure is a max-heap, which uses std::less< T > to maintain that structure, ensuring the largest element is accessible first.","title":"Template Parameters"},{"location":"StacksAndQueues/#member-types_2","text":"container_type : Container . value_compare : Compare . value_type : Container::value_type . size_type : Container::size_type . reference : Container::reference . const_reference : Container::const_reference .","title":"Member Types"},{"location":"StacksAndQueues/#member-objects_2","text":"Container c : The underlying container (protected member object). Compare comp : The comparison function object (protected member object).","title":"Member Objects"},{"location":"StacksAndQueues/#member-functions_2","text":"(constructor): Constructs the priority_queue (public member function). (destructor): Destructs the priority_queue (public member function). operator= : Assigns values to the container adaptor (public member function). top : Accesses the top element (public member function). empty : Checks whether the container adaptor is empty (public member function). size : Returns the number of elements (public member function). push : Inserts element and sorts the underlying container (public member function). push_range (C++23): Inserts a range of elements and sorts the underlying container (public member function). emplace : Constructs element in-place and sorts the underlying container (public member function). pop : Removes the top element (public member function). swap : Swaps the contents (public member function).","title":"Member Functions"},{"location":"StacksAndQueues/#non-member-functions_2","text":"std::swap( std::priority_queue ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"StacksAndQueues/#helper-classes_2","text":"std::uses_allocator< std::priority_queue > : Specializes the std::uses_allocator type trait (class template specialization). std::formatter< std::priority_queue > (C++23): Formatting support for std::priority_queue (class template specialization).","title":"Helper Classes"},{"location":"StacksAndQueues/#deques-double-ended-queue-deck","text":"","title":"Deques (Double-ended Queue) (Deck)"},{"location":"StacksAndQueues/#explanation_3","text":"Deques are sequence containers (template classes) with dynamic sizes that can be expanded or contracted on both ends (either its front or its back). They allow for the individual elements to be accessed directly through random access iterators , with storage handled automatically by expanding and contracting the container as needed. They provide a functionality similar to vectors , but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end . But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations : accessing elements in a deque by offsetting a pointer to another element causes undefined behavior . Their header file is <deque> .","title":"Explanation"},{"location":"StacksAndQueues/#declaration-syntax_3","text":"std::deque< Type > deque_name; std::deque< Type >* deque_ptr;","title":"Declaration Syntax"},{"location":"StacksAndQueues/#initialization-syntax_3","text":"// Initializer deque constructor. std::deque< Type > deque_name = { ... }; // Initializer deque constructor. std::deque< Type > deque_name{ ... }; // No initialization, contain garbage values and behave unpredictably. std::deque< Type > deque_name; // No initialization, contain garbage values and behave unpredictably. std::deque< Type > deque_name( size ); // Initialization with the specific value. std::deque< Type > deque_name( size, value ); // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Copy constructor. std::deque< Type > deque_name2( deque_name1 ); // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Copy constructor. std::deque< Type > deque_name2 = deque_name1; // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Move constructor. std::deque< Type > deque_name2 = std::move( deque_name1 ); // Initializer deque constructor. std::deque< Type > deque_name1 = { ... }; // Constructs the underlying container with the contents of the range `[first, last)`. std::deque< Type, Container< Type > > deque_name2( deque_name1.begin(), deque_name2.end() ); std::deque< Type >* deque_ptr = new std::deque< Type >( size ); std::deque< Type >* deque_ptr = new std::deque< Type >( size, value ); // Initializer deque constructor. std::deque< Type > deque_name = { ... }; std::deque< Type >* deque_ptr = new std::deque< Type >( deque_name ); std::deque< Type >* deque_ptr = new std::deque< Type >{ ... };","title":"Initialization Syntax"},{"location":"StacksAndQueues/#syntax-for-deleting-stddeque-pointers","text":"delete deque_ptr;","title":"Syntax for Deleting std::deque Pointers"},{"location":"StacksAndQueues/#members-and-related-stuffs_3","text":"","title":"Members and Related Stuffs"},{"location":"StacksAndQueues/#links_3","text":"std::deque in cplusplus . std::deque in cppreference .","title":"Links"},{"location":"StacksAndQueues/#template-parameters_3","text":"T : The type of the elements. Allocator : An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory.","title":"Template Parameters"},{"location":"StacksAndQueues/#member-types_3","text":"value_type : T . allocator_type : Allocator . size_type : Unsigned integer type (usually std::size_t ). difference_type : Signed integer type (usually std::ptrdiff_t ). reference : value_type& . const_reference : const value_type& . pointer : Allocator::pointer (until C++11), std::allocator_traits< Allocator >::pointer (since C++11). const_pointer : Allocator::const_pointer (until C++11), std::allocator_traits< Allocator >::const_pointer (since C++11). iterator : LegacyBidirectionalIterator to value_type . const_iterator : LegacyBidirectionalIterator to const value_type . reverse_iterator : std::reverse_iterator< iterator > . const_reverse_iterator : std::reverse_iterator< const_iterator > .","title":"Member Types"},{"location":"StacksAndQueues/#member-functions_3","text":"(constructor): Constructs the deque (public member function). (destructor): Destructs the deque (public member function). operator= : Assigns values to the container (public member function). assign : Assigns values to the container (public member function). assign_range (C++23): Assigns a range of values to the container (public member function). get_allocator : Returns the associated allocator (public member function). at : Access specified element with bounds checking (public member function). operator[] : Access specified element (public member function). front : Access the first element (public member function). back : Access the last element (public member function). begin , cbegin : Returns an iterator to the beginning (public member function). end , cend : Returns an iterator to the end (public member function). rbegin , crbegin : Returns a reverse iterator to the beginning (public member function). rend , crend : Returns a reverse iterator to the end (public member function). empty : Checks whether the container is empty (public member function). size : Returns the number of elements (public member function). max_size : Returns the maximum possible number of elements (public member function). shrink_to_fit ( DR* ): Reduces memory usage by freeing unused memory (public member function). clear : Clears the contents (public member function). insert : Inserts elements (public member function). insert_range (C++23): Inserts a range of elements (public member function). emplace : Constructs elements in-place (public member function). erase : Erases elements and returns a valid iterator (public member function). push_back : Adds an element to the end (public member function). emplace_back : Constructs an element in-place at the end (public member function). append_range (C++23): Adds a range of elements to the end (public member function). pop_back : Removes the last element (public member function). push_front : Inserts an element to the beginning (public member function). emplace_front : Constructs an element in-place at the beginning (public member function). prepend_range (C++23): Adds a range of elements to the beginning (public member function). pop_front : Removes the first element (public member function). resize : Changes the number of elements stored (public member function). swap : Swaps the contents (public member function).","title":"Member Functions"},{"location":"StacksAndQueues/#non-member-functions_3","text":"operator== , operator!=/<!--<=/-->/>= (removed in C++20), operator<=> (C++20): Lexicographically compares the values of two deques (function template). std::swap( std::deque ) : Specializes the std::swap algorithm (function template). erase( std::deque ) (C++20), erase_if( std::deque ) (C++20): Erases all elements satisfying specific criteria (function template).","title":"Non-member Functions"},{"location":"StaticAssert/","text":"static_assert Explanation Syntax static_assert Explanation static_assert is a compile-time assertion that allows you to check conditions during compilation rather than at runtime. If the condition evaluates to false , a compilation error is generated, helping you catch issues early in the development process. The condition must be a compile-time constant expression . Syntax static_assert(condition, \"Error message\");","title":"static_assert"},{"location":"StaticAssert/#static_assert","text":"","title":"static_assert"},{"location":"StaticAssert/#explanation","text":"static_assert is a compile-time assertion that allows you to check conditions during compilation rather than at runtime. If the condition evaluates to false , a compilation error is generated, helping you catch issues early in the development process. The condition must be a compile-time constant expression .","title":"Explanation"},{"location":"StaticAssert/#syntax","text":"static_assert(condition, \"Error message\");","title":"Syntax"},{"location":"StdBindAndStdFunction/","text":"std::bind Explanation Syntax Usage Links std::function Explanation Syntax Usage Links std::bind Explanation std::bind is a function adapter in C++ that allows you to create a callable object by binding one or more arguments to a function or function object. It is part of the <functional> header and provides a way to create a new function that can be invoked with a specific set of arguments, while leaving some arguments unbound. std::bind is useful when you need to adapt a function to match a specific signature for algorithms or event-driven programming. It can also be used to create a function that calls another function with a fixed set of arguments, reducing the need to repeatedly pass those arguments. Syntax // (1) (since C++11) (constexpr since C++20). template< class F, class... Args > /* unspecified */ bind( F&& f, Args&&... args ); // (2) (since C++11) (constexpr since C++20). template< class R, class F, class... Args > /* unspecified */ bind( F&& f, Args&&... args ); Usage Partial function application: CPP RetType funName( Type1 para1, Type2 para2, ... ) { ...; }; Type2 arg2; auto boundName = std::bind( funName, arg2, std::placeholders::_1, ... ); Working with callbacks or functional interfaces: CPP RetType funName( Type1 para1, Type2 para2, ... ) { ...; }; auto boundName = std::bind( funName, arg1, arg2, ... ); std::thread thread_name( boundName ); Binding member functions: CPP class ClassName { public: RetType funcName( Type1 para1, ... ) const { ...; }; }; int main() { ClassName obj_name; auto boundName = std::bind( &ClassName::funcName, obj_name, arg1, ... ); boundName(); return 0; }; Reordering arguments: CPP RetType funcName( Type1 para1, Type2 para2, ... ) { ...; }; int main() { auto boundName = std::bind( funcName, std::placeholders::_2, std::placeholders::_1, ... ); boundName( arg2, arg1 ); }; Avoiding verbose lambda expressions. Compatibility with legacy code: std::bind1st/std::bind2nd (from C++98). Links std::bind in cplusplus . std::bind in cppreference . std::function Explanation std::function is a template class in C++ that provides a type-safe wrapper for any callable entity, including functions, function pointers, and function objects. It is part of the header and allows you to store and invoke callable objects with a specific signature. std::function is useful for scenarios where you need to store or pass around functions as first-class objects, such as callback functions, event handlers, or when working with algorithms that require generic function signatures. For high-performance code where overhead is a concern, function pointers or direct calls may be more suitable. Syntax // (1) (since C++11). template< class > class function; /* undefined */ // (2) (since C++11). template< class R, class... Args > class function< R( Args... ) >; Usage Type-erased function wrapper: CPP RetType funcName( Type1 para1, Type2 para2, ... ) { ...; }; int main() { std::function< RetType( Type1, Type2, ... ) > func = funcName; func(); // Calls funcName(). }; Storing different types of callables: CPP RetType funcName1() { ...; }; struct FuncName2 { RetType operator()( ... ) const { ...; }; }; int main() { std::function< RetType( ... ) > f1 = funcName1; // Function pointer. std::function< RetType( ... ) > f2 = FuncName2( ... ); // Functor. std::function< RetType( ... ) > f3 = [...]( ... ) { // Lambda. ...; }; f1(); // Calls funcName1. f2(); // Calls FuncName2(). f3(); // Calls the lambda. return 0; }; Use in callbacks and event handlers. Memory and performance considerations: Dynamic memory allocation. Function composition and higher-order functions. Use in containers. Flexible function signatures. Passing functions as arguments. Using std::function with member functions: CPP class ClassName { public: RetType funcName( Type1 para1, Type2 para2, ... ) const { ...; }; }; int main() { ClassName obj_name; std::function< RetType( const ClassName&, Type1, Type2, ... ) > obj_nameFunc = &ClassName::funcName; obj_nameFunc( obj_name, arg1, arg2, ... ); }; Links std::function in cplusplus . std::function in cppreference .","title":"std::bind and std::function"},{"location":"StdBindAndStdFunction/#stdbind","text":"","title":"std::bind"},{"location":"StdBindAndStdFunction/#explanation","text":"std::bind is a function adapter in C++ that allows you to create a callable object by binding one or more arguments to a function or function object. It is part of the <functional> header and provides a way to create a new function that can be invoked with a specific set of arguments, while leaving some arguments unbound. std::bind is useful when you need to adapt a function to match a specific signature for algorithms or event-driven programming. It can also be used to create a function that calls another function with a fixed set of arguments, reducing the need to repeatedly pass those arguments.","title":"Explanation"},{"location":"StdBindAndStdFunction/#syntax","text":"// (1) (since C++11) (constexpr since C++20). template< class F, class... Args > /* unspecified */ bind( F&& f, Args&&... args ); // (2) (since C++11) (constexpr since C++20). template< class R, class F, class... Args > /* unspecified */ bind( F&& f, Args&&... args );","title":"Syntax"},{"location":"StdBindAndStdFunction/#usage","text":"Partial function application: CPP RetType funName( Type1 para1, Type2 para2, ... ) { ...; }; Type2 arg2; auto boundName = std::bind( funName, arg2, std::placeholders::_1, ... ); Working with callbacks or functional interfaces: CPP RetType funName( Type1 para1, Type2 para2, ... ) { ...; }; auto boundName = std::bind( funName, arg1, arg2, ... ); std::thread thread_name( boundName ); Binding member functions: CPP class ClassName { public: RetType funcName( Type1 para1, ... ) const { ...; }; }; int main() { ClassName obj_name; auto boundName = std::bind( &ClassName::funcName, obj_name, arg1, ... ); boundName(); return 0; }; Reordering arguments: CPP RetType funcName( Type1 para1, Type2 para2, ... ) { ...; }; int main() { auto boundName = std::bind( funcName, std::placeholders::_2, std::placeholders::_1, ... ); boundName( arg2, arg1 ); }; Avoiding verbose lambda expressions. Compatibility with legacy code: std::bind1st/std::bind2nd (from C++98).","title":"Usage"},{"location":"StdBindAndStdFunction/#links","text":"std::bind in cplusplus . std::bind in cppreference .","title":"Links"},{"location":"StdBindAndStdFunction/#stdfunction","text":"","title":"std::function"},{"location":"StdBindAndStdFunction/#explanation_1","text":"std::function is a template class in C++ that provides a type-safe wrapper for any callable entity, including functions, function pointers, and function objects. It is part of the header and allows you to store and invoke callable objects with a specific signature. std::function is useful for scenarios where you need to store or pass around functions as first-class objects, such as callback functions, event handlers, or when working with algorithms that require generic function signatures. For high-performance code where overhead is a concern, function pointers or direct calls may be more suitable.","title":"Explanation"},{"location":"StdBindAndStdFunction/#syntax_1","text":"// (1) (since C++11). template< class > class function; /* undefined */ // (2) (since C++11). template< class R, class... Args > class function< R( Args... ) >;","title":"Syntax"},{"location":"StdBindAndStdFunction/#usage_1","text":"Type-erased function wrapper: CPP RetType funcName( Type1 para1, Type2 para2, ... ) { ...; }; int main() { std::function< RetType( Type1, Type2, ... ) > func = funcName; func(); // Calls funcName(). }; Storing different types of callables: CPP RetType funcName1() { ...; }; struct FuncName2 { RetType operator()( ... ) const { ...; }; }; int main() { std::function< RetType( ... ) > f1 = funcName1; // Function pointer. std::function< RetType( ... ) > f2 = FuncName2( ... ); // Functor. std::function< RetType( ... ) > f3 = [...]( ... ) { // Lambda. ...; }; f1(); // Calls funcName1. f2(); // Calls FuncName2(). f3(); // Calls the lambda. return 0; }; Use in callbacks and event handlers. Memory and performance considerations: Dynamic memory allocation. Function composition and higher-order functions. Use in containers. Flexible function signatures. Passing functions as arguments. Using std::function with member functions: CPP class ClassName { public: RetType funcName( Type1 para1, Type2 para2, ... ) const { ...; }; }; int main() { ClassName obj_name; std::function< RetType( const ClassName&, Type1, Type2, ... ) > obj_nameFunc = &ClassName::funcName; obj_nameFunc( obj_name, arg1, arg2, ... ); };","title":"Usage"},{"location":"StdBindAndStdFunction/#links_1","text":"std::function in cplusplus . std::function in cppreference .","title":"Links"},{"location":"Structures/","text":"Structures ( struct ) Explanation Differences Between Structures and Classes Notes Structures ( struct ) Explanation Structures are user-defined data types that group variables of different types into a single unit. They are particularly useful when managing related data. While structures originated from the C language, C++ enhances them by allowing member functions, constructors, and even inheritance . The struct keyword is used to define a structure. Differences Between Structures and Classes Default access level: public (structure), private (class). Usage preference: For simple data models (structure), For complex abstractions (class). Inheritance: public by default (structure), Private by default (class). Encapsulation: Less restrictive by design (structure), Promotes encapsulation (class). Notes Except for the four differences mentioned above, the functions provided by structures are the same as those in classes. When using structures, you should treat them like in C code, not as classes .","title":"Structures"},{"location":"Structures/#structures-struct","text":"","title":"Structures (struct)"},{"location":"Structures/#explanation","text":"Structures are user-defined data types that group variables of different types into a single unit. They are particularly useful when managing related data. While structures originated from the C language, C++ enhances them by allowing member functions, constructors, and even inheritance . The struct keyword is used to define a structure.","title":"Explanation"},{"location":"Structures/#differences-between-structures-and-classes","text":"Default access level: public (structure), private (class). Usage preference: For simple data models (structure), For complex abstractions (class). Inheritance: public by default (structure), Private by default (class). Encapsulation: Less restrictive by design (structure), Promotes encapsulation (class).","title":"Differences Between Structures and Classes"},{"location":"Structures/#notes","text":"Except for the four differences mentioned above, the functions provided by structures are the same as those in classes. When using structures, you should treat them like in C code, not as classes .","title":"Notes"},{"location":"Templates/","text":"Templates Explanation Order of Parameters in the Parameter List Limitations of Template Default Types and Values Explicit Instantiation Implicit Instantiation ( Common Instantiation ) Function Templates Explanation Syntax Class Templates or Struct Templates Explanation Syntax Template Specialization Explanation Full specialization Explanation Syntax Partial Specialization (Partial Parameters) Explanation Syntax Variadic Templates (Template Packs) Explanation Common Syntax Link Template Parameters with Non-type Parameters Explanation Syntax Constraints and Concepts Explanation Links SFINAE (Substitution Failure Is Not An Error) Explanation Syntax Type Traits Explanation Syntax Template Aliases Universial References (Forward References) Templates Explanation Templates are C++ entities that use the template keyword to define and use the typename or the class keyword to speficy a generic type . Template parameters cannot be references or pointers . Template parameters must be either types (e.g., class T , typename T ) or values (e.g., int N ) . All type parameters can be bound to default types , and all non-type parameters can be bound to default values . Templates empower developers to write generic and reusable code . By enabling functions and classes to operate on arbitrary data types , templates facilitate enhanced flexibility and type safety in programming. They do not exist , and the compiler does not create them , and some compilers do not detect its syntax until they are called . At compile time, the compiler create and detect them. Because templates exist and are compiled only for specific types when instantiated , they can be declared and defined in header files . Order of Parameters in the Parameter List For function templates , there is no specific order for parameters in the parameter list. Type or non-type parameters, whether they have default types or values, and parameter packs can be placed anywhere in the list. However, for class templates , there is a specific order : All parameters without default types or values must be placed at the beginning of the parameter list. All parameters with default types or values must be specified at the end of the parameter list, but before any parameter packs. All parameter packs must be placed at the end of the parameter list. Better orders : Type parameters without default types, non-type parameters without default values, type parameters with default types, non-type parameters with default values, and parameter packs . Non-type parameters without default values, type parameters without default types, non-type parameters with default values, type parameters with default types, and parameter packs. Limitations of Template Default Types and Values Order of parameters : It is not permissible to omit a parameter with a default value if one intends to provide values for later parameters . Dependent names : Default template parameters cannot depend on other template parameters . A template parameter cannot be utilized to define the default value of another template parameter. Ambiguity in overloading : The use of default template parameters in function overloading may lead to ambiguity. If multiple templates can potentially match a call due to the presence of default arguments, the compiler may encounter difficulty in determining which template to invoke. Inheritance and template defaults : In derived template classes , the default arguments inherited from the base class cannot be modified . It is necessary to explicitly specify the types in the derived class. Specialization limitations : Template specializations are unable to alter default template parameters . If a specialization employs a different type or value, it must explicitly define those parameters. Explicit Instantiation The explicit instantiation refers to the deliberate and formal creation of a specific instance of a template with a particular type, as specified by the programmer. It works similarly to declaring a template with specific types and then using it . This is done using the template keyword followed by the instantiation of the template with the desired type. This mechanism is primarily used to control when and where a template is instantiated, particularly in larger codebases where managing template definitions and instances can become complex. Implicit Instantiation ( Common Instantiation ) The implicit instantiation refers to the automatic creation of a template instance by the compiler when a template is used with a specific type, without requiring explicit instantiation by the programmer. It works similarly to using a template directly with specific types, without any prior declaration . Function Templates Explanation Function templates allow for the definition of functions that can operate with any data type . This capability reduces code duplication and enhances type safety , as the compiler can automatically generate type-specific implementations based on the provided template parameters. Syntax // Definition syntax. template< typename T1, typename T2, ... > T1 funcName( T2 arg1, ... ) { // Function implementation. }; // Usage syntax, explicit instantitaion syntax. template Type funcName( ... ); // Usage syntax, explicit instantitaion syntax. template Type funcName<>( ... ); // Usage syntax, explicit instantitaion syntax. template Type funcName< ... >( ... ); // Usage syntax, implicit instantitaion syntax. Type result = funcName( ... ); // Usage syntax, implicit instantitaion syntax. Type result = funcName<>( ... ); // Usage syntax, implicit instantitaion syntax. Type result = funcName< ... >( ... ); Class Templates or Struct Templates Explanation Class templates or struct templates enable the creation of classes or structs that can manage various data types . This feature is particularly advantageous for implementing data structures such as lists, stacks, and queues , where the type of data may vary . Syntax // With explicit instantiation. namespace SpaceName { // Definition Syntax. template< class T, ... > class ClassName { RetType funcName( ... ) { // Do something. }; }; }; // namespace SpaceName. // Usage syntax, instantiation syntax. // template class ClassName<int>; // error: class template ClassName not visible in the global namespace. using SpaceName::ClassName; // template class ClassName<int>; // error: explicit instantiation outside of the namespace of the template. template class SpaceName::ClassName< Type, ... >; // OK: explicit instantiation. template RetType SpaceName::ClassName< Type, ... >::funcName( ... ); // OK: explicit instantiation. // With implicit instantiation. // Definition Syntax. template< class T, ... > struct StructName { }; // Usage syntax, instantiation syntax. template struct StructName< Type, ... >; // Explicit instantiation of StructName< Type >. StructName< Type, ... > obj; // Implicit instantiation of StructName< Type >. Template Specialization Explanation Template specialization allows for the definition of a specific implementation of a template for a particular data type to meet specific conditions . However, they do not allow more than one specialization for the same type parameters . The compiler will throw an error if multiple specializations that match the same signature are declared. This feature is useful when the generic implementation requires adjustment for certain types to enhance functionality or performance . Full specialization Explanation In full specialization , it is imperative to specify all template parameters explicitly . For instance, if your template accepts two parameters, both must be explicitly defined in the specialization. Syntax // Definition syntax. template< para_list > class ClassName { // Implementation. }; // Full specialization for `arg_list2`. template<> class ClassName< arg_list2 > { // Another implementation. }; // Usage syntax. ClassName< arg_list1 > obj1; // Utilizes the generic version. ClassName< arg_list2 > obj2; // Utilizes the specialized version. Partial Specialization (Partial Parameters) Explanation In partial specialization , it is permissible to leave some template parameters unspecified , allowing them to remain generic . The names of the unspecified template parameters do not need to remain the same as before , except for their remaining quantity . This flexibility is advantageous for providing specialized behavior tailored to specific categories of types . Syntax // Definition syntax. template< para_list1 > class ClassName { // Implementation. }; // Partial specialization for `arg_list3`. template< para_list2 > class ClassName< arg_list3 > { // Another implementation. }; // Usage syntax. ClassName< arg_list1 > obj1; // Utilizes the generic version. ClassName< arg_list2, arg_list3 > obj2; // Utilizes the specialized version. // Definition syntax. template< typename T1, typename T2, ... > class ClassName { // Implementation. }; // Partial specialization for generic reference types. template< typename T1, typename T2, ... > class ClassName< T1&, T2&, ... > { // Another implementation. }; // Definition syntax. template< typename T1, typename T2, ... > class ClassName { // Implementation. }; // Partial specialization for generic pointer types. template< typename T1, typename T2, ... > class ClassName< T1*, T2*, ... > { // Another implementation. }; // Definition syntax. template< typename T, typename... Args > class ClassName { // Implementation. }; // Partial specialization for function types. template< typename T, typename... Args > class ClassName< T(... Args) > { // Another implementation. }; Variadic Templates (Template Packs) Explanation Variadic templates are templates that contain at least one parameter pack . A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). The common way to store the arguments of a template parameter pack and access them is by using std::tuple and std::get . This feature is beneficial for functions that need to handle a flexible number of arguments , thereby enhancing versatility. For a function template , multiple parameter packs can be defined, while a class template can only have one . For a function template , a template parameter pack can automatically deduce types and the types are not explicitly specified when the function is called. However, for a class template (such as std::tuple or std::vector ), the types must be explicitly specified because template parameter packs are typically not deduced in class templates. Common Syntax #include <iostream> #include <tuple> // Be mindful of the Ellipsis. template< typename... Args > class ClassName { public: // explicit ClassName( Args&... args ): // explicit ClassName( Args&&... args ): explicit ClassName( Args... args ): _mem( args... ), _mem_ptr( &args... ) { // Method to print all arguments in order without adding any extra characters. ( std::cout << ... << args ) << std::endl; // Method to print all arguments'addresses in order without adding any extra characters. ( std::cout << ... << &args ) << std::endl; // Method to print all ++arguments in order without adding any extra characters. ( std::cout << ... << ++args ) << std::endl; // Method to add all arguments in order and print the result. std::cout << ( ... + args ) << std::endl; // Method to multiple all arguments in order and print the result. std::cout << ( ... * args ) << std::endl; // Method to && all arguments in order and print the result. std::cout << ( ... && args ) << std::endl; // Method to || all arguments in order and print the result. std::cout << ( ... || args ) << std::endl; }; // Method to get an element by index. template< std::size_t Index > decltype( auto ) get() { return std::get< Index >( _mem ); }; // Others. private: std::tuple< Args... > _mem; // Store arguments in a tuple. std::tuple< Args*... > _mem_ptr; // Store arguments's addresses in a tuple. // Others }; int main() { ClassName< ArgType1, ArgType2, ArgType3, /* and so on */ > obj( arg1, arg2, arg3, /* and so on */ ); // Access specific elements by index. std::cout << \"First element: \" << obj.get< 0 >() << std::endl; // arg1. std::cout << \"Second element: \" << obj.get< 1 >() << std::endl; // arg2. std::cout << \"Third element: \" << obj.get< 2 >() << std::endl; // arg3. // Others. return 0; }; Link parameter packs in cplusplus . parameter packs in cppreference . Template Parameters with Non-type Parameters Explanation Template parameters can include non-type parameters , which are constants of integral or enumeration types, pointers, references, or even certain types of non-type template parameters. This feature allows you to create templates that are more flexible and capable of handling specific values alongside types , enabling additional control over template behavior and structure . Syntax // Definition syntax. template< typename T, ..., Type N, ... > class ClassName { ...; }; // Usage syntax. ClassName< TType, ..., val, ... > var_name; Constraints and Concepts Explanation Class templates, function templates, and non-template functions (typically members of class templates) might be associated with a constraint , which specifies the requirements on template arguments , which can be used to select the most appropriate function overloads and template specializations . Named sets of such requirements are called concepts . Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint: Links constraints and concepts in cplusplus . constraints and concepts in cppreference . SFINAE (Substitution Failure Is Not An Error) Explanation It is a principle that allows template substitutions to fail and may still result in a compilation error \u2014 but it is not treated as an error in the context of template instantiation. This is useful for enabling or disabling templates based on certain conditions . std::enable_if is a common tool for implementing SFINAE, there are other techniques and constructs that can also be used, such as function overloading, template specialization, type traits, constraints and concepts in templates, and more. If a function template cannot be instantiated due to type mismatches, the compiler simply ignores that overload instead of producing an error. If a template specialization cannot be matched, it will not result in an error but rather allow the compiler to try other template. Its declaration syntax: CPP template< bool B, class T = void > struct enable_if; // It has a public member typedef `type`, equal to `T`. Its implementation syntax: CPP template< bool B, class T = void > struct enable_if {}; // Primary template. // Partial specialization for the case when B is true. template< class T > struct enable_if< true, T > { using type = T; }; Its helper types: CPP template< bool B, class T = void > using enable_if_t = typename enable_if< B, T >::type; Syntax // With `std::enable_if`. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header `<type_traits>`, // for example, `std::is_integral`. template< typename T, ... > typename std::enable_if< TypeTrait< T, ... >::value >::type funcName( T para, ... ) { // If T, ... meet specific conditions. // Do something. }; template< typename T, ... > typename std::enable_if< !TypeTrait< T >::value >::type funcName( T para, ... ) { // If T is not a specific type. // Do something. }; // With `std::enable_if`. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header `<type_traits>`, // for example, `std::is_integral`. template< typename T, typename std::enable_if< TypeTrait< T, ... >::value >::type, ... > RetType funcName( T para, ... ) { // If T, ... meet specific conditions. // Do something. }; template< typename T, typename std::enable_if< !TypeTrait< T >::value >::type, ... > RetType funcName( T para, ... ) { // If T is not a specific type. // Do something. }; // With constraints and concepts. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header <type_traits>, // for example, std::is_integral template< typename T, ... > concept TempName = TypeTrait< T, ... >; template< TempName T, ... > RetType funcName( T para, ... ) { // This function is only enabled for specific conditions }; Type Traits Explanation Type traits are a set of template classes (or structures or functions even with the constexpr keyword) provided by the C++ Standard Library that allow you to query and manipulate type information at compile time . They can be combined with various techniques used to complete evaluations at compile time , such as static const , constexpr , templates , std::enable_if , static_assert , and more. All type traits are in the header <type_traits> . Syntax // Using templates and `static_assert` to implement a type trait. template< typename T > struct IsPointer { static const bool val = false; // Default case. }; template< typename T > struct IsPointer< T* > { static const bool val = true; // Specialization for pointers. }; // Usage. static_assert( IsPointer< int* >::val, \"Should be a pointer type\" ); static_assert( !IsPointer< int >::val, \"Should not be a pointer type\" ); // Using a type trait with `static_assert`. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header <type_traits>, // for example, `std::is_integral`. template< typename T, ... > RetType funcName( T t, ... ) { static_assert( TypeTrait< T >::value, \"T must be a specific type\" ); // Do something. }; Template Aliases using Universial References (Forward References) A universal reference is a type of reference in C++ that can bind to both lvalues and rvalues . It is also called a forwarding reference in modern C++ terminology. The term \"universal reference\" is particularly used in the context of template functions . A universal reference typically appears in a template function parameter when the type is declared as T&& but is not a reference type (such as in T&& where T is a template parameter). This is a special case of rvalue reference, which can either bind to: An rvalue (temporary object). An lvalue (persistent object) if it's used in the context of a template. Lvalue reference ( T& ) and rvalue reference ( T&& ) are distinct in C++. But when template type deduction is used, the compiler deduces the right reference type depending on the value category of the argument passed. When an lvalue is passed, T is deduced as Type& , so the universal reference becomes Type& & , which is collapsed to Type& . When an rvalue is passed, T is deduced as Type& , and the universal reference becomes Type& & . Universal references are often used in perfect forwarding , where you want to forward the arguments exactly as received, keeping their value category intact.","title":"Templates"},{"location":"Templates/#templates","text":"","title":"Templates"},{"location":"Templates/#explanation","text":"Templates are C++ entities that use the template keyword to define and use the typename or the class keyword to speficy a generic type . Template parameters cannot be references or pointers . Template parameters must be either types (e.g., class T , typename T ) or values (e.g., int N ) . All type parameters can be bound to default types , and all non-type parameters can be bound to default values . Templates empower developers to write generic and reusable code . By enabling functions and classes to operate on arbitrary data types , templates facilitate enhanced flexibility and type safety in programming. They do not exist , and the compiler does not create them , and some compilers do not detect its syntax until they are called . At compile time, the compiler create and detect them. Because templates exist and are compiled only for specific types when instantiated , they can be declared and defined in header files .","title":"Explanation"},{"location":"Templates/#order-of-parameters-in-the-parameter-list","text":"For function templates , there is no specific order for parameters in the parameter list. Type or non-type parameters, whether they have default types or values, and parameter packs can be placed anywhere in the list. However, for class templates , there is a specific order : All parameters without default types or values must be placed at the beginning of the parameter list. All parameters with default types or values must be specified at the end of the parameter list, but before any parameter packs. All parameter packs must be placed at the end of the parameter list. Better orders : Type parameters without default types, non-type parameters without default values, type parameters with default types, non-type parameters with default values, and parameter packs . Non-type parameters without default values, type parameters without default types, non-type parameters with default values, type parameters with default types, and parameter packs.","title":"Order of Parameters in the Parameter List"},{"location":"Templates/#limitations-of-template-default-types-and-values","text":"Order of parameters : It is not permissible to omit a parameter with a default value if one intends to provide values for later parameters . Dependent names : Default template parameters cannot depend on other template parameters . A template parameter cannot be utilized to define the default value of another template parameter. Ambiguity in overloading : The use of default template parameters in function overloading may lead to ambiguity. If multiple templates can potentially match a call due to the presence of default arguments, the compiler may encounter difficulty in determining which template to invoke. Inheritance and template defaults : In derived template classes , the default arguments inherited from the base class cannot be modified . It is necessary to explicitly specify the types in the derived class. Specialization limitations : Template specializations are unable to alter default template parameters . If a specialization employs a different type or value, it must explicitly define those parameters.","title":"Limitations of Template Default Types and Values"},{"location":"Templates/#explicit-instantiation","text":"The explicit instantiation refers to the deliberate and formal creation of a specific instance of a template with a particular type, as specified by the programmer. It works similarly to declaring a template with specific types and then using it . This is done using the template keyword followed by the instantiation of the template with the desired type. This mechanism is primarily used to control when and where a template is instantiated, particularly in larger codebases where managing template definitions and instances can become complex.","title":"Explicit Instantiation"},{"location":"Templates/#implicit-instantiation-common-instantiation","text":"The implicit instantiation refers to the automatic creation of a template instance by the compiler when a template is used with a specific type, without requiring explicit instantiation by the programmer. It works similarly to using a template directly with specific types, without any prior declaration .","title":"Implicit Instantiation (Common Instantiation)"},{"location":"Templates/#function-templates","text":"","title":"Function Templates"},{"location":"Templates/#explanation_1","text":"Function templates allow for the definition of functions that can operate with any data type . This capability reduces code duplication and enhances type safety , as the compiler can automatically generate type-specific implementations based on the provided template parameters.","title":"Explanation"},{"location":"Templates/#syntax","text":"// Definition syntax. template< typename T1, typename T2, ... > T1 funcName( T2 arg1, ... ) { // Function implementation. }; // Usage syntax, explicit instantitaion syntax. template Type funcName( ... ); // Usage syntax, explicit instantitaion syntax. template Type funcName<>( ... ); // Usage syntax, explicit instantitaion syntax. template Type funcName< ... >( ... ); // Usage syntax, implicit instantitaion syntax. Type result = funcName( ... ); // Usage syntax, implicit instantitaion syntax. Type result = funcName<>( ... ); // Usage syntax, implicit instantitaion syntax. Type result = funcName< ... >( ... );","title":"Syntax"},{"location":"Templates/#class-templates-or-struct-templates","text":"","title":"Class Templates or Struct Templates"},{"location":"Templates/#explanation_2","text":"Class templates or struct templates enable the creation of classes or structs that can manage various data types . This feature is particularly advantageous for implementing data structures such as lists, stacks, and queues , where the type of data may vary .","title":"Explanation"},{"location":"Templates/#syntax_1","text":"// With explicit instantiation. namespace SpaceName { // Definition Syntax. template< class T, ... > class ClassName { RetType funcName( ... ) { // Do something. }; }; }; // namespace SpaceName. // Usage syntax, instantiation syntax. // template class ClassName<int>; // error: class template ClassName not visible in the global namespace. using SpaceName::ClassName; // template class ClassName<int>; // error: explicit instantiation outside of the namespace of the template. template class SpaceName::ClassName< Type, ... >; // OK: explicit instantiation. template RetType SpaceName::ClassName< Type, ... >::funcName( ... ); // OK: explicit instantiation. // With implicit instantiation. // Definition Syntax. template< class T, ... > struct StructName { }; // Usage syntax, instantiation syntax. template struct StructName< Type, ... >; // Explicit instantiation of StructName< Type >. StructName< Type, ... > obj; // Implicit instantiation of StructName< Type >.","title":"Syntax"},{"location":"Templates/#template-specialization","text":"","title":"Template Specialization"},{"location":"Templates/#explanation_3","text":"Template specialization allows for the definition of a specific implementation of a template for a particular data type to meet specific conditions . However, they do not allow more than one specialization for the same type parameters . The compiler will throw an error if multiple specializations that match the same signature are declared. This feature is useful when the generic implementation requires adjustment for certain types to enhance functionality or performance .","title":"Explanation"},{"location":"Templates/#full-specialization","text":"","title":"Full specialization"},{"location":"Templates/#explanation_4","text":"In full specialization , it is imperative to specify all template parameters explicitly . For instance, if your template accepts two parameters, both must be explicitly defined in the specialization.","title":"Explanation"},{"location":"Templates/#syntax_2","text":"// Definition syntax. template< para_list > class ClassName { // Implementation. }; // Full specialization for `arg_list2`. template<> class ClassName< arg_list2 > { // Another implementation. }; // Usage syntax. ClassName< arg_list1 > obj1; // Utilizes the generic version. ClassName< arg_list2 > obj2; // Utilizes the specialized version.","title":"Syntax"},{"location":"Templates/#partial-specialization-partial-parameters","text":"","title":"Partial Specialization (Partial Parameters)"},{"location":"Templates/#explanation_5","text":"In partial specialization , it is permissible to leave some template parameters unspecified , allowing them to remain generic . The names of the unspecified template parameters do not need to remain the same as before , except for their remaining quantity . This flexibility is advantageous for providing specialized behavior tailored to specific categories of types .","title":"Explanation"},{"location":"Templates/#syntax_3","text":"// Definition syntax. template< para_list1 > class ClassName { // Implementation. }; // Partial specialization for `arg_list3`. template< para_list2 > class ClassName< arg_list3 > { // Another implementation. }; // Usage syntax. ClassName< arg_list1 > obj1; // Utilizes the generic version. ClassName< arg_list2, arg_list3 > obj2; // Utilizes the specialized version. // Definition syntax. template< typename T1, typename T2, ... > class ClassName { // Implementation. }; // Partial specialization for generic reference types. template< typename T1, typename T2, ... > class ClassName< T1&, T2&, ... > { // Another implementation. }; // Definition syntax. template< typename T1, typename T2, ... > class ClassName { // Implementation. }; // Partial specialization for generic pointer types. template< typename T1, typename T2, ... > class ClassName< T1*, T2*, ... > { // Another implementation. }; // Definition syntax. template< typename T, typename... Args > class ClassName { // Implementation. }; // Partial specialization for function types. template< typename T, typename... Args > class ClassName< T(... Args) > { // Another implementation. };","title":"Syntax"},{"location":"Templates/#variadic-templates-template-packs","text":"","title":"Variadic Templates (Template Packs)"},{"location":"Templates/#explanation_6","text":"Variadic templates are templates that contain at least one parameter pack . A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). The common way to store the arguments of a template parameter pack and access them is by using std::tuple and std::get . This feature is beneficial for functions that need to handle a flexible number of arguments , thereby enhancing versatility. For a function template , multiple parameter packs can be defined, while a class template can only have one . For a function template , a template parameter pack can automatically deduce types and the types are not explicitly specified when the function is called. However, for a class template (such as std::tuple or std::vector ), the types must be explicitly specified because template parameter packs are typically not deduced in class templates.","title":"Explanation"},{"location":"Templates/#common-syntax","text":"#include <iostream> #include <tuple> // Be mindful of the Ellipsis. template< typename... Args > class ClassName { public: // explicit ClassName( Args&... args ): // explicit ClassName( Args&&... args ): explicit ClassName( Args... args ): _mem( args... ), _mem_ptr( &args... ) { // Method to print all arguments in order without adding any extra characters. ( std::cout << ... << args ) << std::endl; // Method to print all arguments'addresses in order without adding any extra characters. ( std::cout << ... << &args ) << std::endl; // Method to print all ++arguments in order without adding any extra characters. ( std::cout << ... << ++args ) << std::endl; // Method to add all arguments in order and print the result. std::cout << ( ... + args ) << std::endl; // Method to multiple all arguments in order and print the result. std::cout << ( ... * args ) << std::endl; // Method to && all arguments in order and print the result. std::cout << ( ... && args ) << std::endl; // Method to || all arguments in order and print the result. std::cout << ( ... || args ) << std::endl; }; // Method to get an element by index. template< std::size_t Index > decltype( auto ) get() { return std::get< Index >( _mem ); }; // Others. private: std::tuple< Args... > _mem; // Store arguments in a tuple. std::tuple< Args*... > _mem_ptr; // Store arguments's addresses in a tuple. // Others }; int main() { ClassName< ArgType1, ArgType2, ArgType3, /* and so on */ > obj( arg1, arg2, arg3, /* and so on */ ); // Access specific elements by index. std::cout << \"First element: \" << obj.get< 0 >() << std::endl; // arg1. std::cout << \"Second element: \" << obj.get< 1 >() << std::endl; // arg2. std::cout << \"Third element: \" << obj.get< 2 >() << std::endl; // arg3. // Others. return 0; };","title":"Common Syntax"},{"location":"Templates/#link","text":"parameter packs in cplusplus . parameter packs in cppreference .","title":"Link"},{"location":"Templates/#template-parameters-with-non-type-parameters","text":"","title":"Template Parameters with Non-type Parameters"},{"location":"Templates/#explanation_7","text":"Template parameters can include non-type parameters , which are constants of integral or enumeration types, pointers, references, or even certain types of non-type template parameters. This feature allows you to create templates that are more flexible and capable of handling specific values alongside types , enabling additional control over template behavior and structure .","title":"Explanation"},{"location":"Templates/#syntax_4","text":"// Definition syntax. template< typename T, ..., Type N, ... > class ClassName { ...; }; // Usage syntax. ClassName< TType, ..., val, ... > var_name;","title":"Syntax"},{"location":"Templates/#constraints-and-concepts","text":"","title":"Constraints and Concepts"},{"location":"Templates/#explanation_8","text":"Class templates, function templates, and non-template functions (typically members of class templates) might be associated with a constraint , which specifies the requirements on template arguments , which can be used to select the most appropriate function overloads and template specializations . Named sets of such requirements are called concepts . Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:","title":"Explanation"},{"location":"Templates/#links","text":"constraints and concepts in cplusplus . constraints and concepts in cppreference .","title":"Links"},{"location":"Templates/#sfinae-substitution-failure-is-not-an-error","text":"","title":"SFINAE (Substitution Failure Is Not An Error)"},{"location":"Templates/#explanation_9","text":"It is a principle that allows template substitutions to fail and may still result in a compilation error \u2014 but it is not treated as an error in the context of template instantiation. This is useful for enabling or disabling templates based on certain conditions . std::enable_if is a common tool for implementing SFINAE, there are other techniques and constructs that can also be used, such as function overloading, template specialization, type traits, constraints and concepts in templates, and more. If a function template cannot be instantiated due to type mismatches, the compiler simply ignores that overload instead of producing an error. If a template specialization cannot be matched, it will not result in an error but rather allow the compiler to try other template. Its declaration syntax: CPP template< bool B, class T = void > struct enable_if; // It has a public member typedef `type`, equal to `T`. Its implementation syntax: CPP template< bool B, class T = void > struct enable_if {}; // Primary template. // Partial specialization for the case when B is true. template< class T > struct enable_if< true, T > { using type = T; }; Its helper types: CPP template< bool B, class T = void > using enable_if_t = typename enable_if< B, T >::type;","title":"Explanation"},{"location":"Templates/#syntax_5","text":"// With `std::enable_if`. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header `<type_traits>`, // for example, `std::is_integral`. template< typename T, ... > typename std::enable_if< TypeTrait< T, ... >::value >::type funcName( T para, ... ) { // If T, ... meet specific conditions. // Do something. }; template< typename T, ... > typename std::enable_if< !TypeTrait< T >::value >::type funcName( T para, ... ) { // If T is not a specific type. // Do something. }; // With `std::enable_if`. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header `<type_traits>`, // for example, `std::is_integral`. template< typename T, typename std::enable_if< TypeTrait< T, ... >::value >::type, ... > RetType funcName( T para, ... ) { // If T, ... meet specific conditions. // Do something. }; template< typename T, typename std::enable_if< !TypeTrait< T >::value >::type, ... > RetType funcName( T para, ... ) { // If T is not a specific type. // Do something. }; // With constraints and concepts. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header <type_traits>, // for example, std::is_integral template< typename T, ... > concept TempName = TypeTrait< T, ... >; template< TempName T, ... > RetType funcName( T para, ... ) { // This function is only enabled for specific conditions };","title":"Syntax"},{"location":"Templates/#type-traits","text":"","title":"Type Traits"},{"location":"Templates/#explanation_10","text":"Type traits are a set of template classes (or structures or functions even with the constexpr keyword) provided by the C++ Standard Library that allow you to query and manipulate type information at compile time . They can be combined with various techniques used to complete evaluations at compile time , such as static const , constexpr , templates , std::enable_if , static_assert , and more. All type traits are in the header <type_traits> .","title":"Explanation"},{"location":"Templates/#syntax_6","text":"// Using templates and `static_assert` to implement a type trait. template< typename T > struct IsPointer { static const bool val = false; // Default case. }; template< typename T > struct IsPointer< T* > { static const bool val = true; // Specialization for pointers. }; // Usage. static_assert( IsPointer< int* >::val, \"Should be a pointer type\" ); static_assert( !IsPointer< int >::val, \"Should not be a pointer type\" ); // Using a type trait with `static_assert`. #include <type_traits> // In this, `TypeTrait` is a template function (or class or structure, // even with the `constexpr` keyword) in the header <type_traits>, // for example, `std::is_integral`. template< typename T, ... > RetType funcName( T t, ... ) { static_assert( TypeTrait< T >::value, \"T must be a specific type\" ); // Do something. };","title":"Syntax"},{"location":"Templates/#template-aliases","text":"using","title":"Template Aliases"},{"location":"Templates/#universial-references-forward-references","text":"A universal reference is a type of reference in C++ that can bind to both lvalues and rvalues . It is also called a forwarding reference in modern C++ terminology. The term \"universal reference\" is particularly used in the context of template functions . A universal reference typically appears in a template function parameter when the type is declared as T&& but is not a reference type (such as in T&& where T is a template parameter). This is a special case of rvalue reference, which can either bind to: An rvalue (temporary object). An lvalue (persistent object) if it's used in the context of a template. Lvalue reference ( T& ) and rvalue reference ( T&& ) are distinct in C++. But when template type deduction is used, the compiler deduces the right reference type depending on the value category of the argument passed. When an lvalue is passed, T is deduced as Type& , so the universal reference becomes Type& & , which is collapsed to Type& . When an rvalue is passed, T is deduced as Type& , and the universal reference becomes Type& & . Universal references are often used in perfect forwarding , where you want to forward the arguments exactly as received, keeping their value category intact.","title":"Universial References (Forward References)"},{"location":"Threads/","text":"Threads Explanation std::thread Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links Member Types Member functions Non-member functions See also Notes std::jthread Explanation Declaration Syntax Initialization Syntax Members and Related Stuffs Links Member Types Member functions Non-member functions std::this_thread Explanation Links std::this_thread::get_id Explanation Syntax std::this_thread::sleep_for Explanation Syntax std::this_thread::sleep_until Explanation Syntax std::this_thread::yield Explanation Syntax std::forward Explanation Syntax std::ref and std::cref Explanation Syntax Six STD Mutex Classes std::mutex std::recursive_mutex std::timed_mutex std::recursive_timed_mutex std::shared_mutex std::shared_timed_mutex Syntax Members and Related Stuffs Links Nested Types Member Functions Notes std::lock_guard Explanation Syntax Members and Related Stuffs Links Template Parameters Member Types Member Functions std::unique_lock and std::shared_lock std::unique_lock std::shared_lock Syntax Members and Related Stuffs Links Template Parameters Nested Types Member Functions Non-member Functions std::scoped_lock Explanation Syntax Members and Related Stuffs Links Template Parameters Member Types Member Functions std::lock and std::try_lock std::lock std::try_lock Syntax Three Lock Type Tags std::call_once and std::once_flag Explanation Syntax std::atomic and std::atomic_ref std::atomic std::atomic_ref Syntax Members and Related Stuffs Links Member Types Member Functions Constants Specialized Member Functions Specialized for Integral, Floating-point (Since C++20) and Pointer Types Specialized for Integral and Pointer Types Only Specialized for Integral Types Only Type Aliases (Only for std::atomic ) std::condition_variable and std::condition_variable_any std::condition_variable std::condition_variable_any Examples Members and Related Stuffs Links Nested Types Member Functions std::notify_all_at_thread_exit Explanation Syntax std::async Explanation Syntax Related Stuffs Links Parameters Return Value Launching Policies Notes std::future and std::shared_future std::future std::shared_future Declaration Syntax Initialization Syntax Members and Related Stuffs Links Member Functions std::future_status (Returned by wait_for and wait_until Functions) Differences Between std::future and std::shared_future std::promise Explanation Syntax Related Stuffs Links Member Functions Non-member Functions Helper Classes Notes Threads Explanation C++ provides native support for multithreading through the <thread> library , allowing programs to execute tasks concurrently on multiple cores. A thread is the smallest sequence of programmed instructions that can be managed independently by the scheduler. C++ uses the std::thread class to create and manage threads. std::thread Explanation std::thread is a class that represents an individual thread of execution . A thread of execution is a sequence of instructions that can be executed concurrently with other such sequences in multithreading environments, while sharing a same address space . An initialized thread object represents an active thread of execution; Such a thread object is joinable , and has a unique thread id . A default-constructed (non-initialized) thread object is not joinable , and its thread id is common for all non-joinable threads . A joinable thread becomes not joinable if moved from, or if either join or detach are called on them. A std::thread object cannot be copied because its copy constructor is deleted. When some parameters of funName are lvalue references , you must wrap the corresponding arguments in std::ref (for non-const lvalue references) or std::cref (for const lvalue references) when passing them to std::thread . This is necessary because std::thread moves its arguments into the thread function by default, which can break lvalue reference bindings. Its header file is <thread> . Declaration Syntax std::thread thread_name; Initialization Syntax // Default constructor. std::thread thread_name; // Initialization constructor. std::thread thread_name( funName, arg_list_of_funName ); // Initialization constructor. std::thread thread_name( fun_ptr, arg_list_of_fun_ptr ); // Initialization constructor. std::thread thread_name( a_lambad_func, arg_list_of_the_lambad_func ); std::thread thread_name1( ... ); // Move constructor. std::thread thread_name2( std::move( thread_name1 ) ); std::thread thread_name1( ... ); // Move constructor. std::thread thread_name2 = std::move( thread_name1 ); Members and Related Stuffs Links std::thread in cplusplus . std::thread in cppreference . Member Types native_handle_type (optional): Implementation-defined. id : Represents the id of a thread (public member class). Member functions (constructor): Constructs new thread object (public member function). (destructor): Destructs the thread object, underlying thread must be joined or detached (public member function). operator= : Moves the thread object (public member function). joinable : Checks whether the thread is joinable, i.e. potentially running in parallel context (public member function). get_id : Returns the id of the thread (public member function). native_handle : Returns the underlying implementation-defined thread handle (public member function). hardware_concurrency [ static ]: Returns the number of concurrent threads supported by the implementation (public static member function). join : Waits for the thread to finish its execution (public member function). detach : Permits the thread to execute independently from the thread handle (public member function). swap : Swaps two thread objects (public member function). Non-member functions std::swap( std::thread ) : Specializes the std::swap algorithm (function). See also std::jthread (C++20): std::thread with support for auto-joining and cancellation (class). Notes A thread starts executing when the std::thread object is defined, not when the join function is called. Calling join merely blocks the calling thread, waiting for the thread to finish and releasing its resources. A detached thread (a thread that has been detach ed) will release its resources either when the calling thread ends or when it finishes executing itself. However, it cannot safely access resources of the main thread unless those resources have been explicitly managed for concurrent access. Threads automatically release resources when their function completes. It is not recommended to forcefully terminate a thread using other methods, as this may cause memory leaks due to unreleased resources. A thread that is neither joined nor detached will throw an exception when the program exits. std::jthread Explanation std::jthread is a class that represents a managed thread of execution with automatic joining and optional cooperative cancellation . std::jthread executes a sequence of instructions that can run concurrently with other threads, all sharing the same address space in a multithreaded environment. An initialized std::jthread object represents an active thread of execution that is automatically joined when the object is destroyed, making it safer and more convenient to manage. A default-constructed (non-initialized) std::jthread object is not joinable , and its thread id is set to a default value shared by all non-joinable threads . A std::jthread object becomes not joinable if it has been moved from, or after it completes its execution and is automatically joined. A std::jthread object cannot be copied because its copy constructor is deleted. Cooperative cancellation is supported through a stop_token , which allows a thread to respond to stop requests and terminate gracefully. Its header file is <thread> . Declaration Syntax std::jthread thread_name; Initialization Syntax // Default constructor. std::jthread thread_name; // Initialization constructor. std::jthread thread_name( funName, arg_list_of_funName ); // Initialization constructor. std::jthread thread_name( fun_ptr, arg_list_of_fun_ptr ); // Initialization constructor. std::jthread thread_name( a_lambad_func, arg_list_of_the_lambad_func ); std::jthread thread_name1( ... ); // Move constructor. std::jthread thread_name2( std::move( thread_name1 ) ); std::jthread thread_name1( ... ); // Move constructor. std::jthread thread_name2 = std::move( thread_name1 ); Members and Related Stuffs Links std::jthread in cplusplus . std::jthread in cppreference . Member Types native_handle_type (optional): Implementation-defined. id : Represents the id of a thread (public member class). Member functions (constructor): Constructs new thread object (public member function). (destructor): If the thread is joinable, then a stop is requested and the thread joins (public member function). operator= : Moves the jthread object (public member function). joinable : Checks whether the thread is joinable, i.e. potentially running in parallel context (public member function). get_id : Returns the id of the thread (public member function). native_handle : Returns the underlying implementation-defined thread handle (public member function). hardware_concurrency [ static ]: Returns the number of concurrent threads supported by the implementation (public static member function). join : Waits for the thread to finish its execution (public member function). detach : Permits the thread to execute independently from the thread handle (public member function). swap : Swaps two thread objects (public member function). get_stop_source : Returns a stop_source object associated with the shared stop state of the thread (public member function). get_stop_token : Returns a stop_token associated with the shared stop state of the thread (public member function). request_stop : Requests execution stop via the shared stop state of the thread (public member function). Non-member functions std::swap( std::jthread ) (C++20): Specializes the std::swap algorithm (function). std::this_thread Explanation The std::this_thread namespace provides utilities for interacting with the current thread of execution . It contains functions to retrieve the thread\u2019s ID, pause execution, or yield to other threads . Its header file is <thread> . Links std::this_thread in cplusplus . std::this_thread in cppreference . std::this_thread::get_id Explanation std::this_thread::get_id() is a function used to retrieve the ID of the current thread, which is useful for debugging or logging purposes. Syntax // Its declaration syntax. std::thread::id get_id() noexcept; std::this_thread::sleep_for Explanation std::this_thread::sleep_for is a function used to block the execution of the current thread for at least the specified sleep_duration . This function may block for longer than the sleep_duration due to scheduling or resource contention delays. The standard recommends that a steady clock be used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments. Syntax // Its declaration syntax. template< class Rep, class Period > void sleep_for( const std::chrono::duration< Rep, Period >& sleep_duration ); std::this_thread::sleep_until Explanation std::this_thread::sleep_until is a function used blocks the calling thread until the specified sleep_time . The execution of the current thread is paused until at least sleep_time , while other threads may continue to execute during this period. Syntax // Its declaration syntax. template< class Clock, class Duration > void sleep_until( const std::chrono::time_point< Clock, Duration >& sleep_time ); std::this_thread::yield Explanation The calling thread yields, offering the implementation the opportunity to reschedule . This function shall be called when a thread waits for other threads to advance without blocking. Syntax // Its declaration syntax. void yield() noexcept; std::forward Explanation std::forward is a utility function that is used for perfect forwarding of function arguments , ensuring that their value categories (whether they are lvalues or rvalues) are preserved during the forwarding process. It returns an rvalue reference to obj_name if obj_name is not an lvalue reference. If obj_name is an lvalue reference, the function returns obj_name without modifying its type. std::forward acts as a transfer station that preserves the original value category (whether it is an lvalue or an rvalue) of the argument it forwards . Its header file is <utility> . Syntax // Its usage syntax. std::forward( obj_name ); // An usage example. #include <iostream> #include <utility> // For std::forward // Function to demonstrate perfect forwarding template< typename T > void wrapper( T&& arg ) { // Forward the argument to another function // This preserves whether arg is an lvalue or rvalue process( std::forward< T >( arg ) ); }; // Helper function to handle both lvalues and rvalues void process( int& x ) { std::cout << \"Lvalue processed: \" << x << std::endl; }; void process( int&& x ) { std::cout << \"Rvalue processed: \" << x << std::endl; }; int main() { int x = 42; wrapper( x ); // Lvalue passed, so it will call process(int&) wrapper( 10 ); // Rvalue passed, so it will call process(int&&) }; std::ref and std::cref Explanation std::ref is a utility function that creates a reference wrapper for a given object . It is used when you need to pass an argument by reference to a function, particularly in situations where a function or class expects its argument to be passed by value (like in std::thread or in certain algorithms that use copy semantics). The key purpose of std::ref is to ensure that arguments are passed as references even when the target function is expecting arguments by value . std::ref works like a reference , but it is not a true reference . Therefore, a function whose parameters are expecting a direct reference cannot directly receive a std::reference_wrapper . std::cref works similarly to std::ref , but it creates a reference wrapper for constant references . They are usually used with std::thread and std::async . Their header file is <functional> . Syntax // Its usage syntax. std::ref( var_name ); std::cref( var_name ); Six STD Mutex Classes std::mutex A mutex is a lockable object that is designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently and access the same memory locations . std::mutex objects provide exclusive ownership and do not support recursivity (i.e., a thread shall not lock a std::mutex it already owns) -- see std::recursive_mutex for an alternative class that does. It is guaranteed to be a standard-layout class . Its header file is <mutex> . std::recursive_mutex std::recursive_mutex is a lockable object , just like std::mutex , but allows the same thread to acquire multiple levels of ownership over the std::mutex object ( recursivity, recursive calls ). This allows to lock (or try-lock ) the mutex object from a thread that is already locking it, acquiring a new level of ownership over the std::mutex object: the std::mutex object will actually remain locked owning the thread until its member unlock is called as many times as this level of ownership. It is guaranteed to be a standard-layout class . Its header file is <mutex> . std::timed_mutex A timed mutex is a time lockable object that is designed to signal when critical sections of code need exclusive access, just like a regular mutex , but additionally supporting timed try-lock requests . As such, a std::timed_mutex has two additional members: try_lock_for and try_lock_until . It is guaranteed to be a standard-layout class. Its header file is <mutex> . std::recursive_timed_mutex A recursive timed mutex combines both the features of std::recursive_mutex and the features of std::timed_mutex into a single class : it supports both acquiring multiple lock levels by a single thread and also timed try-lock requests. It is guaranteed to be a standard-layout class. Its header file is <mutex> . std::shared_mutex The std::shared_mutex template class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads . In contrast to other mutex types which facilitate exclusive access, a std::shared_mutex has two levels of access : shared (read-shared-data-only) : several threads can share ownership of the same mutex. exclusive (read-or-modify-shared-date) : only one thread can own the mutex. If one thread has acquired the exclusive lock (through lock , try_lock ) , no other threads can acquire the lock (including the shared). If one thread has acquired the shared lock (through lock_shared , try_lock_shared ) , no other thread can acquire the exclusive lock, but can acquire the shared lock. Only when the exclusive lock has not been acquired by any thread, the shared lock can be acquired by multiple threads. Within one thread, only one lock (shared or exclusive) can be acquired at the same time. Shared mutexes are especially useful when shared data can be safely read by any number of threads simultaneously , but a thread may only write the same data when no other thread is reading or writing at the same time . The std::shared_mutex class satisfies all requirements of SharedMutex and StandardLayoutType . Its header file is <mutex> . std::shared_timed_mutex The std::shared_timed_mutex template class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads . In contrast to other mutex types which facilitate exclusive access, a std::shared_timed_mutex has two levels of access : shared (read-shared-data-only) : several threads can share ownership of the same mutex. exclusive (read-or-modify-shared-date) : only one thread can own the mutex. Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so. In a manner similar to std::timed_mutex , std::shared_timed_mutex provides the ability to attempt to claim ownership of a std::shared_timed_mutex with a timeout via the try_lock_for() , try_lock_until() , try_lock_shared_for() , try_lock_shared_until() member functions. The std::shared_timed_mutex class satisfies all requirements of SharedTimedMutex and StandardLayoutType . Its header file is <mutex> . Syntax // Its usage syntax. std::mutex mutex_name; std::recursive_mutex rmutex_name; std::timed_mutex tmutex_name; std::recursive_timed_mutex rtmutex_name; std::shared_mutex smutex_name; std::shared_timed_mutex stmutex_name; Members and Related Stuffs Links <mutex> in cplusplus . <mutex> in cppreference . std::mutex in cplusplus . std::mutex in cppreference . std::recursive_mutex in cplusplus . std::recursive_mutex in cppreference . std::timed_mutex in cplusplus . std::timed_mutex in cppreference . std::recursive_timed_mutex in cplusplus . std::recursive_timed_mutex in cppreference . Nested Types native_handle_type (optional*) : Implementation-defined. Member Functions (constructor): Constructs the mutex (public member function). (destructor): Destroys the mutex (public member function). operator=[deleted] : Not copy-assignabl (public member function). lock : Locks the mutex, blocks if the mutex is not available (public member function). try_lock : Tries to lock the mutex, returns if the mutex is not available (public member function). try_lock_for (only for std::timed_mutex , std::recursive_timed_mutex and std::shared_timed_mutex ): Tries to lock the mutex, returns if the mutex has been unavailable for the specified timeout duration (public member function). try_lock_until (only for std::timed_mutex , std::recursive_timed_mutex and std::shared_timed_mutex ): Tries to lock the mutex, returns if the mutex has been unavailable until specified time point has been reached (public member function). unlock : Unlocks the mutex (public member function). lock_shared (only for std::shared_mutex and std::shared_timed_mutex ): Locks the mutex for shared ownership, blocks if the mutex is not available (public member function). try_lock_shared (only for std::shared_mutex and std::shared_timed_mutex ): Tries to lock the mutex for shared ownership, returns if the mutex is not available (public member function). try_lock_shared_for (only for std::shared_timed_mutex ): Tries to lock the mutex for shared ownership, returns if the mutex has been unavailable for the specified timeout duration (public member function). try_lock_shared_until (only for std::shared_timed_mutex ): Tries to lock the mutex for shared ownership, returns if the mutex has been unavailable until specified time point has been reached (public member function). unlock_shared (only for std::shared_mutex and std::shared_timed_mutex ): Unlocks the mutex (shared ownership) (public member function). native_handle : Returns the underlying implementation-defined native handle object (public member function). Notes All lock classes or functions that receive mutex objects implement the locking or unlocking behavior by calling the mutex object's lock or unlock member functions. All mutex objects are passed to them by reference. All lock objects do not manage the lifetime of the mutex object in any way: the duration of the mutex object shall extend at least until the destruction of the lock object that locks it. std::lock_guard Explanation std::lock_guard is a template class that manages a mutex object by keeping it always locked . On construction , the mutex object is locked by the calling thread, and on destruction , the mutex is unlocked . It is the simplest lock, and is specially useful as an object with automatic duration that lasts until the end of its context. In this way, it guarantees the mutex object is properly unlocked in case an exception is thrown. Its header file is <mutex> . Syntax // Its usage syntax. MutexType mtx; std::lock_guard< MutexType > lck( mtx ); // Its usage syntax. MutexType mtx; mtx.lock(); std::lock_guard< MutexType > lck( mtx, std::adopt_lock ); Members and Related Stuffs Links std::lock_guard in cplusplus . std::lock_guard in cppreference . Template Parameters Mutex : The type of the mutex to lock. The type must meet the BasicLockable requirements. Member Types mutex_type : Mutex . Member Functions (constructor): Constructs a lock_guard , optionally locking the given mutex. Not copy-constructable (public member function). (destructor): Destructs the lock_guard object, unlocks the underlying mutex (public member function). operator=[deleted] : Not copy-assignable (public member function). std::unique_lock and std::shared_lock std::unique_lock std::unique_lock is a template class that manages a mutex object with unique ownership in both states : locked and unlocked . On construction (or by move-assigning to it), the object acquires a mutex object , for whose locking and unlocking operations becomes responsible. This class guarantees an unlocked status on destruction (even if not called explicitly). Therefore it is especially useful as an object with automatic duration, as it guarantees the mutex object is properly unlocked in case an exception is thrown. Even when working with a shared mutex , std::unique_lock essentially behaves like a normal lock , blocking other threads from accessing the shared data. This is because a std::unique_lock provides exclusive access to the resource, preventing other threads from acquiring either a shared or exclusive lock until the unique lock is released. Its header file is <mutex> . std::shared_lock std::shared_lock is a template class that manages a mutex object with shared ownership . On construction (or by move-assigning to it), the object acquires a shared lock on a mutex object, allowing multiple threads to hold the lock concurrently . This class guarantees an unlocked status on destruction , releasing the shared lock when the std::shared_lock object goes out of scope. It is especially useful for shared access to a resource when multiple threads need to read from it concurrently , without blocking each other. However, that std::shared_lock provides only shared access to the resource, meaning exclusive access is not possible while a shared lock is held. While acquiring a shared lock allows other threads to also acquire shared locks, no thread can acquire an exclusive lock until all shared locks are released. The class does not manage the lifetime of the mutex object. The MutexType used with std::shared_lock must be a shared mutex type . Its header file is <shared_mutex> . Syntax // Its usage syntax. MutexType mtx; std::unique_lock< MutexType > ulck( mtx ); std::shared_lock< MutexType > slck( mtx ); // Its usage syntax. MutexType mtx; std::unique_lock< MutexType > ulck1( mtx ); std::shared_lock< MutexType > slck1( mtx ); // Move constructor. std::unique_lock< MutexType > ulck2( std::move( ulck1 ) ); std::shared_lock< MutexType > slck2( std::move( slck1 ) ); // Its usage syntax. MutexType mtx; std::unique_lock< MutexType > ulck( mtx, std::defer_lock ); ulck.lock(); std::shared_lock< MutexType > slck( mtx, std::defer_lock ); slck.lock(); // Its usage syntax. MutexType mtx; mtx.lock(); std::unique_lock< MutexType > ulck( mtx, std::try_to_lock ); if( ulck.owns_lock() ) { // Critical section: code that must be executed atomically. } else { // Lock acquisition failed, handle the situation appropriately. }; std::shared_lock< MutexType > slck( mtx, std::try_to_lock ); if( slck.owns_lock() ) { // Critical section: code that must be executed atomically. } else { // Lock acquisition failed, handle the situation appropriately. }; // Its usage syntax. MutexType mtx; mtx.lock(); std::unique_lock< MutexType > ulck( mtx, std::adopt_lock ); std::shared_lock< MutexType > slck( mtx, std::adopt_lock ); // Its usage syntax. MutexType mtx; std::chrono::duration< Type, std::ratio< num1, num2 >(Optional) > dur; std::unique_lock< MutexType > ulck( mtx, dur ); std::shared_lock< MutexType > slck( mtx, dur ); // Its usage syntax. MutexType mtx; std::chrono::time_point< Clock > tpoint; std::unique_lock< MutexType > ulck( mtx, tpoint ); std::shared_lock< MutexType > slck( mtx, tpoint ); Members and Related Stuffs Links std::unique_lock in cplusplus . std::unique_lock in cppreference . std::shared_lock in cplusplus . std::shared_lock in cppreference . Template Parameters Mutex : The type of the mutex to lock. The type must meet the BasicLockable requirements. Nested Types mutex_type : Mutex . Member Functions (constructor): Constructs a std::unique_lock , optionally locking (i.e., taking ownership of) the supplied mutex (public member function). (destructor): Unlocks (i.e., releases ownership of) the associated mutex, if owned (public member function). operator= : Unlocks (i.e., releases ownership of) the mutex, if owned, and acquires ownership of another (public member function). lock : Locks (i.e., takes ownership of) the associated mutex (public member function). try_lock : Tries to lock (i.e., takes ownership of) the associated mutex without blocking (public member function). try_lock_for : Attempts to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable for the specified time duration (public member function). try_lock_until : Tries to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable until specified time point has been reached (public member function). unlock : Unlocks (i.e., releases ownership of) the associated mutex (public member function). swap : Swaps state with another std::unique_lock (public member function). release : Disassociates the associated mutex without unlocking (i.e., releasing ownership of) it (public member function). mutex : Returns a pointer to the associated mutex (public member function). owns_lock : Tests whether the lock owns (i.e., has locked) its associated mutex (public member function). operator bool : Tests whether the lock owns (i.e., has locked) its associated mutex (public member function). Non-member Functions std::swap( std::unique_lock ) (C++11), std::swap( std::unique_lock ) (C++11): Specializes the std::swap algorithm (function template). std::scoped_lock Explanation The template class std::scoped_lock is a mutex wrapper that provides a convenient RAII-style mechanism for owning zero or more mutexes for the duration of a scoped block. When a std::scoped_lock object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the std::scoped_lock object was created, the std::scoped_lock is destructed and the mutexes are released. If several mutexes are given , deadlock avoidance algorithm is used as if by std::lock . The std::scoped_lock class is non-copyable . Its header file is <mutex> . Syntax // Its declaration syntax. template< class... MutexTypes > class scoped_lock; // Its declaration syntax. MutexType1 mtx1; MutexType2 mtx2; ...; std::scoped_lock< MutexType1, MutexType2, ... > lck( mtx1, mtx2, ... ); // Its declaration syntax. MutexType1 mtx1; MutexType2 mtx2; ...; mtx1.lock; mtx2.lock; ...; std::scoped_lock< MutexType1, MutexType2, ... > lck( std::adopt_lock, mtx1, mtx2, ... ); Members and Related Stuffs Links std::scoped_lock in cplusplus . std::scoped_lock in cppreference . Template Parameters MutexTypes : The types of the mutexes to lock. The types must meet the Lockable requirements unless sizeof...( MutexTypes ) == 1 , in which case the only type must meet BasicLockable. Member Types mutex_type (conditionally present): If sizeof...( MutexTypes ) == 1 , member type mutex_type is the same as Mutex, the sole type in MutexTypes... . Otherwise, there is no member mutex_type . Member Functions (constructor): Constructs a std::scoped_lock , optionally locking the given mutexes (public member function). (destructor): Destructs the std::scoped_lock object, unlocks the underlying mutexes (public member function). operator=[deleted] : Not copy-assignable (public member function). std::lock and std::try_lock std::lock std::lock locks all the objects passed as arguments , blocking the calling thread if necessary. The function locks the objects using an unspecified sequence of calls to their members lock, try_lock and unlock that ensures that all arguments are locked on return (without producing any deadlocks). If the function cannot lock all objects (such as because one of its internal calls threw an exception ), the function first unlocks all objects it successfully locked (if any) before failing. To prevent deadlock, the order of acquiring multiple locks must be consistent . Its header file is <mutex> . std::try_lock std::try_lock attempts to lock all the objects passed as arguments using their std::try_lock member functions (non-blocking) . The function calls the std::try_lock member function for each argument (first lock1 , then lock2 , and eventually the others in lockn , in the same order), until either all calls are successful, or as soon as one of the calls fails (either by returning false or throwing an exception). If the function ends because a call fails , unlock is called on all objects for which the call to std::try_lock was successful, and the function returns the argument order number of the object whose lock failed . No further calls are performed for the remaining objects in the argument list. If the function locks all mutex objects successfully, it returns -1 . Its header file is <mutex> . Syntax // Its declaration syntax. template< class Lockable1, class Lockable2, class... LockableN > void lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn ); // Its declaration syntax. template< class Lockable1, class Lockable2, class... LockableN > int try_lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn ); Three Lock Type Tags <mutex> in cplusplus . <mutex> in cppreference . std::defer : A constexpr defer_lock_t object. Do not acquire ownership of the mutex. std::try_to_lock : A constexpr try_to_lock_t object. Try to acquire ownership of the mutex without blocking. std::adopt_lock : A constexpr adopt_lock_t object. Assume the calling thread already has ownership of the mutex. std::call_once and std::once_flag Explanation std::call_once executes the callable object f exactly once , even if called concurrently from several threads . std::once_flag is a helper object to ensure that std::call_once invokes the function only once . Syntax // Its declaration syntax. template< class Callable, class... Args > void call_once( std::once_flag& flag, Callable&& f, Args&&... args ); std::atomic and std::atomic_ref std::atomic std::atomic is a template class that provides a variety of atomic operations that guarantee the integrity of data access across multiple threads . These operations include read-modify-write operations and compare-and-swap (CAS) operations . These operations are implemented using hardware-level atomic instructions, ensuring that they are indivisible and cannot be interrupted by other threads . std::atomic allows you to specify the memory ordering of operations , which determines how operations on different threads are synchronized . This is crucial for ensuring correct behavior in complex concurrent programs. Many of the operations provided by std::atomic are lock-free , meaning they don't require explicit locking mechanisms. Besides, some operations are wait-free , ensuring that a thread will eventually succeed in its operation, even if other threads are also contending. These two features can significantly improve performance in high-concurrency scenarios . The std::atomic class is non-copyable . Its header file is <atomic> . std::atomic_ref std::atomic_ref is a template class that provides atomic operations on non-atomic objects , allowing them to be accessed safely across multiple threads. It works by wrapping a reference to an existing object and providing atomic operations such as read-modify-write and compare-and-swap (CAS) on the referenced object. These operations are implemented using hardware-level atomic instructions , ensuring that they are indivisible and cannot be interrupted by other threads . std::atomic_ref allows you to specify the memory ordering of operations , which determines how operations on different threads are synchronized . This ensures correct behavior in multi-threaded programs, even when dealing with non-atomic types. Unlike std::atomic , which requires atomic types, std::atomic_ref works with regular types like int , double , and user-defined types. The class does not manage the lifetime of the referenced object, meaning you must ensure that the referenced object remains valid for the duration of the atomic operations. The use of std::atomic_ref can help reduce the overhead of atomic operations on non-atomic objects and improve performance in multi-threaded scenarios. std::atomic_ref is non-copyable , ensuring that the reference is consistent across multiple threads. Its header file is <atomic> . Syntax // Its usage syntax. std::atomic< Type > avar_name1; Type obj_name; avar_name1 = obj_name; // Allows temporary objects. std::atomic< Type > avar_name2( obj_name ); // Its usage syntax. Type obj_name; // Constructs an `atomic_ref` object referencing the object `obj_name`. std::atomic_ref< Type > avar_name1( obj_name ); // Constructs an `atomic_ref` object referencing the object `avar_name1`. std::atomic_ref< Type > avar_name2( avar_name1 ); Members and Related Stuffs Links <atomic> in cplusplus . <atomic> in cppreference . std::atomic in cplusplus . std::atomic in cppreference . Member Types value_type : T (regardless of whether specialized or not). difference_type : value_type (only for atomic< Integral > and atomic< Floating > (since C++20) specializations), std::ptrdiff_t (only for std::atomic< U* > specializations). difference_type is not defined in the primary std::atomic template or in the partial specializations for std::shared_ptr and std::weak_ptr . Member Functions (constructor): Constructs an atomic object (public member function). operator= : Stores a value into an atomic object (public member function). is_lock_free : Checks if the atomic object is lock-free (public member function). store : Atomically replaces the value of the atomic object with a non-atomic argument (public member function). load : Atomically obtains the value of the atomic object (public member function). operator T : Loads a value from an atomic object (public member function). exchange : Atomically replaces the value of the atomic object and obtains the value held previously (public member function). compare_exchange_weak , compare_exchange_strong : Atomically compares the value of the atomic object with non-atomic argument and performs atomic exchange if equal or atomic load if not (public member function). wait (C++20): Blocks the thread until notified and the atomic value changes (public member function). notify_one (C++20): Notifies at least one thread waiting on the atomic object (public member function). notify_all (C++20): Notifies all threads blocked waiting on the atomic object (public member function). Constants is_always_lock_free [ static ] (C++17): Indicates that the type is always lock-free (public static member constant). required_alignment [ static ] (only for std::atomic_ref): Indicates the required alignment of an object to be referenced by atomic_ref` (public static member constant). Specialized Member Functions Specialized for Integral, Floating-point (Since C++20) and Pointer Types fetch_add : Atomically adds the argument to the value stored in the atomic object and obtains the value held previously (public member function). fetch_sub : Atomically subtracts the argument from the value stored in the atomic object and obtains the value held previously (public member function). operator+=/-= : Adds to or subtracts from the atomic value (public member function). Specialized for Integral and Pointer Types Only fetch_max (C++26): Atomically performs std::max between the argument and the value of the atomic object and obtains the value held previously (public member function). fetch_min (C++26): Atomically performs std::min between the argument and the value of the atomic object and obtains the value held previously (public member function). operator++/++(int)/--/--(int) : Increments or decrements the atomic value by one (public member function). Specialized for Integral Types Only fetch_and : Atomically performs bitwise AND between the argument and the value of the atomic object and obtains the value held previously (public member function). fetch_or : Atomically performs bitwise OR between the argument and the value of the atomic object and obtains the value held previously (public member function). fetch_xor : Atomically performs bitwise XOR between the argument and the value of the atomic object and obtains the value held previously (public member function). operator&=/|=/^= : Performs bitwise AND, OR, XOR with the atomic value (public member function). Type Aliases (Only for std::atomic ) std::atomic in cplusplus . std::atomic in cppreference . std::condition_variable and std::condition_variable_any std::condition_variable A condition variable is a class object able to block the calling thread until notified to resume . It uses a std::unique_lock (over a mutex) to lock the thread when one of its wait functions is called. The thread remains blocked until woken up by another thread that calls a notification function on the same std::condition_variable object . Objects of type std::condition_variable always use std::unique_lock< std::mutex > to wait : for an alternative that works with any kind of lockable type, see std::condition_variable_any . Its header file is <condition_variable> . std::condition_variable_any It's the same as std::condition_variable , except that its wait functions can take any lockable type as argument ( std::condition_variable objects can only take std::unique_lock< std::mutex > ). Other than that, they are identical. However, std::condition_variable_any is slower than std::condition_variable . Its header file is <condition_variable> . Examples // condition_variable example #include <iostream> // std::cout #include <thread> // std::thread #include <mutex> // std::mutex, std::unique_lock #include <condition_variable> // std::condition_variable std::mutex mtx; std::condition_variable cv; bool ready = false; void print_id( int id ) { std::unique_lock< std::mutex > lck( mtx ); while( !ready ) cv.wait( lck ); // ...; std::cout << \"thread \" << id << '\\n'; }; void go() { std::unique_lock< std::mutex > lck( mtx ); ready = true; cv.notify_all(); }; int main() { std::thread threads[10]; // spawn 10 threads: for( int i = 0; i < 10; ++i ) threads[i] = std::thread( print_id, i ); std::cout << \"10 threads ready to race...\\n\"; go(); // go! for( auto& th: threads ) th.join(); return 0; }; Members and Related Stuffs Links <condition_variable> in cplusplus . <condition_variable> in cppreference . std::condition_variable in cplusplus . std::condition_variable in cppreference . std::condition_variable_any in cplusplus . std::condition_variable_any in cppreference . Nested Types native_handle_type : Implementation-defined. Member Functions (constructor): Constructs the object (public member function). (destructor): Destructs the object (public member function). operator=[deleted] : Not copy-assignable (public member function). notify_one : Notifies one waiting thread (public member function). notify_all : Notifies all waiting threads (public member function). wait : Blocks the current thread until the condition variable is awakened (public member function). wait_for : Blocks the current thread until the condition variable is awakened or after the specified timeout duration (public member function). wait_until : Blocks the current thread until the condition variable is awakened or until specified time point has been reached (public member function). native_handle : Returns the native handle (public member function). std::notify_all_at_thread_exit Explanation When the calling thread exits , all threads waiting on cond are notified to resume execution. The function also acquires ownership of the lock on the mutex object managed by lck , which is stored internally by the function and unlocked at thread exit (just before notifying all threads ), behaving as if the following was called once all objects with thread storage duration have been destroyed: lck.unlock() ; cond.notify_all() ; Syntax // Its declaration syntax. void notify_all_at_thread_exit( std::condition_variable& cond, std::unique_lock< std::mutex > lk ); std::async Explanation std::async is a template function that calls F (with Args as arguments) at some point, returning without waiting for the execution of F to complete . The value returned by F can be accessed through the future object returned (by calling its member future::get ). The second version (2) lets the caller select a specific launching policy , while the first version (1) uses automatic selection , as if calling (2) with launch::async | launch::deferred as policy. Its header file is <future> . Syntax // Declaration syntax. // The first version. template< class F, class... Args > std::future< /* see below */ > async( F&& f, Args&&... args ); // (since C++11) // Declaration syntax. // The second version. template< class F, class... Args > std::future< /* see below */ > async( std::launch policy, F&& f, Args&&... args ); // (since C++11) // Usage syntax. std::future< RetType > obj_name = std::async( ... ); Related Stuffs Links std::async in cplusplus . std::async in cppreference . Parameters f : Callable object to call. args : Parameters to pass to f . policy : Bitmask value, where individual bits control the allowed methods of execution. Return Value std::future : Referring to the shared state created by this call to std::async . Launching Policies Asynchronous ( launch::async ): Launches a new thread to call F (as if a thread object is constructed with F and Args as arguments, and accessing the shared state of the returned future joins it). Deferred ( launch::deferred ): The call to F is deferred until the shared state of the returned future is accessed (with wait or get ). At that point, F is called and the function is no longer considered deferred. When this call returns, the shared state of the returned future is made ready. Automatic ( launch::async | launch::deferred ): The function chooses the policy automatically (at some point). This depends on the system and library implementation , which generally optimizes for the current availability of concurrency in the system. Particular library implementations may support additional launching policies, with the proper label defined in type launch. Combining multiple values is possible, in which case, the function automatically chooses one among them. Notes Pay attention to the lifetimes of variables or objects passed to a function executed asynchronously. Instead of passing them as references, it may be better to copy them into the function . Passing variables or objects as references can lead to issues . Instead, passing them as pointers might be a better option . std::future and std::shared_future std::future std::future is a template class used to represent the result of an asynchronous operation . It provides a mechanism to access the result of a function that runs concurrently, typically on a separate thread. This allows a thread to retrieve results at some point in the future, once the asynchronous task has completed . std::future is generally used in combination with std::async , std::promise , or thread-based libraries . It acts as a placeholder for the result that will eventually become available. A std::future object cannot be copied , but it can be moved. Its header file is <future> . std::shared_future The class template std::shared_future provides a mechanism to access the result of asynchronous operations , similar to std::future , except that multiple threads are allowed to wait for the same shared state . Unlike std::future , which is only moveable (so only one instance can refer to any particular asynchronous result), std::shared_future is copyable and multiple shared future objects may refer to the same shared state . Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a shared_future object. Its header file is <future> . Declaration Syntax std::future< Type > fut_name; std::shared_future< Type > sfut_name; Initialization Syntax // Default constructor. std::future< Type > fut_name1; // Move constructor. std::future< Type > fut_name1 = std::move( fut_name1 ); // Default constructor. std::shared_future< Type > sfut_name1; // Copy constructor. std::shared_future< Type > sfut_name2 = sfut_name1; // Default constructor. std::shared_future< Type > sfut_name1; // Move constructor. std::shared_future< Type > sfut_name2 = std::move( sfut_name1 ); std::future< Type > fut_name; // Move constructor. std::shared_future< Type > sfut_name = std::move( fut_name ); Members and Related Stuffs Links std::future in cplusplus . std::future in cppreference . std::shared_future in cplusplus . std::shared_future in cppreference . Member Functions (constructor): Constructs the future object ( Only default and move ) (public member function). (destructor): Destructs the future object (public member function). operator= : Moves the future object ( Only Move ) (public member function). share (only for std::future ): Transfers the shared state from *this to a shared_future and returns it (public. member function) get : Returns the result if the result is available . Otherwise , blocks the calling thread . And only allows to call once .(public member function). valid : Checks if the future has a shared state (public member function). wait : Waits for the result to become available (public member function). wait_for : Waits for the result, returns if it is not available for the specified timeout duration (public member function). wait_until : Waits for the result, returns if it is not available until specified time point has been reached (public member function). std::future_status (Returned by wait_for and wait_until Functions) std::future_status::deferred : The shared state contains a deferred function, so the result will be computed only when explicitly requested. std::future_status::ready : The shared state is ready. std::future_status::timeout : The shared state did not become ready before specified timeout duration has passed. Differences Between std::future and std::shared_future Ownership: std::future : Sole ownership of the result. std::shared_future : Shared ownership; multiple instances can access the same result. Result retrieval: std::future : The result can only be retrieved once using get() . std::shared_future : The result can be retrieved multiple times by different instances. Copyability: std::future : Non-copyable but movable. std::shared_future : Copyable and movable; can be shared across multiple threads. Exception handling: Both: If the asynchronous task throws an exception, it is propagated on the first call to get() . std::shared_future : The same exception can be propagated multiple times across all calls to get() . Use case: std::future : When only one thread needs the result, and the result is used only once. std::shared_future : When multiple threads need access to the same result, or the result needs to be accessed multiple times. Conversion: std::future can be converted to std::shared_future using the share() function. std::promise Explanation A promise is an template class object that can store a value of type R to be retrieved by a std::future object (possibly in another thread), offering a synchronization point . On construction , promise objects are associated to a new shared state on which they can store either a value of type R or an exception derived from std::exception . This shared state can be associated to a std::future object by calling member get_future . After the call, both objects share the same shared state : The promise object is the asynchronous provider and is expected to set a value for the shared state at some point. The std::future object is an asynchronous return object that can retrieve the value of the shared state , waiting for it to be ready, if necessary. The lifetime of the shared state lasts at least until the last object with which it is associated releases it or is destroyed. Therefore, it can survive the promise object that obtained it in the first place if associated also to a future. Its header file is <future> . Syntax std::promise< Type > pro_name; // Get the `std::future` associated with the promise. std::future< Type > fut_name = pro_name.get_future(); // Convert it to a shared future. // Method that `std::shared_future` works with `std::promise`. std::shared_future< Type > sfut_name = fut_name.share(); std::promise< Type > pro_name; // Convert it to a shared future. // Method that `std::shared_future` works with `std::promise`. std::shared_future< Type > sfut_name = fut_name.share(); Related Stuffs Links std::promise in cplusplus . std::promise in cppreference . Member Functions (constructor): Constructs the promise object (public member function). (destructor): Destructs the promise object (public member function). operator= : Assigns the shared state (public member function). swap : Swaps two promise objects (public member function). get_future : Returns a future associated with the promised result (public member function). set_value : Sets the result to specific value (public member function). set_value_at_thread_exit : Sets the result to specific value while delivering the notification only at thread exit (public member function). set_exception : Sets the result to indicate an exception (public member function). set_exception_at_thread_exit : Sets the result to indicate an exception while delivering the notification only at thread exit (public member function). Non-member Functions std::swap( std::promise ) : Specializes the std::swap algorithm (function template). Helper Classes std::uses_allocator< std::promise > : specializes the std::uses_allocator type trait (class template specialization). Notes A game typically loads different objects asynchronously and in parallel using multiple threads. This is why, at times, players can control their characters while some objects remain unresponsive. To the best of my knowledge, all classes related to threads lack a copy constructor, except for some classes with a shared prefix or suffix. To prevent deadlock, the order of acquiring multiple locks must be consistent.","title":"Threads"},{"location":"Threads/#threads","text":"","title":"Threads"},{"location":"Threads/#explanation","text":"C++ provides native support for multithreading through the <thread> library , allowing programs to execute tasks concurrently on multiple cores. A thread is the smallest sequence of programmed instructions that can be managed independently by the scheduler. C++ uses the std::thread class to create and manage threads.","title":"Explanation"},{"location":"Threads/#stdthread","text":"","title":"std::thread"},{"location":"Threads/#explanation_1","text":"std::thread is a class that represents an individual thread of execution . A thread of execution is a sequence of instructions that can be executed concurrently with other such sequences in multithreading environments, while sharing a same address space . An initialized thread object represents an active thread of execution; Such a thread object is joinable , and has a unique thread id . A default-constructed (non-initialized) thread object is not joinable , and its thread id is common for all non-joinable threads . A joinable thread becomes not joinable if moved from, or if either join or detach are called on them. A std::thread object cannot be copied because its copy constructor is deleted. When some parameters of funName are lvalue references , you must wrap the corresponding arguments in std::ref (for non-const lvalue references) or std::cref (for const lvalue references) when passing them to std::thread . This is necessary because std::thread moves its arguments into the thread function by default, which can break lvalue reference bindings. Its header file is <thread> .","title":"Explanation"},{"location":"Threads/#declaration-syntax","text":"std::thread thread_name;","title":"Declaration Syntax"},{"location":"Threads/#initialization-syntax","text":"// Default constructor. std::thread thread_name; // Initialization constructor. std::thread thread_name( funName, arg_list_of_funName ); // Initialization constructor. std::thread thread_name( fun_ptr, arg_list_of_fun_ptr ); // Initialization constructor. std::thread thread_name( a_lambad_func, arg_list_of_the_lambad_func ); std::thread thread_name1( ... ); // Move constructor. std::thread thread_name2( std::move( thread_name1 ) ); std::thread thread_name1( ... ); // Move constructor. std::thread thread_name2 = std::move( thread_name1 );","title":"Initialization Syntax"},{"location":"Threads/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links","text":"std::thread in cplusplus . std::thread in cppreference .","title":"Links"},{"location":"Threads/#member-types","text":"native_handle_type (optional): Implementation-defined. id : Represents the id of a thread (public member class).","title":"Member Types"},{"location":"Threads/#member-functions","text":"(constructor): Constructs new thread object (public member function). (destructor): Destructs the thread object, underlying thread must be joined or detached (public member function). operator= : Moves the thread object (public member function). joinable : Checks whether the thread is joinable, i.e. potentially running in parallel context (public member function). get_id : Returns the id of the thread (public member function). native_handle : Returns the underlying implementation-defined thread handle (public member function). hardware_concurrency [ static ]: Returns the number of concurrent threads supported by the implementation (public static member function). join : Waits for the thread to finish its execution (public member function). detach : Permits the thread to execute independently from the thread handle (public member function). swap : Swaps two thread objects (public member function).","title":"Member functions"},{"location":"Threads/#non-member-functions","text":"std::swap( std::thread ) : Specializes the std::swap algorithm (function).","title":"Non-member functions"},{"location":"Threads/#see-also","text":"std::jthread (C++20): std::thread with support for auto-joining and cancellation (class).","title":"See also"},{"location":"Threads/#notes","text":"A thread starts executing when the std::thread object is defined, not when the join function is called. Calling join merely blocks the calling thread, waiting for the thread to finish and releasing its resources. A detached thread (a thread that has been detach ed) will release its resources either when the calling thread ends or when it finishes executing itself. However, it cannot safely access resources of the main thread unless those resources have been explicitly managed for concurrent access. Threads automatically release resources when their function completes. It is not recommended to forcefully terminate a thread using other methods, as this may cause memory leaks due to unreleased resources. A thread that is neither joined nor detached will throw an exception when the program exits.","title":"Notes"},{"location":"Threads/#stdjthread","text":"","title":"std::jthread"},{"location":"Threads/#explanation_2","text":"std::jthread is a class that represents a managed thread of execution with automatic joining and optional cooperative cancellation . std::jthread executes a sequence of instructions that can run concurrently with other threads, all sharing the same address space in a multithreaded environment. An initialized std::jthread object represents an active thread of execution that is automatically joined when the object is destroyed, making it safer and more convenient to manage. A default-constructed (non-initialized) std::jthread object is not joinable , and its thread id is set to a default value shared by all non-joinable threads . A std::jthread object becomes not joinable if it has been moved from, or after it completes its execution and is automatically joined. A std::jthread object cannot be copied because its copy constructor is deleted. Cooperative cancellation is supported through a stop_token , which allows a thread to respond to stop requests and terminate gracefully. Its header file is <thread> .","title":"Explanation"},{"location":"Threads/#declaration-syntax_1","text":"std::jthread thread_name;","title":"Declaration Syntax"},{"location":"Threads/#initialization-syntax_1","text":"// Default constructor. std::jthread thread_name; // Initialization constructor. std::jthread thread_name( funName, arg_list_of_funName ); // Initialization constructor. std::jthread thread_name( fun_ptr, arg_list_of_fun_ptr ); // Initialization constructor. std::jthread thread_name( a_lambad_func, arg_list_of_the_lambad_func ); std::jthread thread_name1( ... ); // Move constructor. std::jthread thread_name2( std::move( thread_name1 ) ); std::jthread thread_name1( ... ); // Move constructor. std::jthread thread_name2 = std::move( thread_name1 );","title":"Initialization Syntax"},{"location":"Threads/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_1","text":"std::jthread in cplusplus . std::jthread in cppreference .","title":"Links"},{"location":"Threads/#member-types_1","text":"native_handle_type (optional): Implementation-defined. id : Represents the id of a thread (public member class).","title":"Member Types"},{"location":"Threads/#member-functions_1","text":"(constructor): Constructs new thread object (public member function). (destructor): If the thread is joinable, then a stop is requested and the thread joins (public member function). operator= : Moves the jthread object (public member function). joinable : Checks whether the thread is joinable, i.e. potentially running in parallel context (public member function). get_id : Returns the id of the thread (public member function). native_handle : Returns the underlying implementation-defined thread handle (public member function). hardware_concurrency [ static ]: Returns the number of concurrent threads supported by the implementation (public static member function). join : Waits for the thread to finish its execution (public member function). detach : Permits the thread to execute independently from the thread handle (public member function). swap : Swaps two thread objects (public member function). get_stop_source : Returns a stop_source object associated with the shared stop state of the thread (public member function). get_stop_token : Returns a stop_token associated with the shared stop state of the thread (public member function). request_stop : Requests execution stop via the shared stop state of the thread (public member function).","title":"Member functions"},{"location":"Threads/#non-member-functions_1","text":"std::swap( std::jthread ) (C++20): Specializes the std::swap algorithm (function).","title":"Non-member functions"},{"location":"Threads/#stdthis_thread","text":"","title":"std::this_thread"},{"location":"Threads/#explanation_3","text":"The std::this_thread namespace provides utilities for interacting with the current thread of execution . It contains functions to retrieve the thread\u2019s ID, pause execution, or yield to other threads . Its header file is <thread> .","title":"Explanation"},{"location":"Threads/#links_2","text":"std::this_thread in cplusplus . std::this_thread in cppreference .","title":"Links"},{"location":"Threads/#stdthis_threadget_id","text":"","title":"std::this_thread::get_id"},{"location":"Threads/#explanation_4","text":"std::this_thread::get_id() is a function used to retrieve the ID of the current thread, which is useful for debugging or logging purposes.","title":"Explanation"},{"location":"Threads/#syntax","text":"// Its declaration syntax. std::thread::id get_id() noexcept;","title":"Syntax"},{"location":"Threads/#stdthis_threadsleep_for","text":"","title":"std::this_thread::sleep_for"},{"location":"Threads/#explanation_5","text":"std::this_thread::sleep_for is a function used to block the execution of the current thread for at least the specified sleep_duration . This function may block for longer than the sleep_duration due to scheduling or resource contention delays. The standard recommends that a steady clock be used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.","title":"Explanation"},{"location":"Threads/#syntax_1","text":"// Its declaration syntax. template< class Rep, class Period > void sleep_for( const std::chrono::duration< Rep, Period >& sleep_duration );","title":"Syntax"},{"location":"Threads/#stdthis_threadsleep_until","text":"","title":"std::this_thread::sleep_until"},{"location":"Threads/#explanation_6","text":"std::this_thread::sleep_until is a function used blocks the calling thread until the specified sleep_time . The execution of the current thread is paused until at least sleep_time , while other threads may continue to execute during this period.","title":"Explanation"},{"location":"Threads/#syntax_2","text":"// Its declaration syntax. template< class Clock, class Duration > void sleep_until( const std::chrono::time_point< Clock, Duration >& sleep_time );","title":"Syntax"},{"location":"Threads/#stdthis_threadyield","text":"","title":"std::this_thread::yield"},{"location":"Threads/#explanation_7","text":"The calling thread yields, offering the implementation the opportunity to reschedule . This function shall be called when a thread waits for other threads to advance without blocking.","title":"Explanation"},{"location":"Threads/#syntax_3","text":"// Its declaration syntax. void yield() noexcept;","title":"Syntax"},{"location":"Threads/#stdforward","text":"","title":"std::forward"},{"location":"Threads/#explanation_8","text":"std::forward is a utility function that is used for perfect forwarding of function arguments , ensuring that their value categories (whether they are lvalues or rvalues) are preserved during the forwarding process. It returns an rvalue reference to obj_name if obj_name is not an lvalue reference. If obj_name is an lvalue reference, the function returns obj_name without modifying its type. std::forward acts as a transfer station that preserves the original value category (whether it is an lvalue or an rvalue) of the argument it forwards . Its header file is <utility> .","title":"Explanation"},{"location":"Threads/#syntax_4","text":"// Its usage syntax. std::forward( obj_name ); // An usage example. #include <iostream> #include <utility> // For std::forward // Function to demonstrate perfect forwarding template< typename T > void wrapper( T&& arg ) { // Forward the argument to another function // This preserves whether arg is an lvalue or rvalue process( std::forward< T >( arg ) ); }; // Helper function to handle both lvalues and rvalues void process( int& x ) { std::cout << \"Lvalue processed: \" << x << std::endl; }; void process( int&& x ) { std::cout << \"Rvalue processed: \" << x << std::endl; }; int main() { int x = 42; wrapper( x ); // Lvalue passed, so it will call process(int&) wrapper( 10 ); // Rvalue passed, so it will call process(int&&) };","title":"Syntax"},{"location":"Threads/#stdref-and-stdcref","text":"","title":"std::ref and std::cref"},{"location":"Threads/#explanation_9","text":"std::ref is a utility function that creates a reference wrapper for a given object . It is used when you need to pass an argument by reference to a function, particularly in situations where a function or class expects its argument to be passed by value (like in std::thread or in certain algorithms that use copy semantics). The key purpose of std::ref is to ensure that arguments are passed as references even when the target function is expecting arguments by value . std::ref works like a reference , but it is not a true reference . Therefore, a function whose parameters are expecting a direct reference cannot directly receive a std::reference_wrapper . std::cref works similarly to std::ref , but it creates a reference wrapper for constant references . They are usually used with std::thread and std::async . Their header file is <functional> .","title":"Explanation"},{"location":"Threads/#syntax_5","text":"// Its usage syntax. std::ref( var_name ); std::cref( var_name );","title":"Syntax"},{"location":"Threads/#six-std-mutex-classes","text":"","title":"Six STD Mutex Classes"},{"location":"Threads/#stdmutex","text":"A mutex is a lockable object that is designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently and access the same memory locations . std::mutex objects provide exclusive ownership and do not support recursivity (i.e., a thread shall not lock a std::mutex it already owns) -- see std::recursive_mutex for an alternative class that does. It is guaranteed to be a standard-layout class . Its header file is <mutex> .","title":"std::mutex"},{"location":"Threads/#stdrecursive_mutex","text":"std::recursive_mutex is a lockable object , just like std::mutex , but allows the same thread to acquire multiple levels of ownership over the std::mutex object ( recursivity, recursive calls ). This allows to lock (or try-lock ) the mutex object from a thread that is already locking it, acquiring a new level of ownership over the std::mutex object: the std::mutex object will actually remain locked owning the thread until its member unlock is called as many times as this level of ownership. It is guaranteed to be a standard-layout class . Its header file is <mutex> .","title":"std::recursive_mutex"},{"location":"Threads/#stdtimed_mutex","text":"A timed mutex is a time lockable object that is designed to signal when critical sections of code need exclusive access, just like a regular mutex , but additionally supporting timed try-lock requests . As such, a std::timed_mutex has two additional members: try_lock_for and try_lock_until . It is guaranteed to be a standard-layout class. Its header file is <mutex> .","title":"std::timed_mutex"},{"location":"Threads/#stdrecursive_timed_mutex","text":"A recursive timed mutex combines both the features of std::recursive_mutex and the features of std::timed_mutex into a single class : it supports both acquiring multiple lock levels by a single thread and also timed try-lock requests. It is guaranteed to be a standard-layout class. Its header file is <mutex> .","title":"std::recursive_timed_mutex"},{"location":"Threads/#stdshared_mutex","text":"The std::shared_mutex template class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads . In contrast to other mutex types which facilitate exclusive access, a std::shared_mutex has two levels of access : shared (read-shared-data-only) : several threads can share ownership of the same mutex. exclusive (read-or-modify-shared-date) : only one thread can own the mutex. If one thread has acquired the exclusive lock (through lock , try_lock ) , no other threads can acquire the lock (including the shared). If one thread has acquired the shared lock (through lock_shared , try_lock_shared ) , no other thread can acquire the exclusive lock, but can acquire the shared lock. Only when the exclusive lock has not been acquired by any thread, the shared lock can be acquired by multiple threads. Within one thread, only one lock (shared or exclusive) can be acquired at the same time. Shared mutexes are especially useful when shared data can be safely read by any number of threads simultaneously , but a thread may only write the same data when no other thread is reading or writing at the same time . The std::shared_mutex class satisfies all requirements of SharedMutex and StandardLayoutType . Its header file is <mutex> .","title":"std::shared_mutex"},{"location":"Threads/#stdshared_timed_mutex","text":"The std::shared_timed_mutex template class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads . In contrast to other mutex types which facilitate exclusive access, a std::shared_timed_mutex has two levels of access : shared (read-shared-data-only) : several threads can share ownership of the same mutex. exclusive (read-or-modify-shared-date) : only one thread can own the mutex. Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so. In a manner similar to std::timed_mutex , std::shared_timed_mutex provides the ability to attempt to claim ownership of a std::shared_timed_mutex with a timeout via the try_lock_for() , try_lock_until() , try_lock_shared_for() , try_lock_shared_until() member functions. The std::shared_timed_mutex class satisfies all requirements of SharedTimedMutex and StandardLayoutType . Its header file is <mutex> .","title":"std::shared_timed_mutex"},{"location":"Threads/#syntax_6","text":"// Its usage syntax. std::mutex mutex_name; std::recursive_mutex rmutex_name; std::timed_mutex tmutex_name; std::recursive_timed_mutex rtmutex_name; std::shared_mutex smutex_name; std::shared_timed_mutex stmutex_name;","title":"Syntax"},{"location":"Threads/#members-and-related-stuffs_2","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_3","text":"<mutex> in cplusplus . <mutex> in cppreference . std::mutex in cplusplus . std::mutex in cppreference . std::recursive_mutex in cplusplus . std::recursive_mutex in cppreference . std::timed_mutex in cplusplus . std::timed_mutex in cppreference . std::recursive_timed_mutex in cplusplus . std::recursive_timed_mutex in cppreference .","title":"Links"},{"location":"Threads/#nested-types","text":"native_handle_type (optional*) : Implementation-defined.","title":"Nested Types"},{"location":"Threads/#member-functions_2","text":"(constructor): Constructs the mutex (public member function). (destructor): Destroys the mutex (public member function). operator=[deleted] : Not copy-assignabl (public member function). lock : Locks the mutex, blocks if the mutex is not available (public member function). try_lock : Tries to lock the mutex, returns if the mutex is not available (public member function). try_lock_for (only for std::timed_mutex , std::recursive_timed_mutex and std::shared_timed_mutex ): Tries to lock the mutex, returns if the mutex has been unavailable for the specified timeout duration (public member function). try_lock_until (only for std::timed_mutex , std::recursive_timed_mutex and std::shared_timed_mutex ): Tries to lock the mutex, returns if the mutex has been unavailable until specified time point has been reached (public member function). unlock : Unlocks the mutex (public member function). lock_shared (only for std::shared_mutex and std::shared_timed_mutex ): Locks the mutex for shared ownership, blocks if the mutex is not available (public member function). try_lock_shared (only for std::shared_mutex and std::shared_timed_mutex ): Tries to lock the mutex for shared ownership, returns if the mutex is not available (public member function). try_lock_shared_for (only for std::shared_timed_mutex ): Tries to lock the mutex for shared ownership, returns if the mutex has been unavailable for the specified timeout duration (public member function). try_lock_shared_until (only for std::shared_timed_mutex ): Tries to lock the mutex for shared ownership, returns if the mutex has been unavailable until specified time point has been reached (public member function). unlock_shared (only for std::shared_mutex and std::shared_timed_mutex ): Unlocks the mutex (shared ownership) (public member function). native_handle : Returns the underlying implementation-defined native handle object (public member function).","title":"Member Functions"},{"location":"Threads/#notes_1","text":"All lock classes or functions that receive mutex objects implement the locking or unlocking behavior by calling the mutex object's lock or unlock member functions. All mutex objects are passed to them by reference. All lock objects do not manage the lifetime of the mutex object in any way: the duration of the mutex object shall extend at least until the destruction of the lock object that locks it.","title":"Notes"},{"location":"Threads/#stdlock_guard","text":"","title":"std::lock_guard"},{"location":"Threads/#explanation_10","text":"std::lock_guard is a template class that manages a mutex object by keeping it always locked . On construction , the mutex object is locked by the calling thread, and on destruction , the mutex is unlocked . It is the simplest lock, and is specially useful as an object with automatic duration that lasts until the end of its context. In this way, it guarantees the mutex object is properly unlocked in case an exception is thrown. Its header file is <mutex> .","title":"Explanation"},{"location":"Threads/#syntax_7","text":"// Its usage syntax. MutexType mtx; std::lock_guard< MutexType > lck( mtx ); // Its usage syntax. MutexType mtx; mtx.lock(); std::lock_guard< MutexType > lck( mtx, std::adopt_lock );","title":"Syntax"},{"location":"Threads/#members-and-related-stuffs_3","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_4","text":"std::lock_guard in cplusplus . std::lock_guard in cppreference .","title":"Links"},{"location":"Threads/#template-parameters","text":"Mutex : The type of the mutex to lock. The type must meet the BasicLockable requirements.","title":"Template Parameters"},{"location":"Threads/#member-types_2","text":"mutex_type : Mutex .","title":"Member Types"},{"location":"Threads/#member-functions_3","text":"(constructor): Constructs a lock_guard , optionally locking the given mutex. Not copy-constructable (public member function). (destructor): Destructs the lock_guard object, unlocks the underlying mutex (public member function). operator=[deleted] : Not copy-assignable (public member function).","title":"Member Functions"},{"location":"Threads/#stdunique_lock-and-stdshared_lock","text":"","title":"std::unique_lock and std::shared_lock"},{"location":"Threads/#stdunique_lock","text":"std::unique_lock is a template class that manages a mutex object with unique ownership in both states : locked and unlocked . On construction (or by move-assigning to it), the object acquires a mutex object , for whose locking and unlocking operations becomes responsible. This class guarantees an unlocked status on destruction (even if not called explicitly). Therefore it is especially useful as an object with automatic duration, as it guarantees the mutex object is properly unlocked in case an exception is thrown. Even when working with a shared mutex , std::unique_lock essentially behaves like a normal lock , blocking other threads from accessing the shared data. This is because a std::unique_lock provides exclusive access to the resource, preventing other threads from acquiring either a shared or exclusive lock until the unique lock is released. Its header file is <mutex> .","title":"std::unique_lock"},{"location":"Threads/#stdshared_lock","text":"std::shared_lock is a template class that manages a mutex object with shared ownership . On construction (or by move-assigning to it), the object acquires a shared lock on a mutex object, allowing multiple threads to hold the lock concurrently . This class guarantees an unlocked status on destruction , releasing the shared lock when the std::shared_lock object goes out of scope. It is especially useful for shared access to a resource when multiple threads need to read from it concurrently , without blocking each other. However, that std::shared_lock provides only shared access to the resource, meaning exclusive access is not possible while a shared lock is held. While acquiring a shared lock allows other threads to also acquire shared locks, no thread can acquire an exclusive lock until all shared locks are released. The class does not manage the lifetime of the mutex object. The MutexType used with std::shared_lock must be a shared mutex type . Its header file is <shared_mutex> .","title":"std::shared_lock"},{"location":"Threads/#syntax_8","text":"// Its usage syntax. MutexType mtx; std::unique_lock< MutexType > ulck( mtx ); std::shared_lock< MutexType > slck( mtx ); // Its usage syntax. MutexType mtx; std::unique_lock< MutexType > ulck1( mtx ); std::shared_lock< MutexType > slck1( mtx ); // Move constructor. std::unique_lock< MutexType > ulck2( std::move( ulck1 ) ); std::shared_lock< MutexType > slck2( std::move( slck1 ) ); // Its usage syntax. MutexType mtx; std::unique_lock< MutexType > ulck( mtx, std::defer_lock ); ulck.lock(); std::shared_lock< MutexType > slck( mtx, std::defer_lock ); slck.lock(); // Its usage syntax. MutexType mtx; mtx.lock(); std::unique_lock< MutexType > ulck( mtx, std::try_to_lock ); if( ulck.owns_lock() ) { // Critical section: code that must be executed atomically. } else { // Lock acquisition failed, handle the situation appropriately. }; std::shared_lock< MutexType > slck( mtx, std::try_to_lock ); if( slck.owns_lock() ) { // Critical section: code that must be executed atomically. } else { // Lock acquisition failed, handle the situation appropriately. }; // Its usage syntax. MutexType mtx; mtx.lock(); std::unique_lock< MutexType > ulck( mtx, std::adopt_lock ); std::shared_lock< MutexType > slck( mtx, std::adopt_lock ); // Its usage syntax. MutexType mtx; std::chrono::duration< Type, std::ratio< num1, num2 >(Optional) > dur; std::unique_lock< MutexType > ulck( mtx, dur ); std::shared_lock< MutexType > slck( mtx, dur ); // Its usage syntax. MutexType mtx; std::chrono::time_point< Clock > tpoint; std::unique_lock< MutexType > ulck( mtx, tpoint ); std::shared_lock< MutexType > slck( mtx, tpoint );","title":"Syntax"},{"location":"Threads/#members-and-related-stuffs_4","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_5","text":"std::unique_lock in cplusplus . std::unique_lock in cppreference . std::shared_lock in cplusplus . std::shared_lock in cppreference .","title":"Links"},{"location":"Threads/#template-parameters_1","text":"Mutex : The type of the mutex to lock. The type must meet the BasicLockable requirements.","title":"Template Parameters"},{"location":"Threads/#nested-types_1","text":"mutex_type : Mutex .","title":"Nested Types"},{"location":"Threads/#member-functions_4","text":"(constructor): Constructs a std::unique_lock , optionally locking (i.e., taking ownership of) the supplied mutex (public member function). (destructor): Unlocks (i.e., releases ownership of) the associated mutex, if owned (public member function). operator= : Unlocks (i.e., releases ownership of) the mutex, if owned, and acquires ownership of another (public member function). lock : Locks (i.e., takes ownership of) the associated mutex (public member function). try_lock : Tries to lock (i.e., takes ownership of) the associated mutex without blocking (public member function). try_lock_for : Attempts to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable for the specified time duration (public member function). try_lock_until : Tries to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable until specified time point has been reached (public member function). unlock : Unlocks (i.e., releases ownership of) the associated mutex (public member function). swap : Swaps state with another std::unique_lock (public member function). release : Disassociates the associated mutex without unlocking (i.e., releasing ownership of) it (public member function). mutex : Returns a pointer to the associated mutex (public member function). owns_lock : Tests whether the lock owns (i.e., has locked) its associated mutex (public member function). operator bool : Tests whether the lock owns (i.e., has locked) its associated mutex (public member function).","title":"Member Functions"},{"location":"Threads/#non-member-functions_2","text":"std::swap( std::unique_lock ) (C++11), std::swap( std::unique_lock ) (C++11): Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"Threads/#stdscoped_lock","text":"","title":"std::scoped_lock"},{"location":"Threads/#explanation_11","text":"The template class std::scoped_lock is a mutex wrapper that provides a convenient RAII-style mechanism for owning zero or more mutexes for the duration of a scoped block. When a std::scoped_lock object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the std::scoped_lock object was created, the std::scoped_lock is destructed and the mutexes are released. If several mutexes are given , deadlock avoidance algorithm is used as if by std::lock . The std::scoped_lock class is non-copyable . Its header file is <mutex> .","title":"Explanation"},{"location":"Threads/#syntax_9","text":"// Its declaration syntax. template< class... MutexTypes > class scoped_lock; // Its declaration syntax. MutexType1 mtx1; MutexType2 mtx2; ...; std::scoped_lock< MutexType1, MutexType2, ... > lck( mtx1, mtx2, ... ); // Its declaration syntax. MutexType1 mtx1; MutexType2 mtx2; ...; mtx1.lock; mtx2.lock; ...; std::scoped_lock< MutexType1, MutexType2, ... > lck( std::adopt_lock, mtx1, mtx2, ... );","title":"Syntax"},{"location":"Threads/#members-and-related-stuffs_5","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_6","text":"std::scoped_lock in cplusplus . std::scoped_lock in cppreference .","title":"Links"},{"location":"Threads/#template-parameters_2","text":"MutexTypes : The types of the mutexes to lock. The types must meet the Lockable requirements unless sizeof...( MutexTypes ) == 1 , in which case the only type must meet BasicLockable.","title":"Template Parameters"},{"location":"Threads/#member-types_3","text":"mutex_type (conditionally present): If sizeof...( MutexTypes ) == 1 , member type mutex_type is the same as Mutex, the sole type in MutexTypes... . Otherwise, there is no member mutex_type .","title":"Member Types"},{"location":"Threads/#member-functions_5","text":"(constructor): Constructs a std::scoped_lock , optionally locking the given mutexes (public member function). (destructor): Destructs the std::scoped_lock object, unlocks the underlying mutexes (public member function). operator=[deleted] : Not copy-assignable (public member function).","title":"Member Functions"},{"location":"Threads/#stdlock-and-stdtry_lock","text":"","title":"std::lock and std::try_lock"},{"location":"Threads/#stdlock","text":"std::lock locks all the objects passed as arguments , blocking the calling thread if necessary. The function locks the objects using an unspecified sequence of calls to their members lock, try_lock and unlock that ensures that all arguments are locked on return (without producing any deadlocks). If the function cannot lock all objects (such as because one of its internal calls threw an exception ), the function first unlocks all objects it successfully locked (if any) before failing. To prevent deadlock, the order of acquiring multiple locks must be consistent . Its header file is <mutex> .","title":"std::lock"},{"location":"Threads/#stdtry_lock","text":"std::try_lock attempts to lock all the objects passed as arguments using their std::try_lock member functions (non-blocking) . The function calls the std::try_lock member function for each argument (first lock1 , then lock2 , and eventually the others in lockn , in the same order), until either all calls are successful, or as soon as one of the calls fails (either by returning false or throwing an exception). If the function ends because a call fails , unlock is called on all objects for which the call to std::try_lock was successful, and the function returns the argument order number of the object whose lock failed . No further calls are performed for the remaining objects in the argument list. If the function locks all mutex objects successfully, it returns -1 . Its header file is <mutex> .","title":"std::try_lock"},{"location":"Threads/#syntax_10","text":"// Its declaration syntax. template< class Lockable1, class Lockable2, class... LockableN > void lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn ); // Its declaration syntax. template< class Lockable1, class Lockable2, class... LockableN > int try_lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn );","title":"Syntax"},{"location":"Threads/#three-lock-type-tags","text":"<mutex> in cplusplus . <mutex> in cppreference . std::defer : A constexpr defer_lock_t object. Do not acquire ownership of the mutex. std::try_to_lock : A constexpr try_to_lock_t object. Try to acquire ownership of the mutex without blocking. std::adopt_lock : A constexpr adopt_lock_t object. Assume the calling thread already has ownership of the mutex.","title":"Three Lock Type Tags"},{"location":"Threads/#stdcall_once-and-stdonce_flag","text":"","title":"std::call_once and std::once_flag"},{"location":"Threads/#explanation_12","text":"std::call_once executes the callable object f exactly once , even if called concurrently from several threads . std::once_flag is a helper object to ensure that std::call_once invokes the function only once .","title":"Explanation"},{"location":"Threads/#syntax_11","text":"// Its declaration syntax. template< class Callable, class... Args > void call_once( std::once_flag& flag, Callable&& f, Args&&... args );","title":"Syntax"},{"location":"Threads/#stdatomic-and-stdatomic_ref","text":"","title":"std::atomic and std::atomic_ref"},{"location":"Threads/#stdatomic","text":"std::atomic is a template class that provides a variety of atomic operations that guarantee the integrity of data access across multiple threads . These operations include read-modify-write operations and compare-and-swap (CAS) operations . These operations are implemented using hardware-level atomic instructions, ensuring that they are indivisible and cannot be interrupted by other threads . std::atomic allows you to specify the memory ordering of operations , which determines how operations on different threads are synchronized . This is crucial for ensuring correct behavior in complex concurrent programs. Many of the operations provided by std::atomic are lock-free , meaning they don't require explicit locking mechanisms. Besides, some operations are wait-free , ensuring that a thread will eventually succeed in its operation, even if other threads are also contending. These two features can significantly improve performance in high-concurrency scenarios . The std::atomic class is non-copyable . Its header file is <atomic> .","title":"std::atomic"},{"location":"Threads/#stdatomic_ref","text":"std::atomic_ref is a template class that provides atomic operations on non-atomic objects , allowing them to be accessed safely across multiple threads. It works by wrapping a reference to an existing object and providing atomic operations such as read-modify-write and compare-and-swap (CAS) on the referenced object. These operations are implemented using hardware-level atomic instructions , ensuring that they are indivisible and cannot be interrupted by other threads . std::atomic_ref allows you to specify the memory ordering of operations , which determines how operations on different threads are synchronized . This ensures correct behavior in multi-threaded programs, even when dealing with non-atomic types. Unlike std::atomic , which requires atomic types, std::atomic_ref works with regular types like int , double , and user-defined types. The class does not manage the lifetime of the referenced object, meaning you must ensure that the referenced object remains valid for the duration of the atomic operations. The use of std::atomic_ref can help reduce the overhead of atomic operations on non-atomic objects and improve performance in multi-threaded scenarios. std::atomic_ref is non-copyable , ensuring that the reference is consistent across multiple threads. Its header file is <atomic> .","title":"std::atomic_ref"},{"location":"Threads/#syntax_12","text":"// Its usage syntax. std::atomic< Type > avar_name1; Type obj_name; avar_name1 = obj_name; // Allows temporary objects. std::atomic< Type > avar_name2( obj_name ); // Its usage syntax. Type obj_name; // Constructs an `atomic_ref` object referencing the object `obj_name`. std::atomic_ref< Type > avar_name1( obj_name ); // Constructs an `atomic_ref` object referencing the object `avar_name1`. std::atomic_ref< Type > avar_name2( avar_name1 );","title":"Syntax"},{"location":"Threads/#members-and-related-stuffs_6","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_7","text":"<atomic> in cplusplus . <atomic> in cppreference . std::atomic in cplusplus . std::atomic in cppreference .","title":"Links"},{"location":"Threads/#member-types_4","text":"value_type : T (regardless of whether specialized or not). difference_type : value_type (only for atomic< Integral > and atomic< Floating > (since C++20) specializations), std::ptrdiff_t (only for std::atomic< U* > specializations). difference_type is not defined in the primary std::atomic template or in the partial specializations for std::shared_ptr and std::weak_ptr .","title":"Member Types"},{"location":"Threads/#member-functions_6","text":"(constructor): Constructs an atomic object (public member function). operator= : Stores a value into an atomic object (public member function). is_lock_free : Checks if the atomic object is lock-free (public member function). store : Atomically replaces the value of the atomic object with a non-atomic argument (public member function). load : Atomically obtains the value of the atomic object (public member function). operator T : Loads a value from an atomic object (public member function). exchange : Atomically replaces the value of the atomic object and obtains the value held previously (public member function). compare_exchange_weak , compare_exchange_strong : Atomically compares the value of the atomic object with non-atomic argument and performs atomic exchange if equal or atomic load if not (public member function). wait (C++20): Blocks the thread until notified and the atomic value changes (public member function). notify_one (C++20): Notifies at least one thread waiting on the atomic object (public member function). notify_all (C++20): Notifies all threads blocked waiting on the atomic object (public member function).","title":"Member Functions"},{"location":"Threads/#constants","text":"is_always_lock_free [ static ] (C++17): Indicates that the type is always lock-free (public static member constant). required_alignment [ static ] (only for std::atomic_ref): Indicates the required alignment of an object to be referenced by atomic_ref` (public static member constant).","title":"Constants"},{"location":"Threads/#specialized-member-functions","text":"","title":"Specialized Member Functions"},{"location":"Threads/#specialized-for-integral-floating-point-since-c20-and-pointer-types","text":"fetch_add : Atomically adds the argument to the value stored in the atomic object and obtains the value held previously (public member function). fetch_sub : Atomically subtracts the argument from the value stored in the atomic object and obtains the value held previously (public member function). operator+=/-= : Adds to or subtracts from the atomic value (public member function).","title":"Specialized for Integral, Floating-point (Since C++20) and Pointer Types"},{"location":"Threads/#specialized-for-integral-and-pointer-types-only","text":"fetch_max (C++26): Atomically performs std::max between the argument and the value of the atomic object and obtains the value held previously (public member function). fetch_min (C++26): Atomically performs std::min between the argument and the value of the atomic object and obtains the value held previously (public member function). operator++/++(int)/--/--(int) : Increments or decrements the atomic value by one (public member function).","title":"Specialized for Integral and Pointer Types Only"},{"location":"Threads/#specialized-for-integral-types-only","text":"fetch_and : Atomically performs bitwise AND between the argument and the value of the atomic object and obtains the value held previously (public member function). fetch_or : Atomically performs bitwise OR between the argument and the value of the atomic object and obtains the value held previously (public member function). fetch_xor : Atomically performs bitwise XOR between the argument and the value of the atomic object and obtains the value held previously (public member function). operator&=/|=/^= : Performs bitwise AND, OR, XOR with the atomic value (public member function).","title":"Specialized for Integral Types Only"},{"location":"Threads/#type-aliases-only-for-stdatomic","text":"std::atomic in cplusplus . std::atomic in cppreference .","title":"Type Aliases (Only for std::atomic)"},{"location":"Threads/#stdcondition_variable-and-stdcondition_variable_any","text":"","title":"std::condition_variable and std::condition_variable_any"},{"location":"Threads/#stdcondition_variable","text":"A condition variable is a class object able to block the calling thread until notified to resume . It uses a std::unique_lock (over a mutex) to lock the thread when one of its wait functions is called. The thread remains blocked until woken up by another thread that calls a notification function on the same std::condition_variable object . Objects of type std::condition_variable always use std::unique_lock< std::mutex > to wait : for an alternative that works with any kind of lockable type, see std::condition_variable_any . Its header file is <condition_variable> .","title":"std::condition_variable"},{"location":"Threads/#stdcondition_variable_any","text":"It's the same as std::condition_variable , except that its wait functions can take any lockable type as argument ( std::condition_variable objects can only take std::unique_lock< std::mutex > ). Other than that, they are identical. However, std::condition_variable_any is slower than std::condition_variable . Its header file is <condition_variable> .","title":"std::condition_variable_any"},{"location":"Threads/#examples","text":"// condition_variable example #include <iostream> // std::cout #include <thread> // std::thread #include <mutex> // std::mutex, std::unique_lock #include <condition_variable> // std::condition_variable std::mutex mtx; std::condition_variable cv; bool ready = false; void print_id( int id ) { std::unique_lock< std::mutex > lck( mtx ); while( !ready ) cv.wait( lck ); // ...; std::cout << \"thread \" << id << '\\n'; }; void go() { std::unique_lock< std::mutex > lck( mtx ); ready = true; cv.notify_all(); }; int main() { std::thread threads[10]; // spawn 10 threads: for( int i = 0; i < 10; ++i ) threads[i] = std::thread( print_id, i ); std::cout << \"10 threads ready to race...\\n\"; go(); // go! for( auto& th: threads ) th.join(); return 0; };","title":"Examples"},{"location":"Threads/#members-and-related-stuffs_7","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_8","text":"<condition_variable> in cplusplus . <condition_variable> in cppreference . std::condition_variable in cplusplus . std::condition_variable in cppreference . std::condition_variable_any in cplusplus . std::condition_variable_any in cppreference .","title":"Links"},{"location":"Threads/#nested-types_2","text":"native_handle_type : Implementation-defined.","title":"Nested Types"},{"location":"Threads/#member-functions_7","text":"(constructor): Constructs the object (public member function). (destructor): Destructs the object (public member function). operator=[deleted] : Not copy-assignable (public member function). notify_one : Notifies one waiting thread (public member function). notify_all : Notifies all waiting threads (public member function). wait : Blocks the current thread until the condition variable is awakened (public member function). wait_for : Blocks the current thread until the condition variable is awakened or after the specified timeout duration (public member function). wait_until : Blocks the current thread until the condition variable is awakened or until specified time point has been reached (public member function). native_handle : Returns the native handle (public member function).","title":"Member Functions"},{"location":"Threads/#stdnotify_all_at_thread_exit","text":"","title":"std::notify_all_at_thread_exit"},{"location":"Threads/#explanation_13","text":"When the calling thread exits , all threads waiting on cond are notified to resume execution. The function also acquires ownership of the lock on the mutex object managed by lck , which is stored internally by the function and unlocked at thread exit (just before notifying all threads ), behaving as if the following was called once all objects with thread storage duration have been destroyed: lck.unlock() ; cond.notify_all() ;","title":"Explanation"},{"location":"Threads/#syntax_13","text":"// Its declaration syntax. void notify_all_at_thread_exit( std::condition_variable& cond, std::unique_lock< std::mutex > lk );","title":"Syntax"},{"location":"Threads/#stdasync","text":"","title":"std::async"},{"location":"Threads/#explanation_14","text":"std::async is a template function that calls F (with Args as arguments) at some point, returning without waiting for the execution of F to complete . The value returned by F can be accessed through the future object returned (by calling its member future::get ). The second version (2) lets the caller select a specific launching policy , while the first version (1) uses automatic selection , as if calling (2) with launch::async | launch::deferred as policy. Its header file is <future> .","title":"Explanation"},{"location":"Threads/#syntax_14","text":"// Declaration syntax. // The first version. template< class F, class... Args > std::future< /* see below */ > async( F&& f, Args&&... args ); // (since C++11) // Declaration syntax. // The second version. template< class F, class... Args > std::future< /* see below */ > async( std::launch policy, F&& f, Args&&... args ); // (since C++11) // Usage syntax. std::future< RetType > obj_name = std::async( ... );","title":"Syntax"},{"location":"Threads/#related-stuffs","text":"","title":"Related Stuffs"},{"location":"Threads/#links_9","text":"std::async in cplusplus . std::async in cppreference .","title":"Links"},{"location":"Threads/#parameters","text":"f : Callable object to call. args : Parameters to pass to f . policy : Bitmask value, where individual bits control the allowed methods of execution.","title":"Parameters"},{"location":"Threads/#return-value","text":"std::future : Referring to the shared state created by this call to std::async .","title":"Return Value"},{"location":"Threads/#launching-policies","text":"Asynchronous ( launch::async ): Launches a new thread to call F (as if a thread object is constructed with F and Args as arguments, and accessing the shared state of the returned future joins it). Deferred ( launch::deferred ): The call to F is deferred until the shared state of the returned future is accessed (with wait or get ). At that point, F is called and the function is no longer considered deferred. When this call returns, the shared state of the returned future is made ready. Automatic ( launch::async | launch::deferred ): The function chooses the policy automatically (at some point). This depends on the system and library implementation , which generally optimizes for the current availability of concurrency in the system. Particular library implementations may support additional launching policies, with the proper label defined in type launch. Combining multiple values is possible, in which case, the function automatically chooses one among them.","title":"Launching Policies"},{"location":"Threads/#notes_2","text":"Pay attention to the lifetimes of variables or objects passed to a function executed asynchronously. Instead of passing them as references, it may be better to copy them into the function . Passing variables or objects as references can lead to issues . Instead, passing them as pointers might be a better option .","title":"Notes"},{"location":"Threads/#stdfuture-and-stdshared_future","text":"","title":"std::future and std::shared_future"},{"location":"Threads/#stdfuture","text":"std::future is a template class used to represent the result of an asynchronous operation . It provides a mechanism to access the result of a function that runs concurrently, typically on a separate thread. This allows a thread to retrieve results at some point in the future, once the asynchronous task has completed . std::future is generally used in combination with std::async , std::promise , or thread-based libraries . It acts as a placeholder for the result that will eventually become available. A std::future object cannot be copied , but it can be moved. Its header file is <future> .","title":"std::future"},{"location":"Threads/#stdshared_future","text":"The class template std::shared_future provides a mechanism to access the result of asynchronous operations , similar to std::future , except that multiple threads are allowed to wait for the same shared state . Unlike std::future , which is only moveable (so only one instance can refer to any particular asynchronous result), std::shared_future is copyable and multiple shared future objects may refer to the same shared state . Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a shared_future object. Its header file is <future> .","title":"std::shared_future"},{"location":"Threads/#declaration-syntax_2","text":"std::future< Type > fut_name; std::shared_future< Type > sfut_name;","title":"Declaration Syntax"},{"location":"Threads/#initialization-syntax_2","text":"// Default constructor. std::future< Type > fut_name1; // Move constructor. std::future< Type > fut_name1 = std::move( fut_name1 ); // Default constructor. std::shared_future< Type > sfut_name1; // Copy constructor. std::shared_future< Type > sfut_name2 = sfut_name1; // Default constructor. std::shared_future< Type > sfut_name1; // Move constructor. std::shared_future< Type > sfut_name2 = std::move( sfut_name1 ); std::future< Type > fut_name; // Move constructor. std::shared_future< Type > sfut_name = std::move( fut_name );","title":"Initialization Syntax"},{"location":"Threads/#members-and-related-stuffs_8","text":"","title":"Members and Related Stuffs"},{"location":"Threads/#links_10","text":"std::future in cplusplus . std::future in cppreference . std::shared_future in cplusplus . std::shared_future in cppreference .","title":"Links"},{"location":"Threads/#member-functions_8","text":"(constructor): Constructs the future object ( Only default and move ) (public member function). (destructor): Destructs the future object (public member function). operator= : Moves the future object ( Only Move ) (public member function). share (only for std::future ): Transfers the shared state from *this to a shared_future and returns it (public. member function) get : Returns the result if the result is available . Otherwise , blocks the calling thread . And only allows to call once .(public member function). valid : Checks if the future has a shared state (public member function). wait : Waits for the result to become available (public member function). wait_for : Waits for the result, returns if it is not available for the specified timeout duration (public member function). wait_until : Waits for the result, returns if it is not available until specified time point has been reached (public member function).","title":"Member Functions"},{"location":"Threads/#stdfuture_status-returned-by-wait_for-and-wait_until-functions","text":"std::future_status::deferred : The shared state contains a deferred function, so the result will be computed only when explicitly requested. std::future_status::ready : The shared state is ready. std::future_status::timeout : The shared state did not become ready before specified timeout duration has passed.","title":"std::future_status (Returned by wait_for and wait_until Functions)"},{"location":"Threads/#differences-between-stdfuture-and-stdshared_future","text":"Ownership: std::future : Sole ownership of the result. std::shared_future : Shared ownership; multiple instances can access the same result. Result retrieval: std::future : The result can only be retrieved once using get() . std::shared_future : The result can be retrieved multiple times by different instances. Copyability: std::future : Non-copyable but movable. std::shared_future : Copyable and movable; can be shared across multiple threads. Exception handling: Both: If the asynchronous task throws an exception, it is propagated on the first call to get() . std::shared_future : The same exception can be propagated multiple times across all calls to get() . Use case: std::future : When only one thread needs the result, and the result is used only once. std::shared_future : When multiple threads need access to the same result, or the result needs to be accessed multiple times. Conversion: std::future can be converted to std::shared_future using the share() function.","title":"Differences Between std::future and std::shared_future"},{"location":"Threads/#stdpromise","text":"","title":"std::promise"},{"location":"Threads/#explanation_15","text":"A promise is an template class object that can store a value of type R to be retrieved by a std::future object (possibly in another thread), offering a synchronization point . On construction , promise objects are associated to a new shared state on which they can store either a value of type R or an exception derived from std::exception . This shared state can be associated to a std::future object by calling member get_future . After the call, both objects share the same shared state : The promise object is the asynchronous provider and is expected to set a value for the shared state at some point. The std::future object is an asynchronous return object that can retrieve the value of the shared state , waiting for it to be ready, if necessary. The lifetime of the shared state lasts at least until the last object with which it is associated releases it or is destroyed. Therefore, it can survive the promise object that obtained it in the first place if associated also to a future. Its header file is <future> .","title":"Explanation"},{"location":"Threads/#syntax_15","text":"std::promise< Type > pro_name; // Get the `std::future` associated with the promise. std::future< Type > fut_name = pro_name.get_future(); // Convert it to a shared future. // Method that `std::shared_future` works with `std::promise`. std::shared_future< Type > sfut_name = fut_name.share(); std::promise< Type > pro_name; // Convert it to a shared future. // Method that `std::shared_future` works with `std::promise`. std::shared_future< Type > sfut_name = fut_name.share();","title":"Syntax"},{"location":"Threads/#related-stuffs_1","text":"","title":"Related Stuffs"},{"location":"Threads/#links_11","text":"std::promise in cplusplus . std::promise in cppreference .","title":"Links"},{"location":"Threads/#member-functions_9","text":"(constructor): Constructs the promise object (public member function). (destructor): Destructs the promise object (public member function). operator= : Assigns the shared state (public member function). swap : Swaps two promise objects (public member function). get_future : Returns a future associated with the promised result (public member function). set_value : Sets the result to specific value (public member function). set_value_at_thread_exit : Sets the result to specific value while delivering the notification only at thread exit (public member function). set_exception : Sets the result to indicate an exception (public member function). set_exception_at_thread_exit : Sets the result to indicate an exception while delivering the notification only at thread exit (public member function).","title":"Member Functions"},{"location":"Threads/#non-member-functions_3","text":"std::swap( std::promise ) : Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"Threads/#helper-classes","text":"std::uses_allocator< std::promise > : specializes the std::uses_allocator type trait (class template specialization).","title":"Helper Classes"},{"location":"Threads/#notes_3","text":"A game typically loads different objects asynchronously and in parallel using multiple threads. This is why, at times, players can control their characters while some objects remain unresponsive. To the best of my knowledge, all classes related to threads lack a copy constructor, except for some classes with a shared prefix or suffix. To prevent deadlock, the order of acquiring multiple locks must be consistent.","title":"Notes"},{"location":"Timers/","text":"std::chrono Namespace Explanation Links Durations Explanation Syntax Realted Stuffs Links Template Instantiations Member Types Member Functions Non-member Functions Helper Classes Helper Specializations Literals Time Points Explanation Syntax Realted Stuffs Links Template Parameters Member Types Member Functions Non-member Functions Helper Classes Clocks Explanation Syntax Related Stuffs of Three Clock Classes Links Member Types of Three Clock Classes Member Constants of Three Clock Classes Member Functions of Three Clock Classes Member Functions of std::chrono::system_clock Common Usage Syntax Notes std::chrono Namespace Explanation chrono is the name of a header , but also of a sub-namespace : All the elements in this header (except for the common_type specializations) are not defined directly under the std namespace (like most of the standard library) but under the std::chrono namespace . The elements in this header deal with time. This is done mainly by means of three concepts : durations, time points and clocks . Links std::chrono in cplusplus . std::chrono in cppreference . Durations Explanation Durations are template classes that measure time spans by means of a count and a period., like: one minute, two hours, or ten milliseconds. For the std::chrono::duration class, only std::ratio< num1, num2 > can be used . The corresponding named types of std::ratio< num1, num2 > (e.g., std::chrono::seconds ) cannot be used directly in std::chrono::duration ; instead, use std::ratio< num1, num2 > (e.g., std::ratio< 1, 1 > ). However, std::chrono::time_point , std::chrono::time_point_cast , and std::chrono::duration_cast support these named types. In some C++ STL types, std::ratio< num1, num2 > has alias names , such as std::milli . Syntax // Declaration syntax. template< class Rep, class Period = ratio< 1 > > class duration; // Usage syntax. // Default constructor. std::chrono::duration< Type, std::ratio< num1, num2 >(Optional) > dur1; // Copy constructor. std::chrono::duration< Type, std::ratio< num1, num2 >(Optional) > dur2( dur1 ); // Usage syntax. // Default constructor. std::chrono::duration< Type1, std::ratio< num1, num2 >(Optional) > dur1; // Conversion constructor. std::chrono::duration< Type2, std::ratio< num3, num4 > > dur2( dur1 ); Realted Stuffs Links std::chrono::duration in cplusplus . std::chrono::duration in cppreference . Template Instantiations All of these are alias names are predefined std::chrono::duration specializations . std::chrono::hours : Signed integral type of at least 23 bits, period std::ratio< 3600, 1 > . std::chrono::minutes : Signed integral type of at least 29 bits, period std::ratio< 60, 1 > . std::chrono::seconds (Default period): Signed integral type of at least 35 bits, period std::ratio< 1, 1 > . std::chrono::milliseconds : Signed integral type of at least 45 bits, period std::ratio< 1, 1000 > . std::chrono::microseconds : Signed integral type of at least 55 bits, period std::ratio< 1, 1000000 > . std::chrono::nanoseconds : Signed integral type of at least 64 bits, period std::ratio< 1, 1000000000 > . Member Types rep : Rep , an arithmetic type, or a class emulating an arithmetic type, representing the number of ticks. period : Period (until C++17) typename Period::type(since C++17) , a std::ratio representing the tick period (i.e. the number of second's fractions per tick). Member Functions (constructor) : Constructs new duration (public member function). (destructor) : Destroy duration (public member function). count : Returns the count of ticks (public member function). zero [ static ]: Returns the special duration value zero (public static member function). min [ static ]: Returns the special duration value min (public static member function). max [ static ]: Returns the special duration value max (public static member function). Non-member Functions operators : Duration operators (function template). duration_cast : Converts a duration to another, with a different tick interval (function template). floor( std::chrono::duration ) (C++17): Converts a duration to another, rounding down (function template). ceil( std::chrono::duration ) (C++17): Converts a duration to another, rounding up (function template). round( std::chrono::duration ) (C++17): Converts a duration to another, rounding to nearest, ties to even (function template). abs( std::chrono::duration ) (C++17): Obtains the absolute value of the duration (function template). from_stream (C++20): Parses a duration from a stream according to the provided format (function template). Helper Classes std::common_type< std::chrono::duration > : Specializes the std::common_type trait (class template specialization). treat_as_floating_point : Indicates that a duration is convertible to duration with different tick period (class template). duration_values : Constructs zero, min, and max values of a tick count of given type (class template). std::formatter< std::chrono::duration > (C++20): Formatting support for duration (class template specialization). std::hash< std::chrono::duration > (C++26): Hash support for std::chrono::duration (class template specialization). Helper Specializations template< class Rep, class Period > constexpr bool enable_nonlocking_formatter_optimization< chrono::duration< Rep, Period > > = enable_nonlocking_formatter_optimization< Rep >; (since C++23): This specialization of std::enable_nonlocking_formatter_optimization enables efficient implementation of std::print and std::println for printing a std::chrono::duration object when the template parameter Rep enables it. Literals Defined in inline namespace std::literals::chrono_literals . operator\"\"h (C++14): A std::chrono::duration literal representing hours (function). operator\"\"min (C++14): A std::chrono::duration literal representing minutes (function). operator\"\"s (C++14): A std::chrono::duration literal representing seconds (function). operator\"\"ms (C++14): A std::chrono::duration literal representing milliseconds (function). operator\"\"us (C++14): A std::chrono::duration literal representing microseconds (function). operator\"\"ns (C++14): A std::chrono::duration literal representing nanoseconds (function). Note: the literal suffixes d and y do not refer to days and years but to day and year, respectively. (since C++20). Time Points Explanation Time points are template classes that express a point in time relative to a clock's epoch. Internally, their instance objects store an object of a std::chrono::duration type, and uses the Clock type as a reference for its epoch. Syntax // Declaration syntax. template< class Clock, class Duration = typename Clock::duration > class time_point; // Usage syntax. // Default constructor. std::chrono::time_point< Clock > start, end; // Usage syntax. auto start = Clock::now(); auto start = Clock::now(); // `Clock::now()`: The `now()` function defined inside the `Clock` class. Realted Stuffs Links std::chrono::time_point in cplusplus . std::chrono::time_point in cppreference . Template Parameters Clock : A clock class, such as std::chrono::system_clock , std::chrono::steady_clock , std::chrono::high_resolution_clock or a custom clock class. Duration : A std::chrono::duration type. Programmers do not need to specify it manually . It is automatically set to a std::chrono::duration type corresponding to the Clock . Clock::duration : The std::chrono::duration type defined inside the Clock class. Each Clock class has its own default std::chrono::duration type . Member Types clock : Clock , the clock on which this time point is measured. duration : Duration , a std::chrono::duration type used to measure the time since epoch. rep : Rep , an arithmetic type representing the number of ticks of the duration. period : Period , a std::ratio type representing the tick period of the duration. Member Functions (constructor): Constructs a new time point (public member function). time_since_epoch : Returns the time point as duration since the start of its clock (public member function). operators : Operators for std::chrono::time_point (function template). time_since_epoch : Time since epoch (public member function). min [ static ]: Returns the time point corresponding to the smallest duration (public static member function). max [ static ]: Returns the time point corresponding to the largest duration (public static member function). Non-member Functions operators : Operators for std::chrono::time_point (function template). time_point_cast : Converts a time point to another time point on the same clock, with a different duration (function template). floor( std::chrono::time_point ) (C++17): Converts a std::chrono::time_point to another, rounding down (function template). ceil( std::chrono::time_point ) (C++17): Converts a std::chrono::time_point to another, rounding up (function template). round( std::chrono::time_point ) (C++17): Converts a std::chrono::time_point to another, rounding to nearest, ties to even (function template). clock_cast (C++20): Convert time points of one clock to another (function template). Helper Classes std::common_type< std::chrono::time_point > : Specializes the std::common_type trait (class template specialization). std::hash< std::chrono::time_point > (C++26): Hash support for std::chrono::time_point (class template specialization). Clocks Explanation Clocks are a framework that relates a time point to real physical time. The library provides at least three clocks that provide means to express the current time as a std::chrono::time_point : std::chrono::system_clock , std::chrono::steady_clock and std::chrono::high_resolution_clock . All of them are classes . Usage: std::chrono::system_clock : Timestamps, timers. std::chrono::steady_clock : Performance measurement, timeouts and delays. std::chrono::high_resolution_clock : High-precision timing, profiling. Syntax // Usage syntax. // Default constructor. std::chrono::time_point< Clock > start, end; // Usage syntax. auto start = Clock::now(); auto start = Clock::now(); // `Clock::now()`: The `now()` function defined inside the `Clock` class. Related Stuffs of Three Clock Classes Links std::chrono::system_clock in cplusplus . std::chrono::system_clock in cppreference . std::chrono::stead_clock in cplusplus . std::chrono::stead_clock in cppreference . std::chrono::high_resolution_clock in cplusplus . std::chrono::high_resolution_clock in cppreference . Member Types of Three Clock Classes rep : An arithmetic type representing the number of ticks in the clock's duration. For system clocks , it's a signed arithmetic type. period : A std::ratio type representing the tick period of the clock, in seconds . duration : std::chrono::duration< rep, period > . For system clocks , capable of representing negative durations. time_point : std::chrono::time_point< Clock > . Member Constants of Three Clock Classes constexpr bool is_steady [ static ]: True if the time between ticks is always constant, i.e. calls to now() return values that increase monotonically even in case of some external clock adjustment, otherwise false. However, for steady clock flag, always true (public static member constant). Member Functions of Three Clock Classes now [ static ]: Returns a std::chrono::time_point representing the current point in time. (public static member function). Member Functions of std::chrono::system_clock to_time_t [ static ]: Converts a system clock time point to std::time_t (public static member function). from_time_t [ static ]: Converts std::time_t to a system clock time point (public static member function). Common Usage Syntax // Measure performance. std::chrono::time_point< Clock > start, end; start = Clock::now(); // Do something. end = Clock::now(); std::chrono::duration< float, std::ratio< num1, num2 > > dur = std::chrono::duration_cast< CorrespondingTemplateInstantiation > ( end - start ); std::cout << \"Elapsed time: \" << dur.count() << \" time unit\\n\"; // Measure performance. auto start = Clock::now(); // Do something. auto end = Clock::now(); auto dur = std::chrono::duration_cast< CorrespondingTemplateInstantiation > ( end - start ); std::cout << \"Elapsed time: \" << dur.count() << \" time unit\\n\"; // Timestamps. auto now = std::chrono::system_clock::now(); std::time_t now_time_t = std::chrono::system_clock::to_time_t( now ); std::cout << \"Current time: \" << std::ctime( &now_time_t ); Notes Utilize a constructor, a destructor, and the object's lifetime to implement a timer object . In Linux, the precision of all clocks is std::chrono::nanoseconds .","title":"Timers"},{"location":"Timers/#stdchrono-namespace","text":"","title":"std::chrono Namespace"},{"location":"Timers/#explanation","text":"chrono is the name of a header , but also of a sub-namespace : All the elements in this header (except for the common_type specializations) are not defined directly under the std namespace (like most of the standard library) but under the std::chrono namespace . The elements in this header deal with time. This is done mainly by means of three concepts : durations, time points and clocks .","title":"Explanation"},{"location":"Timers/#links","text":"std::chrono in cplusplus . std::chrono in cppreference .","title":"Links"},{"location":"Timers/#durations","text":"","title":"Durations"},{"location":"Timers/#explanation_1","text":"Durations are template classes that measure time spans by means of a count and a period., like: one minute, two hours, or ten milliseconds. For the std::chrono::duration class, only std::ratio< num1, num2 > can be used . The corresponding named types of std::ratio< num1, num2 > (e.g., std::chrono::seconds ) cannot be used directly in std::chrono::duration ; instead, use std::ratio< num1, num2 > (e.g., std::ratio< 1, 1 > ). However, std::chrono::time_point , std::chrono::time_point_cast , and std::chrono::duration_cast support these named types. In some C++ STL types, std::ratio< num1, num2 > has alias names , such as std::milli .","title":"Explanation"},{"location":"Timers/#syntax","text":"// Declaration syntax. template< class Rep, class Period = ratio< 1 > > class duration; // Usage syntax. // Default constructor. std::chrono::duration< Type, std::ratio< num1, num2 >(Optional) > dur1; // Copy constructor. std::chrono::duration< Type, std::ratio< num1, num2 >(Optional) > dur2( dur1 ); // Usage syntax. // Default constructor. std::chrono::duration< Type1, std::ratio< num1, num2 >(Optional) > dur1; // Conversion constructor. std::chrono::duration< Type2, std::ratio< num3, num4 > > dur2( dur1 );","title":"Syntax"},{"location":"Timers/#realted-stuffs","text":"","title":"Realted Stuffs"},{"location":"Timers/#links_1","text":"std::chrono::duration in cplusplus . std::chrono::duration in cppreference .","title":"Links"},{"location":"Timers/#template-instantiations","text":"All of these are alias names are predefined std::chrono::duration specializations . std::chrono::hours : Signed integral type of at least 23 bits, period std::ratio< 3600, 1 > . std::chrono::minutes : Signed integral type of at least 29 bits, period std::ratio< 60, 1 > . std::chrono::seconds (Default period): Signed integral type of at least 35 bits, period std::ratio< 1, 1 > . std::chrono::milliseconds : Signed integral type of at least 45 bits, period std::ratio< 1, 1000 > . std::chrono::microseconds : Signed integral type of at least 55 bits, period std::ratio< 1, 1000000 > . std::chrono::nanoseconds : Signed integral type of at least 64 bits, period std::ratio< 1, 1000000000 > .","title":"Template Instantiations"},{"location":"Timers/#member-types","text":"rep : Rep , an arithmetic type, or a class emulating an arithmetic type, representing the number of ticks. period : Period (until C++17) typename Period::type(since C++17) , a std::ratio representing the tick period (i.e. the number of second's fractions per tick).","title":"Member Types"},{"location":"Timers/#member-functions","text":"(constructor) : Constructs new duration (public member function). (destructor) : Destroy duration (public member function). count : Returns the count of ticks (public member function). zero [ static ]: Returns the special duration value zero (public static member function). min [ static ]: Returns the special duration value min (public static member function). max [ static ]: Returns the special duration value max (public static member function).","title":"Member Functions"},{"location":"Timers/#non-member-functions","text":"operators : Duration operators (function template). duration_cast : Converts a duration to another, with a different tick interval (function template). floor( std::chrono::duration ) (C++17): Converts a duration to another, rounding down (function template). ceil( std::chrono::duration ) (C++17): Converts a duration to another, rounding up (function template). round( std::chrono::duration ) (C++17): Converts a duration to another, rounding to nearest, ties to even (function template). abs( std::chrono::duration ) (C++17): Obtains the absolute value of the duration (function template). from_stream (C++20): Parses a duration from a stream according to the provided format (function template).","title":"Non-member Functions"},{"location":"Timers/#helper-classes","text":"std::common_type< std::chrono::duration > : Specializes the std::common_type trait (class template specialization). treat_as_floating_point : Indicates that a duration is convertible to duration with different tick period (class template). duration_values : Constructs zero, min, and max values of a tick count of given type (class template). std::formatter< std::chrono::duration > (C++20): Formatting support for duration (class template specialization). std::hash< std::chrono::duration > (C++26): Hash support for std::chrono::duration (class template specialization).","title":"Helper Classes"},{"location":"Timers/#helper-specializations","text":"template< class Rep, class Period > constexpr bool enable_nonlocking_formatter_optimization< chrono::duration< Rep, Period > > = enable_nonlocking_formatter_optimization< Rep >; (since C++23): This specialization of std::enable_nonlocking_formatter_optimization enables efficient implementation of std::print and std::println for printing a std::chrono::duration object when the template parameter Rep enables it.","title":"Helper Specializations"},{"location":"Timers/#literals","text":"Defined in inline namespace std::literals::chrono_literals . operator\"\"h (C++14): A std::chrono::duration literal representing hours (function). operator\"\"min (C++14): A std::chrono::duration literal representing minutes (function). operator\"\"s (C++14): A std::chrono::duration literal representing seconds (function). operator\"\"ms (C++14): A std::chrono::duration literal representing milliseconds (function). operator\"\"us (C++14): A std::chrono::duration literal representing microseconds (function). operator\"\"ns (C++14): A std::chrono::duration literal representing nanoseconds (function). Note: the literal suffixes d and y do not refer to days and years but to day and year, respectively. (since C++20).","title":"Literals"},{"location":"Timers/#time-points","text":"","title":"Time Points"},{"location":"Timers/#explanation_2","text":"Time points are template classes that express a point in time relative to a clock's epoch. Internally, their instance objects store an object of a std::chrono::duration type, and uses the Clock type as a reference for its epoch.","title":"Explanation"},{"location":"Timers/#syntax_1","text":"// Declaration syntax. template< class Clock, class Duration = typename Clock::duration > class time_point; // Usage syntax. // Default constructor. std::chrono::time_point< Clock > start, end; // Usage syntax. auto start = Clock::now(); auto start = Clock::now(); // `Clock::now()`: The `now()` function defined inside the `Clock` class.","title":"Syntax"},{"location":"Timers/#realted-stuffs_1","text":"","title":"Realted Stuffs"},{"location":"Timers/#links_2","text":"std::chrono::time_point in cplusplus . std::chrono::time_point in cppreference .","title":"Links"},{"location":"Timers/#template-parameters","text":"Clock : A clock class, such as std::chrono::system_clock , std::chrono::steady_clock , std::chrono::high_resolution_clock or a custom clock class. Duration : A std::chrono::duration type. Programmers do not need to specify it manually . It is automatically set to a std::chrono::duration type corresponding to the Clock . Clock::duration : The std::chrono::duration type defined inside the Clock class. Each Clock class has its own default std::chrono::duration type .","title":"Template Parameters"},{"location":"Timers/#member-types_1","text":"clock : Clock , the clock on which this time point is measured. duration : Duration , a std::chrono::duration type used to measure the time since epoch. rep : Rep , an arithmetic type representing the number of ticks of the duration. period : Period , a std::ratio type representing the tick period of the duration.","title":"Member Types"},{"location":"Timers/#member-functions_1","text":"(constructor): Constructs a new time point (public member function). time_since_epoch : Returns the time point as duration since the start of its clock (public member function). operators : Operators for std::chrono::time_point (function template). time_since_epoch : Time since epoch (public member function). min [ static ]: Returns the time point corresponding to the smallest duration (public static member function). max [ static ]: Returns the time point corresponding to the largest duration (public static member function).","title":"Member Functions"},{"location":"Timers/#non-member-functions_1","text":"operators : Operators for std::chrono::time_point (function template). time_point_cast : Converts a time point to another time point on the same clock, with a different duration (function template). floor( std::chrono::time_point ) (C++17): Converts a std::chrono::time_point to another, rounding down (function template). ceil( std::chrono::time_point ) (C++17): Converts a std::chrono::time_point to another, rounding up (function template). round( std::chrono::time_point ) (C++17): Converts a std::chrono::time_point to another, rounding to nearest, ties to even (function template). clock_cast (C++20): Convert time points of one clock to another (function template).","title":"Non-member Functions"},{"location":"Timers/#helper-classes_1","text":"std::common_type< std::chrono::time_point > : Specializes the std::common_type trait (class template specialization). std::hash< std::chrono::time_point > (C++26): Hash support for std::chrono::time_point (class template specialization).","title":"Helper Classes"},{"location":"Timers/#clocks","text":"","title":"Clocks"},{"location":"Timers/#explanation_3","text":"Clocks are a framework that relates a time point to real physical time. The library provides at least three clocks that provide means to express the current time as a std::chrono::time_point : std::chrono::system_clock , std::chrono::steady_clock and std::chrono::high_resolution_clock . All of them are classes . Usage: std::chrono::system_clock : Timestamps, timers. std::chrono::steady_clock : Performance measurement, timeouts and delays. std::chrono::high_resolution_clock : High-precision timing, profiling.","title":"Explanation"},{"location":"Timers/#syntax_2","text":"// Usage syntax. // Default constructor. std::chrono::time_point< Clock > start, end; // Usage syntax. auto start = Clock::now(); auto start = Clock::now(); // `Clock::now()`: The `now()` function defined inside the `Clock` class.","title":"Syntax"},{"location":"Timers/#related-stuffs-of-three-clock-classes","text":"","title":"Related Stuffs of Three Clock Classes"},{"location":"Timers/#links_3","text":"std::chrono::system_clock in cplusplus . std::chrono::system_clock in cppreference . std::chrono::stead_clock in cplusplus . std::chrono::stead_clock in cppreference . std::chrono::high_resolution_clock in cplusplus . std::chrono::high_resolution_clock in cppreference .","title":"Links"},{"location":"Timers/#member-types-of-three-clock-classes","text":"rep : An arithmetic type representing the number of ticks in the clock's duration. For system clocks , it's a signed arithmetic type. period : A std::ratio type representing the tick period of the clock, in seconds . duration : std::chrono::duration< rep, period > . For system clocks , capable of representing negative durations. time_point : std::chrono::time_point< Clock > .","title":"Member Types of Three Clock Classes"},{"location":"Timers/#member-constants-of-three-clock-classes","text":"constexpr bool is_steady [ static ]: True if the time between ticks is always constant, i.e. calls to now() return values that increase monotonically even in case of some external clock adjustment, otherwise false. However, for steady clock flag, always true (public static member constant).","title":"Member Constants of Three Clock Classes"},{"location":"Timers/#member-functions-of-three-clock-classes","text":"now [ static ]: Returns a std::chrono::time_point representing the current point in time. (public static member function).","title":"Member Functions of Three Clock Classes"},{"location":"Timers/#member-functions-of-stdchronosystem_clock","text":"to_time_t [ static ]: Converts a system clock time point to std::time_t (public static member function). from_time_t [ static ]: Converts std::time_t to a system clock time point (public static member function).","title":"Member Functions of std::chrono::system_clock"},{"location":"Timers/#common-usage-syntax","text":"// Measure performance. std::chrono::time_point< Clock > start, end; start = Clock::now(); // Do something. end = Clock::now(); std::chrono::duration< float, std::ratio< num1, num2 > > dur = std::chrono::duration_cast< CorrespondingTemplateInstantiation > ( end - start ); std::cout << \"Elapsed time: \" << dur.count() << \" time unit\\n\"; // Measure performance. auto start = Clock::now(); // Do something. auto end = Clock::now(); auto dur = std::chrono::duration_cast< CorrespondingTemplateInstantiation > ( end - start ); std::cout << \"Elapsed time: \" << dur.count() << \" time unit\\n\"; // Timestamps. auto now = std::chrono::system_clock::now(); std::time_t now_time_t = std::chrono::system_clock::to_time_t( now ); std::cout << \"Current time: \" << std::ctime( &now_time_t );","title":"Common Usage Syntax"},{"location":"Timers/#notes","text":"Utilize a constructor, a destructor, and the object's lifetime to implement a timer object . In Linux, the precision of all clocks is std::chrono::nanoseconds .","title":"Notes"},{"location":"UnionStdAnyStdVariantStdOptional/","text":"Unions Explanation Synatx Anonymous Unions Explanation Syntax std::variant (Multiple Types of Data in Single Variable) Explanation Synatx Members and Related Stuffs Links Template parameters Member Functions Non-member Functions Helper classes Helper objects std::any Explanation Synatx Members and Related Stuffs Links Member Functions Non-member Functions Helper Classes std::optional (Optional Data) Explanation Synatx Members and Related Stuffs Links Template parameters Member Types Member Functions Non-member functions Helper classes Helpers Helper specializations Unions Explanation Unions are special data structures that store different types of data in the same memory location . Only one of the union members can hold a value at any given time, which means the size of a union is determined by the size of its largest member , and all members in the union share the same memory . Typically, we use an anonymous union . It allows us to treat a variable as different types and helps save memory . Synatx // Definition syntax. union UnionName { Type1 mem1; Type2 mem2; // Other mems. }; // Definition syntax. union UnionName { Type1 mem1; Type2 mem2; // Other mems. } obj; // Usage syntax. UnionName obj; obj.mem1 = val1; // obj.mem2 will also be set to val1. obj.mem2 = val2; // obj.mem1 will also be set to val2. Anonymous Unions Explanation Anonymous unions are unions without names , allowing their members to be accessed directly without the need to qualify them with a union name. This can simplify code when the union is used frequently within a class or structure . Syntax // Definition syntax. struct StructName { union { Type1 _mem1; Type2 _mem2; // Other mems. }; }; // Usage syntax. StructName obj; obj._mem1 = val1; // obj._mem2 will also be set to val1. obj._mem2 = val2; // obj._mem1 will also be set to val2. // Definition syntax. class ClassName { public: union { Type1 _mem1; Type2 _mem2; // Other mems. }; }; // Usage syntax. ClassName obj; obj._mem1 = val1; // obj._mem2 will also be set to val1. obj._mem2 = val2; // obj._mem1 will also be set to val2. std::variant (Multiple Types of Data in Single Variable) Explanation std::variant is a type-safe union introduced that allows us to list various types for a variable, as well as assign and reassign it to different types of values. It functions similarly to a template class or a template structure , rather than a union. While a union is more efficient , it is type safer . In some cases, using std::variant helps us obtain more information rather than just optional data, such as when reading a file. std::variant can store exactly one value at a time from a predefined set of types. This means that while you can specify multiple types when declaring a std::variant , it can only hold an instance of one of those types at any given moment. std::variant is type safer than std::any . Its header file is <variant> . Synatx // Declaration syntax. std::variant< TypeList > var_name; // Definition syntax. std::variant< TypeList > var_name = val; // Assignment syntax. var_name = val; // Definition syntax. std::variant< TypeList > var_name1 = val; // Copy constructor. std::variant< TypeList > var_name2 = var_name1; // Move constructor. std::variant< TypeList > var_name3 = std::move( var_name2 ); // Checking type. if( std::holds_alternative< Type >( var_name ) ) { // Do something. }; // Retrieving value. Type var_val = std::get< Type >( var_name ); // Retrieving value. Type& var_val = std::get< Type >( var_name ); // Checking type and retrieving value. if( auto var_val = std::get_if< Type >( var_name ) ) { std::cout << *var_val << std::endl; // or std::cout << std::get< Type >( var_name ) << std::endl; // Do something. }; // Visit the value. std::visit( []( auto&& var_val ) { std::cout << var_val << std::endl; // Do something. }, var_name ); // Handling invalid access. try { Type var_val = std::get< Type >( var_name ); // This will throw if myVariant does not hold a double. } catch( const std::bad_variant_access& e ) { std::cerr << \"Bad variant access: \" << e.what() << std::endl; }; Members and Related Stuffs Links std::variant in cplusplus . std::variant in cppreference . Template parameters Types : The types that may be stored in this variant. All types must meet the Destructible requirements (in particular, array types and non-object types are not allowed). Member Functions (constructor): Constructs the variant object (public member function). (destructor): Destroys the variant, along with its contained value (public member function). operator= : Assigns a variant (public member function). index : Returns the zero-based index of the alternative held by the variant (public member function). valueless_by_exception : Checks if the variant is in the invalid state (public member function). emplace : Constructs a value in the variant, in place (public member function). swap : Swaps with another variant (public member function). visit (C++26): Calls the provided functor with the argument held by the variant (public member function). Non-member Functions visit (C++17): Calls the provided functor with the arguments held by one or more variants (function template). holds_alternative (C++17): Checks if a variant currently holds a given type (function template). get( std::variant ) (C++17): Reads the value of the variant given the index or the type (if the type is unique), throws on error (function template). get_if (C++17): Obtains a pointer to the value of a pointed-to variant given the index or the type (if unique), returns null on error (function template). operator==/!=/<!--<=/-->/>= ( C++ 17 ), operator<=> (C++20): Compares variant objects as their contained values (function template). std::swap( std::variant ) (C++17): Specializes the std::swap algorithm (function template). Helper classes monostate (C++17): Placeholder type for use as the first alternative in a variant of non-default-constructible types (class). bad_variant_access (C++17): Exception thrown on invalid accesses to the value of a variant (class). variant_size (C++17), variant_size_v (C++17): Obtains the size of the variant's list of alternatives at compile time (class template) (variable template). variant_alternative , variant_alternative_t (C++17): Obtains the type of the alternative specified by its index, at compile time (class template) (alias template). std::hash< std::variant > (C++17): Hash support for std::variant (class template specialization). Helper objects variant_npos (C++17): Index of the variant in the invalid state (constant). std::any Explanation std::any is a type-safe container (a class) for single values of any type . It can hold an instance of any type , enabling you to store heterogeneous values without knowing their types at compile time . This feature makes std::any particularly useful in scenarios like dynamic type storage and type erasure . When used to store small-sized variables , typically up to 32 bytes depending on its implementation, it functions similarly to std::variant . However, if larger sizes are required, dynamic allocations are necessary, which can impact performance . This feature is not useful , and few programmers use it . Its header file is <any> . Synatx // Declaration syntax. std::any var_name; // Definition syntax. std::any var_name = val; // Assignment syntax. var_name = val; // Definition syntax. std::any var_name1 = val; // Copy constructor. std::any var_name2( var_name1 ); // Move constructor. std::any var_name3( std::move( var_name1 ) ); // Checking type. if( var_name.type() == typeid( Type ) ) { // Do something. }; // Retrieving value. Type var_val = std::any_cast< Type >( var_name ); // Retrieving value. // Better than the above statement, will be optimized. Type& var_ref = std::any_cast< Type& >( var_name ); // Handling invalid casts. try { Type var_val = std::any_cast< Type >( var_name ); // throws std::bad_any_cast if the type is incorrect. } catch( const std::bad_any_cast& e ) { // Handle error. }; // Resetting the value. var_name.reset(); // clears the stored value. Members and Related Stuffs Links std::any in cplusplus . std::any in cppreference . Member Functions (constructor): Constructs an any object (public member function). (destructor): Destroys an any object (public member function). operator= : Assigns an any object (public member function). emplace : Change the contained object, constructing the new object directly (public member function). reset : Destroys contained object (public member function). swap : Swaps two any objects (public member function). has_value : Checks if object holds a value (public member function). type : Returns the typeid of the contained value (public member function). Non-member Functions std::swap( std::any ) (C++17): Specializes the std::swap algorithm (function). any_cast (C++17): Type-safe access to the contained object (function template). make_any (C++17): Creates an any object (function template). Helper Classes bad_any_cast (C++17): Exception thrown by the value-returning forms of any_cast on a type mismatch (class). std::optional (Optional Data) Explanation std::optional is a wrapper type (a template class) used to represent an object that may or may not contain a value . It encapsulates an optional value, offering a safer alternative to return values from functions (e.g., when searching for elements), nullptr or sentinel values (e.g., -1 as an invalid index). By explicitly managing cases where a value might be absent, it enhances code clarity and reduces the risks of runtime errors (like accessing uninitialized variables). An example is using it to determine whether a file is successfully read . Synatx // Declaration syntax. #include <optional> std::optional< Type > var_name; // Definition syntax. std::optional< Type > var_name = std::nullopt; // Empty optional. // Definition syntax. std::optional< Type > var_name = val; // Contains a value. // Assignment syntax. var_name = std::nullopt; // Reset to empty state. var_name = val; // Assign a value. // Checking if value exists. if( var_name.has_value() ) { // or if( var_name ) { Type& val_name = *var_name; // or Type& val_name = var_name.value(); // Do something with the value. }; // Retrieving value (throws exception if empty). Type var_val = var_name.value(); // Retrieving value (avoids exception). Type var_val = var_name.value_or( default_value ); // Handling exceptions for empty optionals. try { Type var_val = var_name.value(); // Throws std::bad_optional_access if empty. } catch( const std::bad_optional_access& e ) { // Handle the error. }; // Resetting the optional to empty state. var_name.reset(); // Clears the value. Members and Related Stuffs Links std::optional in cplusplus . std::optional in cppreference . Template parameters T : The type of the value to manage initialization state for. Member Types value_type : T iterator (since C++26): Implementation-defined LegacyRandomAccessIterator , ConstexprIterator , and contiguous_iterator whose value_type and reference are std::remove_cv_t< T > and T& , respectively. const_iterator (since C++26): Implementation-defined LegacyRandomAccessIterator , ConstexprIterator , and contiguous_iterator whose value_type and reference are std::remove_cv_t< T > and const T& , respectively. Member Functions (constructor): Constructs the optional object (public member function). (destructor): Destroys the contained value, if there is one (public member function). operator= : Assigns contents (public member function). begin (C++26): Returns an iterator to the beginning (public member function). end (C++26): Returns an iterator to the end (public member function). operator-> , operator* : Accesses the contained value (public member function). operator bool , has_value : Checks whether the object contains a value (public member function). value : Returns the contained value (public member function). value_or : Returns the contained value if available, another value otherwise (public member function). and_then (C++23): Returns the result of the given function on the contained value if it exists, or an empty optional otherwise (public member function). transform (C++23): Returns an optional containing the transformed contained value if it exists, or an empty optional otherwise (public member function). or_else (C++23): Returns the optional itself if it contains a value, or the result of the given function otherwise (public member function). swap : Exchanges the contents (public member function). reset : Destroys any contained value (public member function). emplace : Constructs the contained value in-place (public member function). Non-member functions operator==/!=/<!--<=/-->/>= (C++17), operator<=> (C++20): Compares optional objects (function template). make_optional (C++17): Creates an optional object (function template). std::swap( std::optional ) (C++17): Specializes the std::swap algorithm (function template). Helper classes std::hash< std::optional > (C++17): Hash support for std::optional (class template specialization). nullopt_t (C++17): indicator of an std::optional that does not contain a value (class). bad_optional_access (C++17): Exception indicating checked access to an optional that doesn't contain a value (class). Helpers nullopt (C++17): An object of type nullopt_t (constant). in_place (C++17), in_place_type (C++17), in_place_index (C++17), in_place_t (C++17), in_place_type_t (C++17), in_place_index_t (C++17): in-place construction tag (tag). Helper specializations template< class T > constexpr bool ranges::enable_view< std::optional< T > > = true; (since C++26): This specialization of ranges::enable_view makes optional satisfy view. template< class T > constexpr auto format_kind< std::optional< T > > = range_format::disabled; (since C++26): This specialization of format_kind disables the range formatting support of optional.","title":"union, std:any std::variant and std::optional"},{"location":"UnionStdAnyStdVariantStdOptional/#unions","text":"","title":"Unions"},{"location":"UnionStdAnyStdVariantStdOptional/#explanation","text":"Unions are special data structures that store different types of data in the same memory location . Only one of the union members can hold a value at any given time, which means the size of a union is determined by the size of its largest member , and all members in the union share the same memory . Typically, we use an anonymous union . It allows us to treat a variable as different types and helps save memory .","title":"Explanation"},{"location":"UnionStdAnyStdVariantStdOptional/#synatx","text":"// Definition syntax. union UnionName { Type1 mem1; Type2 mem2; // Other mems. }; // Definition syntax. union UnionName { Type1 mem1; Type2 mem2; // Other mems. } obj; // Usage syntax. UnionName obj; obj.mem1 = val1; // obj.mem2 will also be set to val1. obj.mem2 = val2; // obj.mem1 will also be set to val2.","title":"Synatx"},{"location":"UnionStdAnyStdVariantStdOptional/#anonymous-unions","text":"","title":"Anonymous Unions"},{"location":"UnionStdAnyStdVariantStdOptional/#explanation_1","text":"Anonymous unions are unions without names , allowing their members to be accessed directly without the need to qualify them with a union name. This can simplify code when the union is used frequently within a class or structure .","title":"Explanation"},{"location":"UnionStdAnyStdVariantStdOptional/#syntax","text":"// Definition syntax. struct StructName { union { Type1 _mem1; Type2 _mem2; // Other mems. }; }; // Usage syntax. StructName obj; obj._mem1 = val1; // obj._mem2 will also be set to val1. obj._mem2 = val2; // obj._mem1 will also be set to val2. // Definition syntax. class ClassName { public: union { Type1 _mem1; Type2 _mem2; // Other mems. }; }; // Usage syntax. ClassName obj; obj._mem1 = val1; // obj._mem2 will also be set to val1. obj._mem2 = val2; // obj._mem1 will also be set to val2.","title":"Syntax"},{"location":"UnionStdAnyStdVariantStdOptional/#stdvariant-multiple-types-of-data-in-single-variable","text":"","title":"std::variant (Multiple Types of Data in Single Variable)"},{"location":"UnionStdAnyStdVariantStdOptional/#explanation_2","text":"std::variant is a type-safe union introduced that allows us to list various types for a variable, as well as assign and reassign it to different types of values. It functions similarly to a template class or a template structure , rather than a union. While a union is more efficient , it is type safer . In some cases, using std::variant helps us obtain more information rather than just optional data, such as when reading a file. std::variant can store exactly one value at a time from a predefined set of types. This means that while you can specify multiple types when declaring a std::variant , it can only hold an instance of one of those types at any given moment. std::variant is type safer than std::any . Its header file is <variant> .","title":"Explanation"},{"location":"UnionStdAnyStdVariantStdOptional/#synatx_1","text":"// Declaration syntax. std::variant< TypeList > var_name; // Definition syntax. std::variant< TypeList > var_name = val; // Assignment syntax. var_name = val; // Definition syntax. std::variant< TypeList > var_name1 = val; // Copy constructor. std::variant< TypeList > var_name2 = var_name1; // Move constructor. std::variant< TypeList > var_name3 = std::move( var_name2 ); // Checking type. if( std::holds_alternative< Type >( var_name ) ) { // Do something. }; // Retrieving value. Type var_val = std::get< Type >( var_name ); // Retrieving value. Type& var_val = std::get< Type >( var_name ); // Checking type and retrieving value. if( auto var_val = std::get_if< Type >( var_name ) ) { std::cout << *var_val << std::endl; // or std::cout << std::get< Type >( var_name ) << std::endl; // Do something. }; // Visit the value. std::visit( []( auto&& var_val ) { std::cout << var_val << std::endl; // Do something. }, var_name ); // Handling invalid access. try { Type var_val = std::get< Type >( var_name ); // This will throw if myVariant does not hold a double. } catch( const std::bad_variant_access& e ) { std::cerr << \"Bad variant access: \" << e.what() << std::endl; };","title":"Synatx"},{"location":"UnionStdAnyStdVariantStdOptional/#members-and-related-stuffs","text":"","title":"Members and Related Stuffs"},{"location":"UnionStdAnyStdVariantStdOptional/#links","text":"std::variant in cplusplus . std::variant in cppreference .","title":"Links"},{"location":"UnionStdAnyStdVariantStdOptional/#template-parameters","text":"Types : The types that may be stored in this variant. All types must meet the Destructible requirements (in particular, array types and non-object types are not allowed).","title":"Template parameters"},{"location":"UnionStdAnyStdVariantStdOptional/#member-functions","text":"(constructor): Constructs the variant object (public member function). (destructor): Destroys the variant, along with its contained value (public member function). operator= : Assigns a variant (public member function). index : Returns the zero-based index of the alternative held by the variant (public member function). valueless_by_exception : Checks if the variant is in the invalid state (public member function). emplace : Constructs a value in the variant, in place (public member function). swap : Swaps with another variant (public member function). visit (C++26): Calls the provided functor with the argument held by the variant (public member function).","title":"Member Functions"},{"location":"UnionStdAnyStdVariantStdOptional/#non-member-functions","text":"visit (C++17): Calls the provided functor with the arguments held by one or more variants (function template). holds_alternative (C++17): Checks if a variant currently holds a given type (function template). get( std::variant ) (C++17): Reads the value of the variant given the index or the type (if the type is unique), throws on error (function template). get_if (C++17): Obtains a pointer to the value of a pointed-to variant given the index or the type (if unique), returns null on error (function template). operator==/!=/<!--<=/-->/>= ( C++ 17 ), operator<=> (C++20): Compares variant objects as their contained values (function template). std::swap( std::variant ) (C++17): Specializes the std::swap algorithm (function template).","title":"Non-member Functions"},{"location":"UnionStdAnyStdVariantStdOptional/#helper-classes","text":"monostate (C++17): Placeholder type for use as the first alternative in a variant of non-default-constructible types (class). bad_variant_access (C++17): Exception thrown on invalid accesses to the value of a variant (class). variant_size (C++17), variant_size_v (C++17): Obtains the size of the variant's list of alternatives at compile time (class template) (variable template). variant_alternative , variant_alternative_t (C++17): Obtains the type of the alternative specified by its index, at compile time (class template) (alias template). std::hash< std::variant > (C++17): Hash support for std::variant (class template specialization).","title":"Helper classes"},{"location":"UnionStdAnyStdVariantStdOptional/#helper-objects","text":"variant_npos (C++17): Index of the variant in the invalid state (constant).","title":"Helper objects"},{"location":"UnionStdAnyStdVariantStdOptional/#stdany","text":"","title":"std::any"},{"location":"UnionStdAnyStdVariantStdOptional/#explanation_3","text":"std::any is a type-safe container (a class) for single values of any type . It can hold an instance of any type , enabling you to store heterogeneous values without knowing their types at compile time . This feature makes std::any particularly useful in scenarios like dynamic type storage and type erasure . When used to store small-sized variables , typically up to 32 bytes depending on its implementation, it functions similarly to std::variant . However, if larger sizes are required, dynamic allocations are necessary, which can impact performance . This feature is not useful , and few programmers use it . Its header file is <any> .","title":"Explanation"},{"location":"UnionStdAnyStdVariantStdOptional/#synatx_2","text":"// Declaration syntax. std::any var_name; // Definition syntax. std::any var_name = val; // Assignment syntax. var_name = val; // Definition syntax. std::any var_name1 = val; // Copy constructor. std::any var_name2( var_name1 ); // Move constructor. std::any var_name3( std::move( var_name1 ) ); // Checking type. if( var_name.type() == typeid( Type ) ) { // Do something. }; // Retrieving value. Type var_val = std::any_cast< Type >( var_name ); // Retrieving value. // Better than the above statement, will be optimized. Type& var_ref = std::any_cast< Type& >( var_name ); // Handling invalid casts. try { Type var_val = std::any_cast< Type >( var_name ); // throws std::bad_any_cast if the type is incorrect. } catch( const std::bad_any_cast& e ) { // Handle error. }; // Resetting the value. var_name.reset(); // clears the stored value.","title":"Synatx"},{"location":"UnionStdAnyStdVariantStdOptional/#members-and-related-stuffs_1","text":"","title":"Members and Related Stuffs"},{"location":"UnionStdAnyStdVariantStdOptional/#links_1","text":"std::any in cplusplus . std::any in cppreference .","title":"Links"},{"location":"UnionStdAnyStdVariantStdOptional/#member-functions_1","text":"(constructor): Constructs an any object (public member function). (destructor): Destroys an any object (public member function). operator= : Assigns an any object (public member function). emplace : Change the contained object, constructing the new object directly (public member function). reset : Destroys contained object (public member function). swap : Swaps two any objects (public member function). has_value : Checks if object holds a value (public member function). type : Returns the typeid of the contained value (public member function).","title":"Member Functions"},{"location":"UnionStdAnyStdVariantStdOptional/#non-member-functions_1","text":"std::swap( std::any ) (C++17): Specializes the std::swap algorithm (function). any_cast (C++17): Type-safe access to the contained object (function template). make_any (C++17): Creates an any object (function template).","title":"Non-member Functions"},{"location":"UnionStdAnyStdVariantStdOptional/#helper-classes_1","text":"bad_any_cast (C++17): Exception thrown by the value-returning forms of any_cast on a type mismatch (class).","title":"Helper Classes"},{"location":"UnionStdAnyStdVariantStdOptional/#stdoptional-optional-data","text":"","title":"std::optional (Optional Data)"},{"location":"UnionStdAnyStdVariantStdOptional/#explanation_4","text":"std::optional is a wrapper type (a template class) used to represent an object that may or may not contain a value . It encapsulates an optional value, offering a safer alternative to return values from functions (e.g., when searching for elements), nullptr or sentinel values (e.g., -1 as an invalid index). By explicitly managing cases where a value might be absent, it enhances code clarity and reduces the risks of runtime errors (like accessing uninitialized variables). An example is using it to determine whether a file is successfully read .","title":"Explanation"},{"location":"UnionStdAnyStdVariantStdOptional/#synatx_3","text":"// Declaration syntax. #include <optional> std::optional< Type > var_name; // Definition syntax. std::optional< Type > var_name = std::nullopt; // Empty optional. // Definition syntax. std::optional< Type > var_name = val; // Contains a value. // Assignment syntax. var_name = std::nullopt; // Reset to empty state. var_name = val; // Assign a value. // Checking if value exists. if( var_name.has_value() ) { // or if( var_name ) { Type& val_name = *var_name; // or Type& val_name = var_name.value(); // Do something with the value. }; // Retrieving value (throws exception if empty). Type var_val = var_name.value(); // Retrieving value (avoids exception). Type var_val = var_name.value_or( default_value ); // Handling exceptions for empty optionals. try { Type var_val = var_name.value(); // Throws std::bad_optional_access if empty. } catch( const std::bad_optional_access& e ) { // Handle the error. }; // Resetting the optional to empty state. var_name.reset(); // Clears the value.","title":"Synatx"},{"location":"UnionStdAnyStdVariantStdOptional/#members-and-related-stuffs_2","text":"","title":"Members and Related Stuffs"},{"location":"UnionStdAnyStdVariantStdOptional/#links_2","text":"std::optional in cplusplus . std::optional in cppreference .","title":"Links"},{"location":"UnionStdAnyStdVariantStdOptional/#template-parameters_1","text":"T : The type of the value to manage initialization state for.","title":"Template parameters"},{"location":"UnionStdAnyStdVariantStdOptional/#member-types","text":"value_type : T iterator (since C++26): Implementation-defined LegacyRandomAccessIterator , ConstexprIterator , and contiguous_iterator whose value_type and reference are std::remove_cv_t< T > and T& , respectively. const_iterator (since C++26): Implementation-defined LegacyRandomAccessIterator , ConstexprIterator , and contiguous_iterator whose value_type and reference are std::remove_cv_t< T > and const T& , respectively.","title":"Member Types"},{"location":"UnionStdAnyStdVariantStdOptional/#member-functions_2","text":"(constructor): Constructs the optional object (public member function). (destructor): Destroys the contained value, if there is one (public member function). operator= : Assigns contents (public member function). begin (C++26): Returns an iterator to the beginning (public member function). end (C++26): Returns an iterator to the end (public member function). operator-> , operator* : Accesses the contained value (public member function). operator bool , has_value : Checks whether the object contains a value (public member function). value : Returns the contained value (public member function). value_or : Returns the contained value if available, another value otherwise (public member function). and_then (C++23): Returns the result of the given function on the contained value if it exists, or an empty optional otherwise (public member function). transform (C++23): Returns an optional containing the transformed contained value if it exists, or an empty optional otherwise (public member function). or_else (C++23): Returns the optional itself if it contains a value, or the result of the given function otherwise (public member function). swap : Exchanges the contents (public member function). reset : Destroys any contained value (public member function). emplace : Constructs the contained value in-place (public member function).","title":"Member Functions"},{"location":"UnionStdAnyStdVariantStdOptional/#non-member-functions_2","text":"operator==/!=/<!--<=/-->/>= (C++17), operator<=> (C++20): Compares optional objects (function template). make_optional (C++17): Creates an optional object (function template). std::swap( std::optional ) (C++17): Specializes the std::swap algorithm (function template).","title":"Non-member functions"},{"location":"UnionStdAnyStdVariantStdOptional/#helper-classes_2","text":"std::hash< std::optional > (C++17): Hash support for std::optional (class template specialization). nullopt_t (C++17): indicator of an std::optional that does not contain a value (class). bad_optional_access (C++17): Exception indicating checked access to an optional that doesn't contain a value (class).","title":"Helper classes"},{"location":"UnionStdAnyStdVariantStdOptional/#helpers","text":"nullopt (C++17): An object of type nullopt_t (constant). in_place (C++17), in_place_type (C++17), in_place_index (C++17), in_place_t (C++17), in_place_type_t (C++17), in_place_index_t (C++17): in-place construction tag (tag).","title":"Helpers"},{"location":"UnionStdAnyStdVariantStdOptional/#helper-specializations","text":"template< class T > constexpr bool ranges::enable_view< std::optional< T > > = true; (since C++26): This specialization of ranges::enable_view makes optional satisfy view. template< class T > constexpr auto format_kind< std::optional< T > > = range_format::disabled; (since C++26): This specialization of format_kind disables the range formatting support of optional.","title":"Helper specializations"},{"location":"UsingTypedefNameSpaces/","text":"using and typedef using Explanation Syntax Usage typedef Explanation Syntax Usage Notes namespace Explanation Declaration Syntax Definition Syntax or How to Add a Member into a Defined or Declared namespace How to Reference a Member from a namespace using namespace SpaceName Disadvantages Notes using and typedef using Explanation using is a keyword and has multiple uses, each serving a different purpose depending on the context. It can be used for type aliasing , namespace introduction (not recommend) , and template aliasing . It offers more flexibility compared to typedef , particularly when working with templates. Syntax using AliasName = Type; Usage Syntax simplicity. Template aliases. ( No limitations ). CPP // `ClassName` is a template class that has been implmented. template< typename T, ... > using AliasName = ClassName< T, ... >; CPP // `StructName` is a template structure that has been implmented. template< typename T, ... > using AliasName = StructName< T, ... >; CPP // `funcName` is a template function that has been implmented. template< typename T, ... > using aliasName = funcName< T, ... >; Function pointer declaration. CPP using FuncPtrName = RetType ( * )( parameter_types ); FuncPtrName func_ptr_name; ```CPP struct ClassName { RetType funcName( ... ) {}; ...; using funcPtrName = RetType ( MyClass::* )( ... ); // Alias for member function }; ``` Alias for member types in classes. CPP class ClassName { public: // Using alias. using AliasName = Type; AliasName _mem; }; typedef Explanation typedef is a keyword used to create an alias for a data type , allowing you to define new names for existing types. This can improve code readability, simplify complex type definitions, and enhance maintainability by making it easier to manage changes in data types throughout your code. Syntax typedef Type AliasName; Usage Syntax simplicity. Template aliases. ( Only allows inside a struct or class, but not allows outside of a struct or class ). CPP // `ClassName` is a template class that has been implmented. template< typename T, ... > class ClassName< T, ... > { ...; }; // `StructName` is a template structure that has been implmented. template< typename T, ... > StructName{ typedef Classname< T, ... > AliasName; ...; } Function pointer declaration. CPP typedef RetType ( *FuncPtrName )( parameter_types ); FuncPtrName func_ptr_name; Alias for member types in classes. CPP class ClassName { public: // Using `typedef`. typedef Type AliasName; AliasName _mem; }; Notes Using using is generally better than using typedef for aliasing a data type, especially in modern C++ (C++11 and beyond). namespace Explanation A namespace is a way to organize and group related classes, functions, variables, and other identifiers to avoid name conflicts . It provides a logical structure that helps manage large codebases, particularly when multiple libraries or modules are used that might define identifiers with the same names. In fact, if we do not implement our classes, functions, variables, and other identifiers within a named namespace , they are implemented in an anonymous namespace . Declaration Syntax namespace SpaceName {}; Definition Syntax or How to Add a Member into a Defined or Declared namespace namespace SpaceName { ...; }; namespace SpaceName = AnotherSpaceName; namespace SpaceName = SpaceNameA::SpaceNameB; How to Reference a Member from a namespace SpaceName::member; using namespace SpaceName using SpaceNameA::SpaceNameB; using namespace SpaceNameA; using namespace SpaceNameB; using namespace SpaceNameA::SpaceNameB; Disadvantages It's difficult to determine from which namespace a function is being called if both namespaces contain a function with the same name . There are multiple scenarios: Both functions have the same signature . Both functions do not have the same signature, but implicit conversion can occur between their parameters. Notes Do not use it in header files, but it can be used within a small scope , such as a function or an if statement.","title":"using, typedef and Namespaces"},{"location":"UsingTypedefNameSpaces/#using-and-typedef","text":"","title":"using and typedef"},{"location":"UsingTypedefNameSpaces/#using","text":"","title":"using"},{"location":"UsingTypedefNameSpaces/#explanation","text":"using is a keyword and has multiple uses, each serving a different purpose depending on the context. It can be used for type aliasing , namespace introduction (not recommend) , and template aliasing . It offers more flexibility compared to typedef , particularly when working with templates.","title":"Explanation"},{"location":"UsingTypedefNameSpaces/#syntax","text":"using AliasName = Type;","title":"Syntax"},{"location":"UsingTypedefNameSpaces/#usage","text":"Syntax simplicity. Template aliases. ( No limitations ). CPP // `ClassName` is a template class that has been implmented. template< typename T, ... > using AliasName = ClassName< T, ... >; CPP // `StructName` is a template structure that has been implmented. template< typename T, ... > using AliasName = StructName< T, ... >; CPP // `funcName` is a template function that has been implmented. template< typename T, ... > using aliasName = funcName< T, ... >; Function pointer declaration. CPP using FuncPtrName = RetType ( * )( parameter_types ); FuncPtrName func_ptr_name; ```CPP struct ClassName { RetType funcName( ... ) {}; ...; using funcPtrName = RetType ( MyClass::* )( ... ); // Alias for member function }; ``` Alias for member types in classes. CPP class ClassName { public: // Using alias. using AliasName = Type; AliasName _mem; };","title":"Usage"},{"location":"UsingTypedefNameSpaces/#typedef","text":"","title":"typedef"},{"location":"UsingTypedefNameSpaces/#explanation_1","text":"typedef is a keyword used to create an alias for a data type , allowing you to define new names for existing types. This can improve code readability, simplify complex type definitions, and enhance maintainability by making it easier to manage changes in data types throughout your code.","title":"Explanation"},{"location":"UsingTypedefNameSpaces/#syntax_1","text":"typedef Type AliasName;","title":"Syntax"},{"location":"UsingTypedefNameSpaces/#usage_1","text":"Syntax simplicity. Template aliases. ( Only allows inside a struct or class, but not allows outside of a struct or class ). CPP // `ClassName` is a template class that has been implmented. template< typename T, ... > class ClassName< T, ... > { ...; }; // `StructName` is a template structure that has been implmented. template< typename T, ... > StructName{ typedef Classname< T, ... > AliasName; ...; } Function pointer declaration. CPP typedef RetType ( *FuncPtrName )( parameter_types ); FuncPtrName func_ptr_name; Alias for member types in classes. CPP class ClassName { public: // Using `typedef`. typedef Type AliasName; AliasName _mem; };","title":"Usage"},{"location":"UsingTypedefNameSpaces/#notes","text":"Using using is generally better than using typedef for aliasing a data type, especially in modern C++ (C++11 and beyond).","title":"Notes"},{"location":"UsingTypedefNameSpaces/#namespace","text":"","title":"namespace"},{"location":"UsingTypedefNameSpaces/#explanation_2","text":"A namespace is a way to organize and group related classes, functions, variables, and other identifiers to avoid name conflicts . It provides a logical structure that helps manage large codebases, particularly when multiple libraries or modules are used that might define identifiers with the same names. In fact, if we do not implement our classes, functions, variables, and other identifiers within a named namespace , they are implemented in an anonymous namespace .","title":"Explanation"},{"location":"UsingTypedefNameSpaces/#declaration-syntax","text":"namespace SpaceName {};","title":"Declaration Syntax"},{"location":"UsingTypedefNameSpaces/#definition-syntax-or-how-to-add-a-member-into-a-defined-or-declared-namespace","text":"namespace SpaceName { ...; }; namespace SpaceName = AnotherSpaceName; namespace SpaceName = SpaceNameA::SpaceNameB;","title":"Definition Syntax or How to Add a Member into a Defined or Declared namespace"},{"location":"UsingTypedefNameSpaces/#how-to-reference-a-member-from-a-namespace","text":"SpaceName::member;","title":"How to Reference a Member from a namespace"},{"location":"UsingTypedefNameSpaces/#using-namespace-spacename","text":"using SpaceNameA::SpaceNameB; using namespace SpaceNameA; using namespace SpaceNameB; using namespace SpaceNameA::SpaceNameB;","title":"using namespace SpaceName"},{"location":"UsingTypedefNameSpaces/#disadvantages","text":"It's difficult to determine from which namespace a function is being called if both namespaces contain a function with the same name . There are multiple scenarios: Both functions have the same signature . Both functions do not have the same signature, but implicit conversion can occur between their parameters.","title":"Disadvantages"},{"location":"UsingTypedefNameSpaces/#notes_1","text":"Do not use it in header files, but it can be used within a small scope , such as a function or an if statement.","title":"Notes"},{"location":"Volatile/","text":"volatile Explanation Syntax Usage Limitations volatile Explanation The volatile keyword tells the compiler that a variable's value may change unexpectedly, outside the program's control (e.g., hardware, interrupts, etc.). It prevents the compiler from optimizing reads and writes to the variable, ensuring that every read/write of a variable occurs exactly as written in the code. It is used when variables might be modified by hardware, interrupts, or external threads. Syntax volatile Type var_name; volatile Type* var_ptr; Usage Embedded systems: Hardware registers, memory-mapped I/O, and flags. Interrupt service routines (ISRs): Variables modified by ISRs to ensure the main program does not cache them. Multi-threading (discouraged): Shared variables accessed by multiple threads (use std::atomic instead for thread synchronization). Limitations No atomicity: Does not guarantee atomic access or synchronization between threads. No memory ordering: volatile does not enforce memory ordering or prevent reordering of instructions. Not a synchronization mechanism: volatile should not be used for thread synchronization. Use std::atomic or other synchronization techniques instead. Does not ensure thread safety: Used for hardware interaction or volatile memory locations, not for controlling access to shared variables between threads.","title":"volatile"},{"location":"Volatile/#volatile","text":"","title":"volatile"},{"location":"Volatile/#explanation","text":"The volatile keyword tells the compiler that a variable's value may change unexpectedly, outside the program's control (e.g., hardware, interrupts, etc.). It prevents the compiler from optimizing reads and writes to the variable, ensuring that every read/write of a variable occurs exactly as written in the code. It is used when variables might be modified by hardware, interrupts, or external threads.","title":"Explanation"},{"location":"Volatile/#syntax","text":"volatile Type var_name; volatile Type* var_ptr;","title":"Syntax"},{"location":"Volatile/#usage","text":"Embedded systems: Hardware registers, memory-mapped I/O, and flags. Interrupt service routines (ISRs): Variables modified by ISRs to ensure the main program does not cache them. Multi-threading (discouraged): Shared variables accessed by multiple threads (use std::atomic instead for thread synchronization).","title":"Usage"},{"location":"Volatile/#limitations","text":"No atomicity: Does not guarantee atomic access or synchronization between threads. No memory ordering: volatile does not enforce memory ordering or prevent reordering of instructions. Not a synchronization mechanism: volatile should not be used for thread synchronization. Use std::atomic or other synchronization techniques instead. Does not ensure thread safety: Used for hardware interaction or volatile memory locations, not for controlling access to shared variables between threads.","title":"Limitations"},{"location":"makeAndMakefiles/","text":"make and Makefile make Makefile Basic Syntax of Makefile Code Explanation How make Processes a Makefile Prerequisites Steps .PHONY , a Pseudo Target Syntax Explanation and Usage Example Implicit Rule Explanation Common Implicit Rules Notes Variables in Makefile Explanation and Usage The Syntax of Defining a Variable The Syntax of Referencing a Variable Default Variables, Common Variables, Automatic Variables, Special Symbols and Environment Variables Explanation Name of Default Variables Name of Common Variables Common Automatic Variables Some Common Special Symbols Environment Variables 1 The Syntax of Referencing an Environment Variable 2 The Syntax of Overriding an Environment Variable 3 Important Notes 4 Some Common Environment Variables in Makefiles Functions in Makefiles Functions for Transforming Text (Usage) Function Call Syntax More Information Pattern Rules Explanation and Usage Basic Syntax Code Explanation Notes How to Understand the Actual Process of Pattern Rules Example Without Variables Example 1: Compiling .cpp files to .o files Code Explanation Example 2: Creating Executables Code Explanation Example 3: Custom Pattern Rule Code Explanation Example 4: Chaining Pattern Rules Code Explanation Example 5: Using $* for Matching Stems Code Explanation Example With Variables Example 1: Using Variables for File Extensions Code Explanation Example 2: Using Variables for Directories Code Explanation Example 3: Using Variables for Compiler and Flags Code Explanation Example 4: Using Variables for Custom Commands Code Explanation Example 5: Combining Multiple Variables Code Explanation Example 6: Using a Variable for a List of Targets Code Explanation Example 7: Using a Variable with Multiple Targets for an Executable Code Explanation Example 9: Using a Variable for Source Files and a Pattern Rule to Compile Them Code Explanation Example 10: Pattern Rule with Variable Target-pattern Using wildcard Code Explanation Example 11: Pattern Rule with a Prefix Code Explanation Example 12: Limitations and an Error Demonstration Code Explanation How to Process Header Files Effectively Problem Solution Code Explanation Some Common make command make make -jn make target_name make -C a_path make -C a_path target_name make target_name VAR_NAME1=\"...\" VAR_NAME2=\"...\" ... make -C a_path target_name VAR_NAME1=\"...\" VAR_NAME2=\"...\" ... How to Manage Libraries or Dependencies Your Project Denpends On make and Makefile make The make command is a build automation tool primarily used for compiling and building projects in C, C++, and other programming languages. It simplifies the process of compiling code, linking libraries, and creating executables by reading instructions from a configuration file called a Makefile. Additionally, it checks the return value of each executed command in the Makefile. If a command returns an error ( a non-zero value ), make will exit . Makefile A Makefile consists of a set of rules , each specifying how to compile files, generate targets, or perform other tasks related to building the project. These rules may include shell commands as well as custom commands defined within the Makefile syntax. A rule consists of three parts : target, dependency set (prerequisites) and command set . The dependency set of a rule can be empty . Basic Syntax of Makefile Code target1: dependency set1 command set1 target2: dependency set2 command set2 ...; Explanation target : It is a file you want to create , except for a pseudo target . It can be an object file, a .cpp file, a .txt file, and so on. dependency : It is a file that a target requires during its creation. It can be an object file, a .cpp file, a .txt file, and so on. Typically, it's unnecessary to explicitly list header files because the compiler can automatically track dependencies between source files and header files. command set : It is a set of commands used to compile all dependency files into a target file. Notes: Only files listed as targets or within the dependency set will be checked for existence or modifications. How make Processes a Makefile Prerequisites Simply type the make command without any suffix or option. Ensure all source files and the Makefile are in the same folder. Steps Check for a Makefile in the current folder: If the Makefile does not exist, exit and report an error: \"No targets specified and no makefile found. Stop.\". If the Makefile is found, proceed to the next step. Identify the first target: Locate the first target in the Makefile and treat it as the final or default target. For example, in the basic rule of the makefile above, target1 is the first target. Build the dependency graph: make examines the dependencies listed in the Makefile and constructs a dependency graph. Each target can depend on other files or targets, which are updated recursively if necessary. Each node in the dependency graph represents a target or file and its associated commands, except for the leaf nodes. A child node represents a dependency of its parent (a file or target), except for the leaf nodes. Each leaf node represents a source or a library file or a target file and its command set witout any dependency. The root node represents the final target and its command set. Recursively scan the dependency graph: Traverse the dependency graph in a breadth-first manner, starting from the leaves up to the root. While scanning the tree, check if the file corresponding to the current node exists or if its timestamp is newer than the root's. If the file exists and its timestamp is not newer than the root\u2019s, continue scanning. If the file\u2019s timestamp is newer than the root\u2019s, execute the parent node's commands to rebuild it. If the file does not exist and it's not a leaf, execute its command set and rebuild it. If the file does not exist and it's a leaf with a command set, execute its command set and rebuild it. If the file does not exist and it's a leaf without a command set, exit and report an error: \"No rule to make target 'xxx', needed by 'yyy'. Stop.\". .PHONY , a Pseudo Target Syntax .PHONY: a_pseudo_target1, a_pseudo_target2, ...; Explanation and Usage A pseudo-target (also called a phony target) in a Makefile is a target that does not represent a real file . It is used to group commands or perform actions , such as cleaning up files or running non-file related tasks like tests. Since these targets do not correspond to actual files, they are marked as .PHONY to avoid conflicts with files of the same name that might exist in the directory. Example .PHONY: clean clean: rm -f *.o *.exe Implicit Rule Explanation In a Makefile, an implicit rule is a predefined or general rule that tells make how to build certain types of files automatically without explicitly specifying a rule for each file. These rules are built into make and handle common tasks like compiling .c or .cpp files into object files, linking object files into executables, and more . Common Implicit Rules Compiling .c to .o : Implicit rule: n.o : n.c Command: $(CC) -c $(CFLAGS) n.c -o n.o This rule tells make how to compile a .c file into an object ( .o ) file. Compiling .cpp to .o : Implicit rule: n.o : n.cpp Command: $(CXX) -c $(CXXFLAGS) n.cpp -o n.o Similarly, this rule tells make how to compile C++ files into object files. Linking object files into an executable: Implicit rule: prog : prog.o Command: $(CC) prog.o $(LDFLAGS) -o prog This rule links an object file into an executable. Notes Avoid using implicit rules, as they can lead to various issues. Instead, define your own rules to override them. Use the command make -r or add .SUFFIXES: to your Makefile to prevent the use of implicit rules. Variables in Makefile Explanation and Usage In a Makefile, variables are used to store values (such as flags, paths, or file lists) that can be referenced multiple times, simplifying the Makefile's maintenance. They are used in targets, dependency sets, and command sets. A variable can represent multiple targets in a pattern rule or a list of target files, allowing the pattern rule to apply to those targets. However, there is an important limitation: a variable cannot be used directly in place of the % in the target pattern. The Syntax of Defining a Variable Simple assignment ( VAR_NAME = value ): The value is expanded when the variable is used. Whenever its dependencies are updated, or anything that depends on it is modified, all related components will be updated. Immediate assignment ( VAR_NAME := value ): The value is expanded when the variable is defined. Whenever its dependencies are updated, or anything that depends on it is modified, all related components will not be updated. Conditional assignment ( VAR_NAME ?= value ): Only assigns if the variable is not already defined. Whenever its dependencies are updated, or anything that depends on it is modified, all related components will be updated. The Syntax of Referencing a Variable $(VAR_NAME) Default Variables, Common Variables, Automatic Variables, Special Symbols and Environment Variables Explanation Default variables: In Makefiles, default variables are pre-defined by make itself . They come with default values and they can be overridden in your Makefile if necessary. Common variables: In Makefiles, common variables refer to variables that are frequently used in build scripts , such as CC for the compiler or CFLAGS for compiler options. These are often user-defined or customized for specific projects. Automatic variables: In Makefile, automatic variables are predefined variables that hold specific values based on the rule being executed. These variables are automatically set by make and allow you to write more flexible and generalized rules. They represent parts of a rule, such as the target, prerequisites (prerequisities = dependencies), or the stem (The part of the file name that % matches is called the stem.) of a filename in pattern rules. Special symbols: In Makefiles, special symbols help define rules and control execution. Environment variables: In a Makefile, environment variables play an important role in controlling the build process. These variables are inherited from the shell's environment and can be used in the Makefile to set values for compilers, paths, flags, or other settings. Name of Default Variables CC : Defaults to cc . CXX : Defaults to g++ . MAKE : Defaults to make . AR : Defaults to ar . RM : Defaults to rm -f . Name of Common Variables CC : C compiler. CXX : C++ compiler. CFLAGS : Compiler flags for C. CXXFLAGS : Compiler flags for C++. LDFLAGS : Linker options. LDLIBS : Libraries to link. OBJS : List of object files. SRC : List of source files. Common Automatic Variables $@ : Represents the full target name . This is used when you need to refer to the target being generated, like in commands that create that target. $< : Refers to the first prerequisite of the target or the first dependency in the dependency set . It is often used in rules where only the first dependency is needed, like in compiling a source file. $^ : Contains all the prerequisites for the target, but with any duplicates removed . This is useful for linking or when all dependencies are needed. $+ : Similar to $^ , but includes duplicates . It is often used in cases where the order of prerequisites is significant. $? : Contains all prerequisites that are newer than the target . This is helpful for incremental builds, as it allows make to rebuild only when necessary. $* : Represents the stem of the target name , which is the part matched by the % in pattern rules. It is useful when constructing filenames based on patterns. $% : This variable is used when the target is an archive. It represents the member name being processed , which is useful for commands dealing with archive files. $$ : Used to represent a literal dollar sign ( $ ) . In commands where a dollar sign is needed (e.g., for shell commands), this is necessary to prevent it from being interpreted as the beginning of a variable. $(a function or a VAR_NAME) : Used for function calls or to evaluate the value of a variable. Some Common Special Symbols % : Wildcard used in pattern rules (matches any string). : : Separates targets from their prerequisites in rules. $ : Introduces a variable or automatic variable (e.g., $@ , $< ). @ : Represents a command prefix to suppress command echoing. - : Represents a command prefix that ignores errors for the command without causing make to exit, thereby allowing subsequent commands to execute. Environment Variables 1 The Syntax of Referencing an Environment Variable $(ENV_VAR) 2 The Syntax of Overriding an Environment Variable Use an assignment operation to assign a value to it in a Makefile: ENV_VAR = value , ENV_VAR := value or ENV_VAR ?= value . Override environment variables when invoking make from the command line: make ENV_VAR = value , make ENV_VAR := value or make ENV_VAR ?= value . 3 Important Notes Command-line precedence: Command-line variable assignments (e.g., make CC=clang ) take precedence over both environment variables and variables defined in the Makefile. Override directive: If you want to ensure that a Makefile variable cannot be overridden by the environment or the command line, you can use the override directive: override ENV_VAR = value , override ENV_VAR := value or override ENV_VAR ?= value . 4 Some Common Environment Variables in Makefiles CC : C compiler (e.g., gcc , clang ). CXX : C++ compiler. CFLAGS : C compiler flags. CXXFLAGS : C++ compiler flags. LDFLAGS : Linker flags. AR : Archiver (used for static libraries). LD : Linker. Functions in Makefiles Functions for Transforming Text (Usage) Functions allow you to do text processing in the makefile to compute the files to operate on or the commands to use in recipes. You use a function in a function call, where you give the name of the function and some text (the arguments) for the function to operate on. The result of the function\u2019s processing is substituted into the makefile at the point of the call, just as a variable might be substituted. Function Call Syntax $(func_name arg_list) ${func_name arg1, arg2, ...} More Information If you want to know more about functions in Makefiles, you can refer to <<GNU Make.pdf>> . Pattern Rules Explanation and Usage In Makefiles, pattern rules allow you to define generalized rules that apply to multiple targets with similar file extensions or naming patterns . Pattern rules use the % symbol to represent a pattern that can be matched by different file names. This is particularly useful when you have repetitive build steps, like compiling several .cpp files into .o files. Basic Syntax Code target-pattern: prerequisite-pattern command set Explanation target-pattern : The pattern for the file(s) to be created. % matches any part of the target name. prerequisite-pattern : A pattern for the required dependencies. % in this part of the rule matches the same text as in the target pattern. command set : It a set of commands to run when the pattern rule is triggered. Notes The % symbol is the only wildcard symbol available for pattern rules in Makefiles. It is specifically designed to represent a pattern wildcard that can match any part of a file name. % is used to represent a placeholder for a part of the target or prerequisite name. It matches any string of characters in the file names and is used to create general rules for targets that follow a similar pattern. The part of the file name that % matches is called the stem. The stem is used to correlate the target with the prerequisite. How to Understand the Actual Process of Pattern Rules Create a simple C/C++ project. Writing multiple simple C/C++ files. Copy the following code example into your Makefile . Execute the make command in a terminal. Check the printed information in the terminal. The printed information shows the actual process of the pattern rules of the code example. Example Without Variables Example 1: Compiling .cpp files to .o files Code %.o: %.cpp g++ -c $< -o $@ Explanation This rule applies to all .cpp files in the project and compiles them into .o object files. %.o : Target pattern that matches any .o file. %.cpp : Prerequisite pattern that matches the corresponding .cpp file. $< : Refers to the first prerequisite (the .cpp file in this case). $@ : Refers to the target (the .o file). Example 2: Creating Executables Code %: %.cpp g++ $< -o $@ Explanation This rule compiles .cpp files into executable files directly. % : Represents any executable name without any suffix. %.cpp : The prerequisite is a .cpp file with the same base name as the target. $< : Refers to the .cpp file. $@ : Refers to the executable. Example 3: Custom Pattern Rule Code build/%: src/%.cpp g++ -Wall $< -o $@ Explanation This rule apply a custom command to get dependencies from src/ and generate targets into build/ . Targets files in the build/ directory. Matches .cpp files in the src/ directory. The g++ -Wall command is applied to the matched files. Example 4: Chaining Pattern Rules Code %.o: %.cpp g++ -c $< -o $@ Exe: Main.o Fun.o g++ Main.o Fun.o -o Exe Explanation Pattern rules can be chained, meaning one pattern rule can produce an intermediate file, which can then be used as a prerequisite for another pattern rule. In this case, .cpp files are first compiled into .o files, which are then linked together to produce the app executable. Example 5: Using $* for Matching Stems Code %.test: %.o ./run_tests $* Explanation This pattern rule applies to any .test file, using the corresponding .o file as a prerequisite. $* represents the stem. The part of the file name that % matches is called the stem. The stem is used to correlate the target with the prerequisite. Example With Variables Example 1: Using Variables for File Extensions Code EXT = cpp %.o: %.$(EXT) g++ -c $< -o $@ Explanation Define a variable to hold file extensions, and then use that variable in a pattern rule. EXT = cpp : Defines a variable EXT with the value cpp. %.o: %.$(EXT) : Matches any .cpp file (or whatever extension is stored in EXT ) to produce a .o file. $< and $@ : Standard automatic variables for prerequisites and targets. Example 2: Using Variables for Directories Code SRC_DIR = src BUILD_DIR = build $(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp g++ -c $< -o $@ Explanation Define a variable to to specify directory paths in pattern rules. This is useful if your source files and build outputs are in different directories. SRC_DIR and BUILD_DIR: Variables for source and build directories. $(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp : For any .cpp file in src/ , compile it into a .o file in build/ . $< : Refers to the prerequisite (the .cpp file). $@ : Refers to the target (the .o file). Example 3: Using Variables for Compiler and Flags Code CC = g++ CFLAGS = -Wall -O2 %.o: %.cpp $(CC) $(CFLAGS) -c $< -o $@ Explanation Define the compiler and compilation flags using variables and use them within the pattern rule. CC = g++ : Defines the compiler variable. CFLAGS = -Wall -O2 : Defines the flags to be used during compilation. $(CC) $(CFLAGS) : Expands to the actual compiler command with flags inside the pattern rule. Example 4: Using Variables for Custom Commands Code LINTER = cppcheck %.lint: %.cpp $(LINTER) $< Explanation Store a command in a variable and use it within a rule. This rule runs a linting tool ( cppcheck in this case) on every .cpp file and creates a .lint file. Example 5: Combining Multiple Variables Code SRC_DIR = src OBJ_DIR = obj CC = g++ CFLAGS = -O2 -Wall $(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp $(CC) $(CFLAGS) -c $< -o $@ Explanation Combine multiple variables in a single pattern rule to control paths, files, and commands flexibly. Compile each .cpp file from src/ into a corresponding .o file in the obj/ directory. The compiler and flags are customizable through variables ( CC and CFLAGS ). Example 6: Using a Variable for a List of Targets Code OBJS = Main.o Fun.o FunN.o $(OBJS): %.o: %.cpp g++ -c $< -o $@ Explanation Define a variable that contains a list of targets and use it with a pattern rule. OBJS : A variable containing a list of object files ( Main.o , Fun.o , FunN.o ). $(OBJS): %.o: %.cpp : A pattern rule that applies to all targets in the OBJS list, and the % matches the base name of the file. Example 7: Using a Variable with Multiple Targets for an Executable Code OBJS = Main.o Fun.o FunN.o EXEC = Main.exe $(EXEC): $(OBJS) g++ $(OBJS) -o $(EXEC) Explanation Define two variables: one containing a list of .o and the other containing a target separately, and use them with a pattern rule.. OBJS : A list of object files ( Main.o , Fun.o , FunN.o ). $(EXEC) : The name of the executable ( Main.exe ). g++ $(OBJS) -o $(EXEC) : Links the object files into the executable. Example 9: Using a Variable for Source Files and a Pattern Rule to Compile Them Code SRCS = Main.cpp Fun.cpp FunN.cpp OBJS = $(SRCS:.cpp=.o) $(OBJS): %.o: %.cpp g++ -c $< -o $@ Explanation Use a variable to represent multiple source files and compile them into object files SRCS : A variable containing a list of .cpp source files. OBJS : A variable that automatically transforms the .cpp file list in SRCS into a list of corresponding .o files. $(OBJS): %.o: %.cpp : A pattern rule that applies to all the object files in OBJS , and each .cpp file will be compiled to its corresponding .o file. Example 10: Pattern Rule with Variable Target-pattern Using wildcard Code SRCS = $(wildcard src/\\*.cpp) OBJS = $(SRCS:src/%.cpp=build/%.o) $(OBJS): build/%.o: src/%.cpp g++ -c $< -o $@ Explanation Generate a list of files dynamically using the wildcard function and apply a pattern rule to them. SRCS : Uses wildcard to get all .cpp files in the src/ directory. OBJS : Automatically generates a list of object files in the build/ directory. $(OBJS): build/%.o: src/%.cpp : A pattern rule that applies to each .cpp file in src/ and compiles it into its corresponding .o file in build/ . Example 11: Pattern Rule with a Prefix Code # List all .cpp files, .o files, and .so files SRCS = Main.cpp Fun.cpp FunN.cpp OBJS = Main.o SHARED_LIBS = libFun.so libFunN.so TARGET = Main.exe PREFIX = lib $(TARGET): $(OBJS) $(STATIC_LIBS) $(SHARED_LIBS) $(CC) -o $@ $< -L. -lFun -lFunN # Pattern rules: %.o: %.cpp $(CC) -c -fPIC -o $@ $< # Rule to create the shared library from Fun.cpp $(SHARED_LIBS): $(PREFIX)%.so: %.o $(CC) -shared -o $@ $< Explanation Generate shared libraries and link them into a final executable. $(SHARED_LIBS): $(PREFIX)%.so: %.o : A pattern rule that applies to each $(PREFIX)%.so file in $(SHARED_LIBS) , and each .o file is compiled into its corresponding $(PREFIX)%.so file. Example 12: Limitations and an Error Demonstration Code TARGET_PATTERN = %.o $(TARGET_PATTERN): %.cpp g++ -c $< -o $@ Explanation The target-pattern itself cannot directly contain a variable that includes a % . TARGET_PATTERN : A variable contains a % . This is a wrong demonstration. How to Process Header Files Effectively Problem I have introduced the common knowledge regarding custom rules, implicit rules, and pattern rules. However, these rules cannot process header files effectively. The make command cannot determine which header files the C/C++ files depend on. These dependencies are only identified when the compiler processes the C/C++ files, and there isn't a straightforward name-mapping rule. Consequently, issues arise: if any header files are updated, the make command remains unaware of the modifications and does nothing to update the project. Solution Code .PHONY: clean # Define the compiler variable CC = g++ # List all .cpp files SRCS = $(wildcard *.cpp) # Generate a list of .o files from SRCS OBJS = $(SRCS:.cpp=.o) # Generate a list of .d files from SRCS DEPS = $(SRCS:.cpp=.d) TARGET = Main.exe # Default target: $(TARGET): $(OBJS) $(CC) -o $@ $^ # The rule for # xyz.d is generated by xyz.cpp: %.d: %.cpp $(CC) -MM $< > $@ # Pattern rules: %.o: %.cpp $(CC) -c -o $@ $< clean: rm -rf *.o *.d $(TARGET) # Include all .d files: include $(DEPS) Explanation gcc -MM and g++ -MM can identify the header dependencies of the source file. include $(DEPS) : This line includes all the .d files in the Makefile. It tells make to use the dependency information to track changes to header files. Some Common make command make For the default make command, please refer to How to Understand the Actual Process of Pattern Rules Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. make -jn This flag -j allows make to run multiple jobs in parallel, speeding up the build process by utilizing multiple CPU cores. The number n ( n \u2265 1 )following -j (if provided) specifies the maximum number of jobs to run simultaneously. Without a number n , make will use a default value. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. make target_name This command tells make to build a specific target named target_name as defined in the Makefile. If target_name has prerequisites, make will first build those before building the specified target. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. make -C a_path The -C option changes the directory to a_path before executing the make command. This allows you to run make in a different directory than the current one, where the Makefile is located. If no target is specified, make will build the default target defined in the Makefile in that directory. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. make -C a_path target_name Similar to the previous command, this changes the directory to a_path and then builds the specified target_name defined in the Makefile located in that directory. This allows you to target specific builds in different directories. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. make target_name VAR_NAME1=\"...\" VAR_NAME2=\"...\" ... This command builds the specified target_name while overriding or setting variables VAR_NAME1 and VAR_NAME2 to the specified values. These variables can be used in the Makefile to customize the build process or pass configuration options. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. make -C a_path target_name VAR_NAME1=\"...\" VAR_NAME2=\"...\" ... This command combines the previous concepts. It changes the directory to a_path , builds the specified target_name , and overrides or sets the variables VAR_NAME1 and VAR_NAME2 for that build. This allows for targeted builds in different directories with specific configurations. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option. How to Manage Libraries or Dependencies Your Project Denpends On Add source code for dependencies: Include the source code of your dependencies in your project and build them from scratch. Compile them into static or dynamic libraries: Compile the dependencies as either static libraries or dynamic libraries, depending on your project's needs. Link against binaries (if no source code available): If you lack access to the source code, time to set them up, or prefer not to, linking against pre-built binaries is also an option. Build from source if binaries aren't available: If binaries for your dependencies aren't available, you'll need to download and build their source code from scratch. Include directories and libraries: Make sure to include the dependencies' header directories and library/link directories. Header directories contain the files required for inclusion in your code, while library directories contain the pre-built binary files for linking. Header files provide declarations, and library files contain definitions that link your code with these binaries. Static ( .lib or .a ) vs dynamic libraries ( .dll or .so ): Linking with static libraries is faster than dynamic libraries because the C++ linker performs optimizations during static linking. Import libraries ( xxxdll.lib files): These files contain references to functions and symbols defined in the xxx.dll files, allowing linking at compile time , ensuring that the correct function signatures and addresses are used and allowing the linker to know where to find them at runtime. Use relative paths: When building dependencies from scratch, use relative paths instead of absolute paths to ensure portability. Header file inclusion: Use angle brackets ( <> ) to include header files if you\u2019ve specified the paths for the compiler (compiler include paths). Otherwise, use quotes ( \"\" ) for relative paths. The search order for quoted includes starts with relative paths, followed by the main .cpp files, and finally, the compiler include paths. It\u2019s recommended to use angle brackets for external headers and quotes for project-specific headers. Prefer compiler include paths over relative paths to avoid common errors. Visual Studio project and solution: In Visual Studio, a project contains the code, resources, and configuration needed to build an executable, library, or component. A solution acts as a container that groups multiple related projects, providing organizational structure for managing them.","title":"make and Makefiles"},{"location":"makeAndMakefiles/#make-and-makefile","text":"","title":"make and Makefile"},{"location":"makeAndMakefiles/#make","text":"The make command is a build automation tool primarily used for compiling and building projects in C, C++, and other programming languages. It simplifies the process of compiling code, linking libraries, and creating executables by reading instructions from a configuration file called a Makefile. Additionally, it checks the return value of each executed command in the Makefile. If a command returns an error ( a non-zero value ), make will exit .","title":"make"},{"location":"makeAndMakefiles/#makefile","text":"A Makefile consists of a set of rules , each specifying how to compile files, generate targets, or perform other tasks related to building the project. These rules may include shell commands as well as custom commands defined within the Makefile syntax. A rule consists of three parts : target, dependency set (prerequisites) and command set . The dependency set of a rule can be empty .","title":"Makefile"},{"location":"makeAndMakefiles/#basic-syntax-of-makefile","text":"","title":"Basic Syntax of Makefile"},{"location":"makeAndMakefiles/#code","text":"target1: dependency set1 command set1 target2: dependency set2 command set2 ...;","title":"Code"},{"location":"makeAndMakefiles/#explanation","text":"target : It is a file you want to create , except for a pseudo target . It can be an object file, a .cpp file, a .txt file, and so on. dependency : It is a file that a target requires during its creation. It can be an object file, a .cpp file, a .txt file, and so on. Typically, it's unnecessary to explicitly list header files because the compiler can automatically track dependencies between source files and header files. command set : It is a set of commands used to compile all dependency files into a target file. Notes: Only files listed as targets or within the dependency set will be checked for existence or modifications.","title":"Explanation"},{"location":"makeAndMakefiles/#how-make-processes-a-makefile","text":"","title":"How make Processes a Makefile"},{"location":"makeAndMakefiles/#prerequisites","text":"Simply type the make command without any suffix or option. Ensure all source files and the Makefile are in the same folder.","title":"Prerequisites"},{"location":"makeAndMakefiles/#steps","text":"Check for a Makefile in the current folder: If the Makefile does not exist, exit and report an error: \"No targets specified and no makefile found. Stop.\". If the Makefile is found, proceed to the next step. Identify the first target: Locate the first target in the Makefile and treat it as the final or default target. For example, in the basic rule of the makefile above, target1 is the first target. Build the dependency graph: make examines the dependencies listed in the Makefile and constructs a dependency graph. Each target can depend on other files or targets, which are updated recursively if necessary. Each node in the dependency graph represents a target or file and its associated commands, except for the leaf nodes. A child node represents a dependency of its parent (a file or target), except for the leaf nodes. Each leaf node represents a source or a library file or a target file and its command set witout any dependency. The root node represents the final target and its command set. Recursively scan the dependency graph: Traverse the dependency graph in a breadth-first manner, starting from the leaves up to the root. While scanning the tree, check if the file corresponding to the current node exists or if its timestamp is newer than the root's. If the file exists and its timestamp is not newer than the root\u2019s, continue scanning. If the file\u2019s timestamp is newer than the root\u2019s, execute the parent node's commands to rebuild it. If the file does not exist and it's not a leaf, execute its command set and rebuild it. If the file does not exist and it's a leaf with a command set, execute its command set and rebuild it. If the file does not exist and it's a leaf without a command set, exit and report an error: \"No rule to make target 'xxx', needed by 'yyy'. Stop.\".","title":"Steps"},{"location":"makeAndMakefiles/#phony-a-pseudo-target","text":"","title":".PHONY, a Pseudo Target"},{"location":"makeAndMakefiles/#syntax","text":".PHONY: a_pseudo_target1, a_pseudo_target2, ...;","title":"Syntax"},{"location":"makeAndMakefiles/#explanation-and-usage","text":"A pseudo-target (also called a phony target) in a Makefile is a target that does not represent a real file . It is used to group commands or perform actions , such as cleaning up files or running non-file related tasks like tests. Since these targets do not correspond to actual files, they are marked as .PHONY to avoid conflicts with files of the same name that might exist in the directory.","title":"Explanation and Usage"},{"location":"makeAndMakefiles/#example","text":".PHONY: clean clean: rm -f *.o *.exe","title":"Example"},{"location":"makeAndMakefiles/#implicit-rule","text":"","title":"Implicit Rule"},{"location":"makeAndMakefiles/#explanation_1","text":"In a Makefile, an implicit rule is a predefined or general rule that tells make how to build certain types of files automatically without explicitly specifying a rule for each file. These rules are built into make and handle common tasks like compiling .c or .cpp files into object files, linking object files into executables, and more .","title":"Explanation"},{"location":"makeAndMakefiles/#common-implicit-rules","text":"Compiling .c to .o : Implicit rule: n.o : n.c Command: $(CC) -c $(CFLAGS) n.c -o n.o This rule tells make how to compile a .c file into an object ( .o ) file. Compiling .cpp to .o : Implicit rule: n.o : n.cpp Command: $(CXX) -c $(CXXFLAGS) n.cpp -o n.o Similarly, this rule tells make how to compile C++ files into object files. Linking object files into an executable: Implicit rule: prog : prog.o Command: $(CC) prog.o $(LDFLAGS) -o prog This rule links an object file into an executable.","title":"Common Implicit Rules"},{"location":"makeAndMakefiles/#notes","text":"Avoid using implicit rules, as they can lead to various issues. Instead, define your own rules to override them. Use the command make -r or add .SUFFIXES: to your Makefile to prevent the use of implicit rules.","title":"Notes"},{"location":"makeAndMakefiles/#variables-in-makefile","text":"","title":"Variables in Makefile"},{"location":"makeAndMakefiles/#explanation-and-usage_1","text":"In a Makefile, variables are used to store values (such as flags, paths, or file lists) that can be referenced multiple times, simplifying the Makefile's maintenance. They are used in targets, dependency sets, and command sets. A variable can represent multiple targets in a pattern rule or a list of target files, allowing the pattern rule to apply to those targets. However, there is an important limitation: a variable cannot be used directly in place of the % in the target pattern.","title":"Explanation and Usage"},{"location":"makeAndMakefiles/#the-syntax-of-defining-a-variable","text":"Simple assignment ( VAR_NAME = value ): The value is expanded when the variable is used. Whenever its dependencies are updated, or anything that depends on it is modified, all related components will be updated. Immediate assignment ( VAR_NAME := value ): The value is expanded when the variable is defined. Whenever its dependencies are updated, or anything that depends on it is modified, all related components will not be updated. Conditional assignment ( VAR_NAME ?= value ): Only assigns if the variable is not already defined. Whenever its dependencies are updated, or anything that depends on it is modified, all related components will be updated.","title":"The Syntax of Defining a Variable"},{"location":"makeAndMakefiles/#the-syntax-of-referencing-a-variable","text":"$(VAR_NAME)","title":"The Syntax of Referencing a Variable"},{"location":"makeAndMakefiles/#default-variables-common-variables-automatic-variables-special-symbols-and-environment-variables","text":"","title":"Default Variables, Common Variables, Automatic Variables, Special Symbols and Environment Variables"},{"location":"makeAndMakefiles/#explanation_2","text":"Default variables: In Makefiles, default variables are pre-defined by make itself . They come with default values and they can be overridden in your Makefile if necessary. Common variables: In Makefiles, common variables refer to variables that are frequently used in build scripts , such as CC for the compiler or CFLAGS for compiler options. These are often user-defined or customized for specific projects. Automatic variables: In Makefile, automatic variables are predefined variables that hold specific values based on the rule being executed. These variables are automatically set by make and allow you to write more flexible and generalized rules. They represent parts of a rule, such as the target, prerequisites (prerequisities = dependencies), or the stem (The part of the file name that % matches is called the stem.) of a filename in pattern rules. Special symbols: In Makefiles, special symbols help define rules and control execution. Environment variables: In a Makefile, environment variables play an important role in controlling the build process. These variables are inherited from the shell's environment and can be used in the Makefile to set values for compilers, paths, flags, or other settings.","title":"Explanation"},{"location":"makeAndMakefiles/#name-of-default-variables","text":"CC : Defaults to cc . CXX : Defaults to g++ . MAKE : Defaults to make . AR : Defaults to ar . RM : Defaults to rm -f .","title":"Name of Default Variables"},{"location":"makeAndMakefiles/#name-of-common-variables","text":"CC : C compiler. CXX : C++ compiler. CFLAGS : Compiler flags for C. CXXFLAGS : Compiler flags for C++. LDFLAGS : Linker options. LDLIBS : Libraries to link. OBJS : List of object files. SRC : List of source files.","title":"Name of Common Variables"},{"location":"makeAndMakefiles/#common-automatic-variables","text":"$@ : Represents the full target name . This is used when you need to refer to the target being generated, like in commands that create that target. $< : Refers to the first prerequisite of the target or the first dependency in the dependency set . It is often used in rules where only the first dependency is needed, like in compiling a source file. $^ : Contains all the prerequisites for the target, but with any duplicates removed . This is useful for linking or when all dependencies are needed. $+ : Similar to $^ , but includes duplicates . It is often used in cases where the order of prerequisites is significant. $? : Contains all prerequisites that are newer than the target . This is helpful for incremental builds, as it allows make to rebuild only when necessary. $* : Represents the stem of the target name , which is the part matched by the % in pattern rules. It is useful when constructing filenames based on patterns. $% : This variable is used when the target is an archive. It represents the member name being processed , which is useful for commands dealing with archive files. $$ : Used to represent a literal dollar sign ( $ ) . In commands where a dollar sign is needed (e.g., for shell commands), this is necessary to prevent it from being interpreted as the beginning of a variable. $(a function or a VAR_NAME) : Used for function calls or to evaluate the value of a variable.","title":"Common Automatic Variables"},{"location":"makeAndMakefiles/#some-common-special-symbols","text":"% : Wildcard used in pattern rules (matches any string). : : Separates targets from their prerequisites in rules. $ : Introduces a variable or automatic variable (e.g., $@ , $< ). @ : Represents a command prefix to suppress command echoing. - : Represents a command prefix that ignores errors for the command without causing make to exit, thereby allowing subsequent commands to execute.","title":"Some Common Special Symbols"},{"location":"makeAndMakefiles/#environment-variables","text":"","title":"Environment Variables"},{"location":"makeAndMakefiles/#1-the-syntax-of-referencing-an-environment-variable","text":"$(ENV_VAR)","title":"1 The Syntax of Referencing an Environment Variable"},{"location":"makeAndMakefiles/#2-the-syntax-of-overriding-an-environment-variable","text":"Use an assignment operation to assign a value to it in a Makefile: ENV_VAR = value , ENV_VAR := value or ENV_VAR ?= value . Override environment variables when invoking make from the command line: make ENV_VAR = value , make ENV_VAR := value or make ENV_VAR ?= value .","title":"2 The Syntax of Overriding an Environment Variable"},{"location":"makeAndMakefiles/#3-important-notes","text":"Command-line precedence: Command-line variable assignments (e.g., make CC=clang ) take precedence over both environment variables and variables defined in the Makefile. Override directive: If you want to ensure that a Makefile variable cannot be overridden by the environment or the command line, you can use the override directive: override ENV_VAR = value , override ENV_VAR := value or override ENV_VAR ?= value .","title":"3 Important Notes"},{"location":"makeAndMakefiles/#4-some-common-environment-variables-in-makefiles","text":"CC : C compiler (e.g., gcc , clang ). CXX : C++ compiler. CFLAGS : C compiler flags. CXXFLAGS : C++ compiler flags. LDFLAGS : Linker flags. AR : Archiver (used for static libraries). LD : Linker.","title":"4 Some Common Environment Variables in Makefiles"},{"location":"makeAndMakefiles/#functions-in-makefiles","text":"","title":"Functions in Makefiles"},{"location":"makeAndMakefiles/#functions-for-transforming-text-usage","text":"Functions allow you to do text processing in the makefile to compute the files to operate on or the commands to use in recipes. You use a function in a function call, where you give the name of the function and some text (the arguments) for the function to operate on. The result of the function\u2019s processing is substituted into the makefile at the point of the call, just as a variable might be substituted.","title":"Functions for Transforming Text (Usage)"},{"location":"makeAndMakefiles/#function-call-syntax","text":"$(func_name arg_list) ${func_name arg1, arg2, ...}","title":"Function Call Syntax"},{"location":"makeAndMakefiles/#more-information","text":"If you want to know more about functions in Makefiles, you can refer to <<GNU Make.pdf>> .","title":"More Information"},{"location":"makeAndMakefiles/#pattern-rules","text":"","title":"Pattern Rules"},{"location":"makeAndMakefiles/#explanation-and-usage_2","text":"In Makefiles, pattern rules allow you to define generalized rules that apply to multiple targets with similar file extensions or naming patterns . Pattern rules use the % symbol to represent a pattern that can be matched by different file names. This is particularly useful when you have repetitive build steps, like compiling several .cpp files into .o files.","title":"Explanation and Usage"},{"location":"makeAndMakefiles/#basic-syntax","text":"","title":"Basic Syntax"},{"location":"makeAndMakefiles/#code_1","text":"target-pattern: prerequisite-pattern command set","title":"Code"},{"location":"makeAndMakefiles/#explanation_3","text":"target-pattern : The pattern for the file(s) to be created. % matches any part of the target name. prerequisite-pattern : A pattern for the required dependencies. % in this part of the rule matches the same text as in the target pattern. command set : It a set of commands to run when the pattern rule is triggered.","title":"Explanation"},{"location":"makeAndMakefiles/#notes_1","text":"The % symbol is the only wildcard symbol available for pattern rules in Makefiles. It is specifically designed to represent a pattern wildcard that can match any part of a file name. % is used to represent a placeholder for a part of the target or prerequisite name. It matches any string of characters in the file names and is used to create general rules for targets that follow a similar pattern. The part of the file name that % matches is called the stem. The stem is used to correlate the target with the prerequisite.","title":"Notes"},{"location":"makeAndMakefiles/#how-to-understand-the-actual-process-of-pattern-rules","text":"Create a simple C/C++ project. Writing multiple simple C/C++ files. Copy the following code example into your Makefile . Execute the make command in a terminal. Check the printed information in the terminal. The printed information shows the actual process of the pattern rules of the code example.","title":"How to Understand the Actual Process of Pattern Rules"},{"location":"makeAndMakefiles/#example-without-variables","text":"","title":"Example Without Variables"},{"location":"makeAndMakefiles/#example-1-compiling-cpp-files-to-o-files","text":"","title":"Example 1: Compiling .cpp files to .o files"},{"location":"makeAndMakefiles/#code_2","text":"%.o: %.cpp g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_4","text":"This rule applies to all .cpp files in the project and compiles them into .o object files. %.o : Target pattern that matches any .o file. %.cpp : Prerequisite pattern that matches the corresponding .cpp file. $< : Refers to the first prerequisite (the .cpp file in this case). $@ : Refers to the target (the .o file).","title":"Explanation"},{"location":"makeAndMakefiles/#example-2-creating-executables","text":"","title":"Example 2: Creating Executables"},{"location":"makeAndMakefiles/#code_3","text":"%: %.cpp g++ $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_5","text":"This rule compiles .cpp files into executable files directly. % : Represents any executable name without any suffix. %.cpp : The prerequisite is a .cpp file with the same base name as the target. $< : Refers to the .cpp file. $@ : Refers to the executable.","title":"Explanation"},{"location":"makeAndMakefiles/#example-3-custom-pattern-rule","text":"","title":"Example 3: Custom Pattern Rule"},{"location":"makeAndMakefiles/#code_4","text":"build/%: src/%.cpp g++ -Wall $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_6","text":"This rule apply a custom command to get dependencies from src/ and generate targets into build/ . Targets files in the build/ directory. Matches .cpp files in the src/ directory. The g++ -Wall command is applied to the matched files.","title":"Explanation"},{"location":"makeAndMakefiles/#example-4-chaining-pattern-rules","text":"","title":"Example 4: Chaining Pattern Rules"},{"location":"makeAndMakefiles/#code_5","text":"%.o: %.cpp g++ -c $< -o $@ Exe: Main.o Fun.o g++ Main.o Fun.o -o Exe","title":"Code"},{"location":"makeAndMakefiles/#explanation_7","text":"Pattern rules can be chained, meaning one pattern rule can produce an intermediate file, which can then be used as a prerequisite for another pattern rule. In this case, .cpp files are first compiled into .o files, which are then linked together to produce the app executable.","title":"Explanation"},{"location":"makeAndMakefiles/#example-5-using-for-matching-stems","text":"","title":"Example 5: Using $* for Matching Stems"},{"location":"makeAndMakefiles/#code_6","text":"%.test: %.o ./run_tests $*","title":"Code"},{"location":"makeAndMakefiles/#explanation_8","text":"This pattern rule applies to any .test file, using the corresponding .o file as a prerequisite. $* represents the stem. The part of the file name that % matches is called the stem. The stem is used to correlate the target with the prerequisite.","title":"Explanation"},{"location":"makeAndMakefiles/#example-with-variables","text":"","title":"Example With Variables"},{"location":"makeAndMakefiles/#example-1-using-variables-for-file-extensions","text":"","title":"Example 1: Using Variables for File Extensions"},{"location":"makeAndMakefiles/#code_7","text":"EXT = cpp %.o: %.$(EXT) g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_9","text":"Define a variable to hold file extensions, and then use that variable in a pattern rule. EXT = cpp : Defines a variable EXT with the value cpp. %.o: %.$(EXT) : Matches any .cpp file (or whatever extension is stored in EXT ) to produce a .o file. $< and $@ : Standard automatic variables for prerequisites and targets.","title":"Explanation"},{"location":"makeAndMakefiles/#example-2-using-variables-for-directories","text":"","title":"Example 2: Using Variables for Directories"},{"location":"makeAndMakefiles/#code_8","text":"SRC_DIR = src BUILD_DIR = build $(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_10","text":"Define a variable to to specify directory paths in pattern rules. This is useful if your source files and build outputs are in different directories. SRC_DIR and BUILD_DIR: Variables for source and build directories. $(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp : For any .cpp file in src/ , compile it into a .o file in build/ . $< : Refers to the prerequisite (the .cpp file). $@ : Refers to the target (the .o file).","title":"Explanation"},{"location":"makeAndMakefiles/#example-3-using-variables-for-compiler-and-flags","text":"","title":"Example 3: Using Variables for Compiler and Flags"},{"location":"makeAndMakefiles/#code_9","text":"CC = g++ CFLAGS = -Wall -O2 %.o: %.cpp $(CC) $(CFLAGS) -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_11","text":"Define the compiler and compilation flags using variables and use them within the pattern rule. CC = g++ : Defines the compiler variable. CFLAGS = -Wall -O2 : Defines the flags to be used during compilation. $(CC) $(CFLAGS) : Expands to the actual compiler command with flags inside the pattern rule.","title":"Explanation"},{"location":"makeAndMakefiles/#example-4-using-variables-for-custom-commands","text":"","title":"Example 4: Using Variables for Custom Commands"},{"location":"makeAndMakefiles/#code_10","text":"LINTER = cppcheck %.lint: %.cpp $(LINTER) $<","title":"Code"},{"location":"makeAndMakefiles/#explanation_12","text":"Store a command in a variable and use it within a rule. This rule runs a linting tool ( cppcheck in this case) on every .cpp file and creates a .lint file.","title":"Explanation"},{"location":"makeAndMakefiles/#example-5-combining-multiple-variables","text":"","title":"Example 5: Combining Multiple Variables"},{"location":"makeAndMakefiles/#code_11","text":"SRC_DIR = src OBJ_DIR = obj CC = g++ CFLAGS = -O2 -Wall $(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp $(CC) $(CFLAGS) -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_13","text":"Combine multiple variables in a single pattern rule to control paths, files, and commands flexibly. Compile each .cpp file from src/ into a corresponding .o file in the obj/ directory. The compiler and flags are customizable through variables ( CC and CFLAGS ).","title":"Explanation"},{"location":"makeAndMakefiles/#example-6-using-a-variable-for-a-list-of-targets","text":"","title":"Example 6: Using a Variable for a List of Targets"},{"location":"makeAndMakefiles/#code_12","text":"OBJS = Main.o Fun.o FunN.o $(OBJS): %.o: %.cpp g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_14","text":"Define a variable that contains a list of targets and use it with a pattern rule. OBJS : A variable containing a list of object files ( Main.o , Fun.o , FunN.o ). $(OBJS): %.o: %.cpp : A pattern rule that applies to all targets in the OBJS list, and the % matches the base name of the file.","title":"Explanation"},{"location":"makeAndMakefiles/#example-7-using-a-variable-with-multiple-targets-for-an-executable","text":"","title":"Example 7: Using a Variable with Multiple Targets for an Executable"},{"location":"makeAndMakefiles/#code_13","text":"OBJS = Main.o Fun.o FunN.o EXEC = Main.exe $(EXEC): $(OBJS) g++ $(OBJS) -o $(EXEC)","title":"Code"},{"location":"makeAndMakefiles/#explanation_15","text":"Define two variables: one containing a list of .o and the other containing a target separately, and use them with a pattern rule.. OBJS : A list of object files ( Main.o , Fun.o , FunN.o ). $(EXEC) : The name of the executable ( Main.exe ). g++ $(OBJS) -o $(EXEC) : Links the object files into the executable.","title":"Explanation"},{"location":"makeAndMakefiles/#example-9-using-a-variable-for-source-files-and-a-pattern-rule-to-compile-them","text":"","title":"Example 9: Using a Variable for Source Files and a Pattern Rule to Compile Them"},{"location":"makeAndMakefiles/#code_14","text":"SRCS = Main.cpp Fun.cpp FunN.cpp OBJS = $(SRCS:.cpp=.o) $(OBJS): %.o: %.cpp g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_16","text":"Use a variable to represent multiple source files and compile them into object files SRCS : A variable containing a list of .cpp source files. OBJS : A variable that automatically transforms the .cpp file list in SRCS into a list of corresponding .o files. $(OBJS): %.o: %.cpp : A pattern rule that applies to all the object files in OBJS , and each .cpp file will be compiled to its corresponding .o file.","title":"Explanation"},{"location":"makeAndMakefiles/#example-10-pattern-rule-with-variable-target-pattern-using-wildcard","text":"","title":"Example 10: Pattern Rule with Variable Target-pattern Using wildcard"},{"location":"makeAndMakefiles/#code_15","text":"SRCS = $(wildcard src/\\*.cpp) OBJS = $(SRCS:src/%.cpp=build/%.o) $(OBJS): build/%.o: src/%.cpp g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_17","text":"Generate a list of files dynamically using the wildcard function and apply a pattern rule to them. SRCS : Uses wildcard to get all .cpp files in the src/ directory. OBJS : Automatically generates a list of object files in the build/ directory. $(OBJS): build/%.o: src/%.cpp : A pattern rule that applies to each .cpp file in src/ and compiles it into its corresponding .o file in build/ .","title":"Explanation"},{"location":"makeAndMakefiles/#example-11-pattern-rule-with-a-prefix","text":"","title":"Example 11: Pattern Rule with a Prefix"},{"location":"makeAndMakefiles/#code_16","text":"# List all .cpp files, .o files, and .so files SRCS = Main.cpp Fun.cpp FunN.cpp OBJS = Main.o SHARED_LIBS = libFun.so libFunN.so TARGET = Main.exe PREFIX = lib $(TARGET): $(OBJS) $(STATIC_LIBS) $(SHARED_LIBS) $(CC) -o $@ $< -L. -lFun -lFunN # Pattern rules: %.o: %.cpp $(CC) -c -fPIC -o $@ $< # Rule to create the shared library from Fun.cpp $(SHARED_LIBS): $(PREFIX)%.so: %.o $(CC) -shared -o $@ $<","title":"Code"},{"location":"makeAndMakefiles/#explanation_18","text":"Generate shared libraries and link them into a final executable. $(SHARED_LIBS): $(PREFIX)%.so: %.o : A pattern rule that applies to each $(PREFIX)%.so file in $(SHARED_LIBS) , and each .o file is compiled into its corresponding $(PREFIX)%.so file.","title":"Explanation"},{"location":"makeAndMakefiles/#example-12-limitations-and-an-error-demonstration","text":"","title":"Example 12: Limitations and an Error Demonstration"},{"location":"makeAndMakefiles/#code_17","text":"TARGET_PATTERN = %.o $(TARGET_PATTERN): %.cpp g++ -c $< -o $@","title":"Code"},{"location":"makeAndMakefiles/#explanation_19","text":"The target-pattern itself cannot directly contain a variable that includes a % . TARGET_PATTERN : A variable contains a % . This is a wrong demonstration.","title":"Explanation"},{"location":"makeAndMakefiles/#how-to-process-header-files-effectively","text":"","title":"How to Process Header Files Effectively"},{"location":"makeAndMakefiles/#problem","text":"I have introduced the common knowledge regarding custom rules, implicit rules, and pattern rules. However, these rules cannot process header files effectively. The make command cannot determine which header files the C/C++ files depend on. These dependencies are only identified when the compiler processes the C/C++ files, and there isn't a straightforward name-mapping rule. Consequently, issues arise: if any header files are updated, the make command remains unaware of the modifications and does nothing to update the project.","title":"Problem"},{"location":"makeAndMakefiles/#solution","text":"","title":"Solution"},{"location":"makeAndMakefiles/#code_18","text":".PHONY: clean # Define the compiler variable CC = g++ # List all .cpp files SRCS = $(wildcard *.cpp) # Generate a list of .o files from SRCS OBJS = $(SRCS:.cpp=.o) # Generate a list of .d files from SRCS DEPS = $(SRCS:.cpp=.d) TARGET = Main.exe # Default target: $(TARGET): $(OBJS) $(CC) -o $@ $^ # The rule for # xyz.d is generated by xyz.cpp: %.d: %.cpp $(CC) -MM $< > $@ # Pattern rules: %.o: %.cpp $(CC) -c -o $@ $< clean: rm -rf *.o *.d $(TARGET) # Include all .d files: include $(DEPS)","title":"Code"},{"location":"makeAndMakefiles/#explanation_20","text":"gcc -MM and g++ -MM can identify the header dependencies of the source file. include $(DEPS) : This line includes all the .d files in the Makefile. It tells make to use the dependency information to track changes to header files.","title":"Explanation"},{"location":"makeAndMakefiles/#some-common-make-command","text":"","title":"Some Common make command"},{"location":"makeAndMakefiles/#make_1","text":"For the default make command, please refer to How to Understand the Actual Process of Pattern Rules Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make"},{"location":"makeAndMakefiles/#make-jn","text":"This flag -j allows make to run multiple jobs in parallel, speeding up the build process by utilizing multiple CPU cores. The number n ( n \u2265 1 )following -j (if provided) specifies the maximum number of jobs to run simultaneously. Without a number n , make will use a default value. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make -jn"},{"location":"makeAndMakefiles/#make-target_name","text":"This command tells make to build a specific target named target_name as defined in the Makefile. If target_name has prerequisites, make will first build those before building the specified target. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make target_name"},{"location":"makeAndMakefiles/#make-c-a_path","text":"The -C option changes the directory to a_path before executing the make command. This allows you to run make in a different directory than the current one, where the Makefile is located. If no target is specified, make will build the default target defined in the Makefile in that directory. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make -C a_path"},{"location":"makeAndMakefiles/#make-c-a_path-target_name","text":"Similar to the previous command, this changes the directory to a_path and then builds the specified target_name defined in the Makefile located in that directory. This allows you to target specific builds in different directories. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make -C a_path target_name"},{"location":"makeAndMakefiles/#make-target_name-var_name1-var_name2","text":"This command builds the specified target_name while overriding or setting variables VAR_NAME1 and VAR_NAME2 to the specified values. These variables can be used in the Makefile to customize the build process or pass configuration options. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make target_name VAR_NAME1=\"...\" VAR_NAME2=\"...\" ..."},{"location":"makeAndMakefiles/#make-c-a_path-target_name-var_name1-var_name2","text":"This command combines the previous concepts. It changes the directory to a_path , builds the specified target_name , and overrides or sets the variables VAR_NAME1 and VAR_NAME2 for that build. This allows for targeted builds in different directories with specific configurations. Notes: If you want to use this command in Makefiles, please use $(MAKE) instead of make . This is the more commonly used option.","title":"make -C a_path target_name VAR_NAME1=\"...\" VAR_NAME2=\"...\" ..."},{"location":"makeAndMakefiles/#how-to-manage-libraries-or-dependencies-your-project-denpends-on","text":"Add source code for dependencies: Include the source code of your dependencies in your project and build them from scratch. Compile them into static or dynamic libraries: Compile the dependencies as either static libraries or dynamic libraries, depending on your project's needs. Link against binaries (if no source code available): If you lack access to the source code, time to set them up, or prefer not to, linking against pre-built binaries is also an option. Build from source if binaries aren't available: If binaries for your dependencies aren't available, you'll need to download and build their source code from scratch. Include directories and libraries: Make sure to include the dependencies' header directories and library/link directories. Header directories contain the files required for inclusion in your code, while library directories contain the pre-built binary files for linking. Header files provide declarations, and library files contain definitions that link your code with these binaries. Static ( .lib or .a ) vs dynamic libraries ( .dll or .so ): Linking with static libraries is faster than dynamic libraries because the C++ linker performs optimizations during static linking. Import libraries ( xxxdll.lib files): These files contain references to functions and symbols defined in the xxx.dll files, allowing linking at compile time , ensuring that the correct function signatures and addresses are used and allowing the linker to know where to find them at runtime. Use relative paths: When building dependencies from scratch, use relative paths instead of absolute paths to ensure portability. Header file inclusion: Use angle brackets ( <> ) to include header files if you\u2019ve specified the paths for the compiler (compiler include paths). Otherwise, use quotes ( \"\" ) for relative paths. The search order for quoted includes starts with relative paths, followed by the main .cpp files, and finally, the compiler include paths. It\u2019s recommended to use angle brackets for external headers and quotes for project-specific headers. Prefer compiler include paths over relative paths to avoid common errors. Visual Studio project and solution: In Visual Studio, a project contains the code, resources, and configuration needed to build an executable, library, or component. A solution acts as a container that groups multiple related projects, providing organizational structure for managing them.","title":"How to Manage Libraries or Dependencies Your Project Denpends On"}]}